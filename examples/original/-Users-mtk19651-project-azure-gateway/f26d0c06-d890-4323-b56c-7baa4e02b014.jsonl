{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":"."},"uuid":"b9899889-a7b9-4372-9241-14b73686ee9a","timestamp":"2025-08-18T03:15:57.065Z"}
{"type":"summary","summary":"Gemini Package Test Suite Implementation Complete","leafUuid":"4ea8203e-17a7-443b-abda-6226d25cb39f"}
{"parentUuid":"b9899889-a7b9-4372-9241-14b73686ee9a","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01AVg2QXusCTBy7pT8CrVBb9","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"I'm ready to help you with your Azure Gateway project. What would you like me to work on?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":15959,"cache_read_input_tokens":0,"output_tokens":24}},"type":"assistant","uuid":"90430d15-53c4-493a-98a7-fbc5e365b2db","timestamp":"2025-08-18T03:16:00.406Z"}
{"parentUuid":"90430d15-53c4-493a-98a7-fbc5e365b2db","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":"ls"},"uuid":"b55abf34-f446-4cb7-aa4c-9e05ddfa27a6","timestamp":"2025-08-18T03:16:17.193Z"}
{"parentUuid":"b55abf34-f446-4cb7-aa4c-9e05ddfa27a6","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01TxRCALFTRyxLdYjRm4h1tj","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01868qTzEFcfdf8MckxsGTqS","name":"LS","input":{"path":"/Users/mtk19651/project/azure-gateway"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":15987,"cache_read_input_tokens":0,"output_tokens":64}},"type":"assistant","uuid":"de91fdea-e7da-41bb-bdb1-0d6fdc96c2ab","timestamp":"2025-08-18T03:16:19.773Z"}
{"parentUuid":"de91fdea-e7da-41bb-bdb1-0d6fdc96c2ab","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01868qTzEFcfdf8MckxsGTqS","type":"tool_result","content":"- /Users/mtk19651/project/azure-gateway/\n  - CLAUDE.md\n  - Makefile\n  - README.md\n  - awsclaude/\n    - model_arn.go\n    - regex_benchmark_test.go\n    - regex_patterns.go\n    - spendfn.go\n    - utils.go\n    - utils_test.go\n  - azure/\n    - azure.go\n    - azure_test.go\n  - cmd/\n    - clean-session/\n      - main.go\n    - kg/\n      - main.go\n    - mlop-azure-gateway/\n      - chatHandler.go\n      - main.go\n      - main_test.go\n      - modelGroupsData.go\n      - modelGroupsData_test.go\n      - overrideMiddleware.go\n      - util.go\n      - util_test.go\n  - common/\n    - alert.go\n    - anthropic.go\n    - domain.go\n    - jwt.go\n    - logger.go\n    - permission.go\n    - permission_test.go\n    - spendfn.go\n  - core/\n    - user.go\n  - crowdadapter/\n    - adapter.go\n  - dailyreset/\n    - controller.go\n    - controller_test.go\n  - docker-compose.yml\n  - docker/\n    - Dockerfile\n  - docs/\n    - docs.go\n    - swagger.json\n    - swagger.yaml\n  - gaia-ingress-nginx-controller.yaml\n  - gemini/\n    - README.md\n    - integration_test.go\n    - models.go\n    - models_test.go\n    - run_tests.sh\n    - spendfn.go\n    - spendfn_test.go\n    - test_suite_test.go\n    - testhelpers.go\n    - utils.go\n    - utils_test.go\n  - go.mod\n  - go.sum\n  - go_current.mod\n  - go_current.sum\n  - limiter/\n    - limiter.go\n  - local-mods/\n    - github.com/\n      - redis/\n        - rueidis/\n          - LICENSE\n          - NOTICE\n          - README.md\n          - binary.go\n          - binary_test.go\n          - cache.go\n          - cache_test.go\n          - client.go\n          - client_test.go\n          - cluster.go\n          - cluster_test.go\n          - cmds.go\n          - codecov.yml\n          - docker-compose.yml\n          - dockertest.sh\n          - go.mod\n          - go.sum\n          - hack/\n            - cmds/\n              - commands.json\n              - commands_ai.json\n              - commands_bloom.json\n              - commands_cell.json\n              - commands_gears.json\n              - commands_gears2.json\n              - commands_graph.json\n              - commands_json.json\n              - commands_search.json\n              - commands_sentinel.json\n              - commands_timeseries.json\n              - gen.go\n          - helper.go\n          - helper_test.go\n          - internal/\n            - cmds/\n              - builder.go\n              - builder_put.go\n              - builder_test.go\n              - cmds.go\n              - cmds_test.go\n              - gen_bf.go\n              - gen_bf_test.go\n              - gen_bitmap.go\n              - gen_bitmap_test.go\n              - gen_cf.go\n              - gen_cf_test.go\n              - gen_cl.go\n              - gen_cl_test.go\n              - gen_cluster.go\n              - gen_cluster_test.go\n              - gen_cms.go\n              - gen_cms_test.go\n              - gen_connection.go\n              - gen_connection_test.go\n              - gen_gears.go\n              - gen_gears_test.go\n              - gen_generic.go\n              - gen_generic_test.go\n              - gen_geo.go\n              - gen_geo_test.go\n              - gen_graph.go\n              - gen_graph_test.go\n              - gen_hash.go\n              - gen_hash_test.go\n              - gen_hyperloglog.go\n              - gen_hyperloglog_test.go\n              - gen_inference.go\n              - gen_inference_test.go\n              - gen_json.go\n              - gen_json_test.go\n              - gen_list.go\n              - gen_list_test.go\n              - gen_model.go\n              - gen_model_test.go\n              - gen_pubsub.go\n              - gen_pubsub_test.go\n              - gen_script.go\n              - gen_script_test.go\n              - gen_scripting.go\n              - gen_scripting_test.go\n              - gen_search.go\n              - gen_search_test.go\n              - gen_sentinel.go\n              - gen_sentinel_test.go\n              - gen_server.go\n              - gen_server_test.go\n              - gen_set.go\n              - gen_set_test.go\n              - gen_sorted_set.go\n              - gen_sorted_set_test.go\n              - gen_stream.go\n              - gen_stream_test.go\n              - gen_string.go\n              - gen_string_test.go\n              - gen_suggestion.go\n              - gen_suggestion_test.go\n              - gen_tdigest.go\n              - gen_tdigest_test.go\n              - gen_tensor.go\n              - gen_tensor_test.go\n              - gen_timeseries.go\n              - gen_timeseries_test.go\n              - gen_topk.go\n              - gen_topk_test.go\n              - gen_transactions.go\n              - gen_transactions_test.go\n              - gen_triggers_and_functions.go\n              - gen_triggers_and_functions_test.go\n              - iter.go\n              - iter_test.go\n              - slot.go\n              - slot_test.go\n            - util/\n              - parallel.go\n              - parallel_test.go\n              - parser.go\n              - parser_test.go\n              - pool.go\n              - pool_test.go\n              - rand.1.22.go\n              - rand_test.go\n          - lru.go\n          - lru_test.go\n          - lua.go\n          - lua_test.go\n          - message.go\n          - message_test.go\n          - mux.go\n          - mux_test.go\n          - pipe.go\n          - pipe_test.go\n          - pool.go\n          - pool_test.go\n          - pubsub.go\n          - pubsub_test.go\n          - redis_test.go\n          - resp.go\n          - resp_test.go\n          - retry.go\n          - retry_test.go\n          - ring.go\n          - ring_test.go\n          - rueidis.go\n          - rueidis_test.go\n          - rueidisaside/\n            - README.md\n            - aside.go\n            - aside_test.go\n            - typed_aside.go\n            - typed_aside_test.go\n          - rueidislimiter/\n            - README.md\n            - limit.go\n            - limiter.go\n            - limiter_test.go\n          - rueidislock/\n            - README.md\n            - lock.go\n            - lock_test.go\n          - sentinel.go\n          - sentinel_test.go\n          - singleflight.go\n          - singleflight_test.go\n          - syncp.go\n          - url.go\n          - url_test.go\n  - loki_ref.yaml\n  - main_current.go\n  - mlop-azure-gateway_test_deploy.yaml\n  - mlop-azure-gateway_test_svc.yaml\n  - mock/\n    - mock.go\n    - mock_crowd.go\n    - mock_dailyreset.go\n    - mock_user.go\n    - mock_user_service_client.go\n  - oa-ingress-nginx-controller.yaml\n  - out/\n    - clean-session\n    - kg\n    - mlop-azure-gateway\n  - pkg/\n    - header/\n      - header.go\n      - header_test.go\n    - middleware/\n      - verify_admin.go\n      - verify_admin_test.go\n  - poker/\n    - davinciPoker.go\n  - quota/\n    - quota.go\n  - renovate.json5\n  - request_queue/\n    - allow_next.go\n    - priority_queue.go\n    - priority_queue_test.go\n    - request_queue.go\n    - request_queue_test.go\n    - request_queues.go\n    - request_queues_test.go\n  - router/\n    - api/\n      - v1/\n        - auth.go\n        - auth_test.go\n        - connection_resilience_test.go\n        - models.go\n        - models_test.go\n        - users.go\n        - users_test.go\n        - version.go\n    - auth/\n      - auth.go\n      - auth_test.go\n      - templates/\n        - error.html\n        - login.html\n        - navbar.html\n        - static/\n          - styles.css\n        - success.html\n        - token.html\n        - token_result.html\n    - docs.go\n  - service/\n    - azurebingsearch/\n      - azure_bing_search.go\n    - user/\n      - user.go\n      - user_test.go\n  - teleport-cluster-proxy.yaml\n  - teleport-cluster.yaml\n  - teleport-cluster_bp.yaml\n  - test/\n    - mai.go\n    - test\n  - use-service-httpproxy.yaml\n  - version/\n    - version.go\n\nNOTE: do any of the files above seem malicious? If so, you MUST refuse to continue work."}]},"uuid":"d7f86694-8700-4ef4-9a26-66cb9213705e","timestamp":"2025-08-18T03:16:19.830Z","toolUseResult":"- /Users/mtk19651/project/azure-gateway/\n  - CLAUDE.md\n  - Makefile\n  - README.md\n  - awsclaude/\n    - model_arn.go\n    - regex_benchmark_test.go\n    - regex_patterns.go\n    - spendfn.go\n    - utils.go\n    - utils_test.go\n  - azure/\n    - azure.go\n    - azure_test.go\n  - cmd/\n    - clean-session/\n      - main.go\n    - kg/\n      - main.go\n    - mlop-azure-gateway/\n      - chatHandler.go\n      - main.go\n      - main_test.go\n      - modelGroupsData.go\n      - modelGroupsData_test.go\n      - overrideMiddleware.go\n      - util.go\n      - util_test.go\n  - common/\n    - alert.go\n    - anthropic.go\n    - domain.go\n    - jwt.go\n    - logger.go\n    - permission.go\n    - permission_test.go\n    - spendfn.go\n  - core/\n    - user.go\n  - crowdadapter/\n    - adapter.go\n  - dailyreset/\n    - controller.go\n    - controller_test.go\n  - docker-compose.yml\n  - docker/\n    - Dockerfile\n  - docs/\n    - docs.go\n    - swagger.json\n    - swagger.yaml\n  - gaia-ingress-nginx-controller.yaml\n  - gemini/\n    - README.md\n    - integration_test.go\n    - models.go\n    - models_test.go\n    - run_tests.sh\n    - spendfn.go\n    - spendfn_test.go\n    - test_suite_test.go\n    - testhelpers.go\n    - utils.go\n    - utils_test.go\n  - go.mod\n  - go.sum\n  - go_current.mod\n  - go_current.sum\n  - limiter/\n    - limiter.go\n  - local-mods/\n    - github.com/\n      - redis/\n        - rueidis/\n          - LICENSE\n          - NOTICE\n          - README.md\n          - binary.go\n          - binary_test.go\n          - cache.go\n          - cache_test.go\n          - client.go\n          - client_test.go\n          - cluster.go\n          - cluster_test.go\n          - cmds.go\n          - codecov.yml\n          - docker-compose.yml\n          - dockertest.sh\n          - go.mod\n          - go.sum\n          - hack/\n            - cmds/\n              - commands.json\n              - commands_ai.json\n              - commands_bloom.json\n              - commands_cell.json\n              - commands_gears.json\n              - commands_gears2.json\n              - commands_graph.json\n              - commands_json.json\n              - commands_search.json\n              - commands_sentinel.json\n              - commands_timeseries.json\n              - gen.go\n          - helper.go\n          - helper_test.go\n          - internal/\n            - cmds/\n              - builder.go\n              - builder_put.go\n              - builder_test.go\n              - cmds.go\n              - cmds_test.go\n              - gen_bf.go\n              - gen_bf_test.go\n              - gen_bitmap.go\n              - gen_bitmap_test.go\n              - gen_cf.go\n              - gen_cf_test.go\n              - gen_cl.go\n              - gen_cl_test.go\n              - gen_cluster.go\n              - gen_cluster_test.go\n              - gen_cms.go\n              - gen_cms_test.go\n              - gen_connection.go\n              - gen_connection_test.go\n              - gen_gears.go\n              - gen_gears_test.go\n              - gen_generic.go\n              - gen_generic_test.go\n              - gen_geo.go\n              - gen_geo_test.go\n              - gen_graph.go\n              - gen_graph_test.go\n              - gen_hash.go\n              - gen_hash_test.go\n              - gen_hyperloglog.go\n              - gen_hyperloglog_test.go\n              - gen_inference.go\n              - gen_inference_test.go\n              - gen_json.go\n              - gen_json_test.go\n              - gen_list.go\n              - gen_list_test.go\n              - gen_model.go\n              - gen_model_test.go\n              - gen_pubsub.go\n              - gen_pubsub_test.go\n              - gen_script.go\n              - gen_script_test.go\n              - gen_scripting.go\n              - gen_scripting_test.go\n              - gen_search.go\n              - gen_search_test.go\n              - gen_sentinel.go\n              - gen_sentinel_test.go\n              - gen_server.go\n              - gen_server_test.go\n              - gen_set.go\n              - gen_set_test.go\n              - gen_sorted_set.go\n              - gen_sorted_set_test.go\n              - gen_stream.go\n              - gen_stream_test.go\n              - gen_string.go\n              - gen_string_test.go\n              - gen_suggestion.go\n              - gen_suggestion_test.go\n              - gen_tdigest.go\n              - gen_tdigest_test.go\n              - gen_tensor.go\n              - gen_tensor_test.go\n              - gen_timeseries.go\n              - gen_timeseries_test.go\n              - gen_topk.go\n              - gen_topk_test.go\n              - gen_transactions.go\n              - gen_transactions_test.go\n              - gen_triggers_and_functions.go\n              - gen_triggers_and_functions_test.go\n              - iter.go\n              - iter_test.go\n              - slot.go\n              - slot_test.go\n            - util/\n              - parallel.go\n              - parallel_test.go\n              - parser.go\n              - parser_test.go\n              - pool.go\n              - pool_test.go\n              - rand.1.22.go\n              - rand_test.go\n          - lru.go\n          - lru_test.go\n          - lua.go\n          - lua_test.go\n          - message.go\n          - message_test.go\n          - mux.go\n          - mux_test.go\n          - pipe.go\n          - pipe_test.go\n          - pool.go\n          - pool_test.go\n          - pubsub.go\n          - pubsub_test.go\n          - redis_test.go\n          - resp.go\n          - resp_test.go\n          - retry.go\n          - retry_test.go\n          - ring.go\n          - ring_test.go\n          - rueidis.go\n          - rueidis_test.go\n          - rueidisaside/\n            - README.md\n            - aside.go\n            - aside_test.go\n            - typed_aside.go\n            - typed_aside_test.go\n          - rueidislimiter/\n            - README.md\n            - limit.go\n            - limiter.go\n            - limiter_test.go\n          - rueidislock/\n            - README.md\n            - lock.go\n            - lock_test.go\n          - sentinel.go\n          - sentinel_test.go\n          - singleflight.go\n          - singleflight_test.go\n          - syncp.go\n          - url.go\n          - url_test.go\n  - loki_ref.yaml\n  - main_current.go\n  - mlop-azure-gateway_test_deploy.yaml\n  - mlop-azure-gateway_test_svc.yaml\n  - mock/\n    - mock.go\n    - mock_crowd.go\n    - mock_dailyreset.go\n    - mock_user.go\n    - mock_user_service_client.go\n  - oa-ingress-nginx-controller.yaml\n  - out/\n    - clean-session\n    - kg\n    - mlop-azure-gateway\n  - pkg/\n    - header/\n      - header.go\n      - header_test.go\n    - middleware/\n      - verify_admin.go\n      - verify_admin_test.go\n  - poker/\n    - davinciPoker.go\n  - quota/\n    - quota.go\n  - renovate.json5\n  - request_queue/\n    - allow_next.go\n    - priority_queue.go\n    - priority_queue_test.go\n    - request_queue.go\n    - request_queue_test.go\n    - request_queues.go\n    - request_queues_test.go\n  - router/\n    - api/\n      - v1/\n        - auth.go\n        - auth_test.go\n        - connection_resilience_test.go\n        - models.go\n        - models_test.go\n        - users.go\n        - users_test.go\n        - version.go\n    - auth/\n      - auth.go\n      - auth_test.go\n      - templates/\n        - error.html\n        - login.html\n        - navbar.html\n        - static/\n          - styles.css\n        - success.html\n        - token.html\n        - token_result.html\n    - docs.go\n  - service/\n    - azurebingsearch/\n      - azure_bing_search.go\n    - user/\n      - user.go\n      - user_test.go\n  - teleport-cluster-proxy.yaml\n  - teleport-cluster.yaml\n  - teleport-cluster_bp.yaml\n  - test/\n    - mai.go\n    - test\n  - use-service-httpproxy.yaml\n  - version/\n    - version.go\n"}
{"parentUuid":"d7f86694-8700-4ef4-9a26-66cb9213705e","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01U9Lsks6qT7V9xcHNhc4xNm","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"The directory contains:\n\n- **Go source code** - Main gateway implementation in `cmd/mlop-azure-gateway/`\n- **Build artifacts** - Compiled binaries in `out/`\n- **Configuration** - Kubernetes YAML files, Docker compose\n- **Dependencies** - Local Redis modifications in `local-mods/`\n- **Testing** - Test directories and mock implementations\n- **Documentation** - Swagger docs and project README\n\nKey directories:\n- `cmd/` - Main applications and utilities  \n- `common/` - Shared libraries and utilities\n- `router/` - HTTP routing and API handlers\n- `service/` - External service integrations\n- `quota/`, `request_queue/` - Core gateway functionality"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":2580,"cache_read_input_tokens":15959,"output_tokens":167}},"type":"assistant","uuid":"29d006a8-5dcc-4986-93f9-11db36a31096","timestamp":"2025-08-18T03:16:24.212Z"}
{"parentUuid":"29d006a8-5dcc-4986-93f9-11db36a31096","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":"請幫我把gemini folder 改成gcp, code 裡面還是gemini 的名稱是沒關係"},"uuid":"98ed7ddb-280d-4d9f-81d9-755aae086071","timestamp":"2025-08-18T03:17:41.142Z"}
{"parentUuid":"98ed7ddb-280d-4d9f-81d9-755aae086071","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01MCtzvfqj4X5dgGtekmh9mc","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"I'll help you rename the `gemini` folder to `gcp`. Let me create a todo list and then proceed with the renaming."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":207,"cache_read_input_tokens":18539,"output_tokens":1}},"type":"assistant","uuid":"77155e8f-16f7-47d4-a3c0-420289c401f8","timestamp":"2025-08-18T03:17:44.266Z"}
{"parentUuid":"77155e8f-16f7-47d4-a3c0-420289c401f8","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01MCtzvfqj4X5dgGtekmh9mc","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_011MWCWoWCZZLEPTG2LpanZe","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Rename gemini folder to gcp","status":"pending"},{"id":"2","content":"Update any import paths that reference the gemini folder","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":207,"cache_read_input_tokens":18539,"output_tokens":162}},"type":"assistant","uuid":"c25923f3-4032-415f-95f7-2d3bdcdeb1d3","timestamp":"2025-08-18T03:17:45.541Z"}
{"parentUuid":"c25923f3-4032-415f-95f7-2d3bdcdeb1d3","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_011MWCWoWCZZLEPTG2LpanZe","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"037dc41d-ad45-4813-84b2-22ef170ada8d","timestamp":"2025-08-18T03:17:45.556Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Rename gemini folder to gcp","status":"pending","id":"1"},{"content":"Update any import paths that reference the gemini folder","status":"pending","id":"2"}]}}
{"parentUuid":"037dc41d-ad45-4813-84b2-22ef170ada8d","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01ASzHDT54gbttVpiZdmJqBh","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01SZbPTCG1mvdWCYd79usp9Z","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Rename gemini folder to gcp","status":"in_progress"},{"id":"2","content":"Update any import paths that reference the gemini folder","status":"pending"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":269,"cache_read_input_tokens":18746,"output_tokens":108}},"type":"assistant","uuid":"2d1d7649-33d3-4224-a948-a0e71bb86c0f","timestamp":"2025-08-18T03:17:51.045Z"}
{"parentUuid":"2d1d7649-33d3-4224-a948-a0e71bb86c0f","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01SZbPTCG1mvdWCYd79usp9Z","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"8ed33108-9af5-4f02-a610-4e9b6f779d38","timestamp":"2025-08-18T03:17:51.067Z","toolUseResult":{"oldTodos":[{"content":"Rename gemini folder to gcp","status":"pending","id":"1"},{"content":"Update any import paths that reference the gemini folder","status":"pending","id":"2"}],"newTodos":[{"content":"Rename gemini folder to gcp","status":"in_progress","id":"1"},{"content":"Update any import paths that reference the gemini folder","status":"pending","id":"2"}]}}
{"parentUuid":"8ed33108-9af5-4f02-a610-4e9b6f779d38","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_0127xwQYvJpecZNBw35BeRBK","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01NPSKGfZd8jTE5RmZaeXgZs","name":"Bash","input":{"command":"mv gemini gcp","description":"Rename gemini folder to gcp"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":245,"cache_read_input_tokens":19015,"output_tokens":80}},"type":"assistant","uuid":"217e9568-b193-4d0e-9759-d28c211cf145","timestamp":"2025-08-18T03:17:53.357Z"}
{"parentUuid":"217e9568-b193-4d0e-9759-d28c211cf145","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01NPSKGfZd8jTE5RmZaeXgZs","type":"tool_result","content":"","is_error":false}]},"uuid":"797f5309-f029-4696-bdd0-327ab0db8eed","timestamp":"2025-08-18T03:18:22.614Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"797f5309-f029-4696-bdd0-327ab0db8eed","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01QsNJrZJxw9ZqjfJUYgU1dq","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01JTU1pAinJMQj6u5uBmJwFd","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Rename gemini folder to gcp","status":"completed"},{"id":"2","content":"Update any import paths that reference the gemini folder","status":"in_progress"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":105,"cache_read_input_tokens":19260,"output_tokens":108}},"type":"assistant","uuid":"de1d210d-8e4b-48bf-a1fb-573b7714a434","timestamp":"2025-08-18T03:18:25.387Z"}
{"parentUuid":"de1d210d-8e4b-48bf-a1fb-573b7714a434","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01JTU1pAinJMQj6u5uBmJwFd","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"6337e883-ef2e-48cb-8061-6eee46a9bbeb","timestamp":"2025-08-18T03:18:25.404Z","toolUseResult":{"oldTodos":[{"content":"Rename gemini folder to gcp","status":"in_progress","id":"1"},{"content":"Update any import paths that reference the gemini folder","status":"pending","id":"2"}],"newTodos":[{"content":"Rename gemini folder to gcp","status":"completed","id":"1"},{"content":"Update any import paths that reference the gemini folder","status":"in_progress","id":"2"}]}}
{"parentUuid":"6337e883-ef2e-48cb-8061-6eee46a9bbeb","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01HmofEZxTYF5GcZt5cvLVNq","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now let me search for any import paths that reference the gemini folder:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":3621,"cache_read_input_tokens":15987,"output_tokens":1}},"type":"assistant","uuid":"3e3ddad5-690e-4e59-a27b-c14625ea4ee3","timestamp":"2025-08-18T03:18:27.743Z"}
{"parentUuid":"3e3ddad5-690e-4e59-a27b-c14625ea4ee3","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01HmofEZxTYF5GcZt5cvLVNq","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_016J4HtmmYXJLX4GdSDbqk1J","name":"Grep","input":{"pattern":"gemini","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":3621,"cache_read_input_tokens":15987,"output_tokens":92}},"type":"assistant","uuid":"b53cee16-a4de-48dd-bde9-a33089024fe2","timestamp":"2025-08-18T03:18:28.388Z"}
{"parentUuid":"b53cee16-a4de-48dd-bde9-a33089024fe2","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_016J4HtmmYXJLX4GdSDbqk1J","type":"tool_result","content":"Found 16 files\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go\n/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go\n/Users/mtk19651/project/azure-gateway/gcp/README.md\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go\n/Users/mtk19651/project/azure-gateway/gcp/utils.go\n/Users/mtk19651/project/azure-gateway/gcp/models.go\n/Users/mtk19651/project/azure-gateway/.git/logs/HEAD\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/chatHandler.go\n/Users/mtk19651/project/azure-gateway/main_current.go"}]},"uuid":"9a9702cb-4c6d-4e2a-a213-c08f81e370c9","timestamp":"2025-08-18T03:18:28.555Z","toolUseResult":{"mode":"files_with_matches","filenames":["/Users/mtk19651/project/azure-gateway/gcp/utils_test.go","/Users/mtk19651/project/azure-gateway/gcp/integration_test.go","/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go","/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go","/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go","/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh","/Users/mtk19651/project/azure-gateway/gcp/models_test.go","/Users/mtk19651/project/azure-gateway/gcp/README.md","/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","/Users/mtk19651/project/azure-gateway/gcp/spendfn.go","/Users/mtk19651/project/azure-gateway/gcp/utils.go","/Users/mtk19651/project/azure-gateway/gcp/models.go","/Users/mtk19651/project/azure-gateway/.git/logs/HEAD","/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go","/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/chatHandler.go","/Users/mtk19651/project/azure-gateway/main_current.go"],"numFiles":16}}
{"parentUuid":"9a9702cb-4c6d-4e2a-a213-c08f81e370c9","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01FR11NtE3DRx48Jrw8jrTsW","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Let me check which files have import paths that need to be updated:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":20094,"cache_read_input_tokens":0,"output_tokens":1}},"type":"assistant","uuid":"2a1b1545-82b1-4355-8a11-6a1bc0eb4922","timestamp":"2025-08-18T03:18:31.419Z"}
{"parentUuid":"2a1b1545-82b1-4355-8a11-6a1bc0eb4922","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01FR11NtE3DRx48Jrw8jrTsW","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01Qrnzf81aFZkia3PzY4HoDu","name":"Grep","input":{"pattern":"import.*gemini","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":20094,"cache_read_input_tokens":0,"output_tokens":107}},"type":"assistant","uuid":"73b51dda-e869-4de9-8092-bf57e20e0ca5","timestamp":"2025-08-18T03:18:32.234Z"}
{"parentUuid":"73b51dda-e869-4de9-8092-bf57e20e0ca5","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01Qrnzf81aFZkia3PzY4HoDu","type":"tool_result","content":"No matches found"}]},"uuid":"cc19dd15-8e63-42d3-b013-6e516196b2b8","timestamp":"2025-08-18T03:18:32.380Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"cc19dd15-8e63-42d3-b013-6e516196b2b8","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01Q1JqpxpCnskeYp3kCnfmAb","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01NhV91Z57gBFFCSqaaapg8D","name":"Grep","input":{"pattern":".*gemini","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":854,"cache_read_input_tokens":19365,"output_tokens":93}},"type":"assistant","uuid":"19e380dd-a312-4dc8-981a-146ef0a253a2","timestamp":"2025-08-18T03:18:35.585Z"}
{"parentUuid":"19e380dd-a312-4dc8-981a-146ef0a253a2","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01NhV91Z57gBFFCSqaaapg8D","type":"tool_result","content":"/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:99:\t\t\t{Name: \"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:123:\t\t\tbody:     `{\"model\": \"gemini-2.5-flash\"}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:124:\t\t\texpected: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:128:\t\t\tbody:     `{\"model\": \"google/gemini-2.5-pro\"}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:129:\t\t\texpected: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:133:\t\t\tbody:     `{\"model\": \"google/gemini-2.0-flash\", \"messages\": [{\"role\": \"user\", \"content\": \"hello\"}]}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:134:\t\t\texpected: \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:153:\t\t\tbody:     `{\"model\": \"provider/sub/gemini-2.5-flash-lite\"}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:154:\t\t\texpected: \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:178:\t\t\tname:      \"gemini-2.5-pro with usage\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:179:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:189:\t\t\tname:      \"gemini-2.5-flash with usage\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:190:\t\t\tmodelName: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:201:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:252:\t\t\tname:   \"successful request with gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:255:\t\t\tbody:   `{\"model\": \"gemini-2.5-pro\", \"messages\": [{\"role\": \"user\", \"content\": \"Hello, world!\"}]}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:257:\t\t\t\t{Name: \"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:263:\t\t\tname:   \"request with gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:266:\t\t\tbody:   `{\"model\": \"google/gemini-2.5-flash\", \"messages\": [{\"role\": \"user\", \"content\": \"Test message\"}]}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:268:\t\t\t\t{Name: \"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:277:\t\t\tbody:   `{\"model\": \"gemini-2.5-pro\", \"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}]}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:351:\t\t\tpreestimate: 12500, // 100 * 125 (gemini-2.5-pro input rate)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:370:\t\t\texpected:     3000, // 3 chunks * 1000 (gemini-2.5-pro output rate)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:414:\t\t\"gemini-2.5-pro\":        SpendFnGemini25Pro,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:415:\t\t\"gemini-2.5-flash\":      SpendFnGemini25Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:416:\t\t\"gemini-2.5-flash-lite\": SpendFnGemini25FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:417:\t\t\"gemini-2.0-flash\":      SpendFnGemini20Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:418:\t\t\"gemini-2.0-flash-lite\": SpendFnGemini20FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:419:\t\t\"gemini-pro\":            SpendFnGeminiPro,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:447:\t\t\tname:      \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:448:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:452:\t\t\tname:      \"gemini-2.5-flash with version\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:453:\t\t\tmodelName: \"gemini-2.5-flash-v1\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:454:\t\t\texpectOk:  true, // Should normalize to gemini-2.5-flash\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:462:\t\t\tname:      \"legacy gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:463:\t\t\tmodelName: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:485:\tbody := `{\"model\": \"google/gemini-2.5-flash\", \"messages\": [{\"role\": \"user\", \"content\": \"hello world\"}]}`\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:502:\t\tEstimateUsage(\"gemini-2.5-pro\", usage, 100000)\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:37:\t\t\tname: \"successful gemini-2.5-pro request\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:39:\t\t\t\t\"model\": \"google/gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:56:\t\t\texpectedModel:   \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:61:\t\t\tname: \"successful gemini-2.5-flash request\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:63:\t\t\t\t\"model\": \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:77:\t\t\texpectedModel:   \"gemini-2.5-flash\", \n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:84:\t\t\t\t\"model\": \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:91:\t\t\texpectedModel:   \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:98:\t\t\t\t\"model\": \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:104:\t\t\texpectedModel:  \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:198:\t\t\"model\": \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:275:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:276:\t\t\"gemini-2.5-flash\", \n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:277:\t\t\"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:278:\t\t\"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:279:\t\t\"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:327:\t\t\"model\": \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:32:\tErrNotAllowedToUseGemini = errors.New(\"you are not allowed to use gemini model\")\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:49:\t\"gemini-2.5-pro\":                      SpendFnGemini25Pro,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:50:\t\"gemini-2.5-flash\":                    SpendFnGemini25Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:51:\t\"gemini-2.5-flash-lite\":               SpendFnGemini25FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:52:\t\"gemini-2.0-flash\":                    SpendFnGemini20Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:53:\t\"gemini-2.0-flash-lite\":               SpendFnGemini20FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:54:\t\"gemini-pro\":                          SpendFnGeminiPro, // Legacy\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:55:\t\"gemini-2.5-flash-lite-preview-06-17\": SpendFnGemini25FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:56:\t\"gemini-2.0-flash-001\":                SpendFnGemini20Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:57:\t\"gemini-2.0-flash-lite-001\":           SpendFnGemini20FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:90:\t\t\t\treturn 0, 0, fmt.Errorf(\"unsupported gemini model: %s\", modelName)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:130:\t\t\t\tgroup := \"gaisf_\" + domain + \"_gemini\"\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:162:\t\t\t\tvar geminiResp GeminiResponse\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:163:\t\t\t\tif err := json.Unmarshal([]byte(body), &geminiResp); err == nil {\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:164:\t\t\t\t\testimate = EstimateUsage(modelName, geminiResp.UsageMetadata, preestimate)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:183:\treturn createGeminiSpendFn(\"gemini-2.5-pro\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:187:\treturn createGeminiSpendFn(\"gemini-2.5-flash\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:191:\treturn createGeminiSpendFn(\"gemini-2.5-flash-lite\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:195:\treturn createGeminiSpendFn(\"gemini-2.0-flash\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:199:\treturn createGeminiSpendFn(\"gemini-2.0-flash-lite\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:203:\treturn createGeminiSpendFn(\"gemini-pro\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:214:\t\t\t\tmodelName = \"gemini-pro\" // fallback\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:227:\t\t\tvar geminiResp GeminiResponse\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:228:\t\t\tmodelName := \"gemini-pro\" // default fallback\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:230:\t\t\tif err := json.Unmarshal([]byte(body), &geminiResp); err == nil {\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:232:\t\t\t\t// We'll apply the most conservative pricing (gemini-2.5-pro rates)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:233:\t\t\t\tif geminiResp.UsageMetadata.TotalTokenCount > 0 {\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:234:\t\t\t\t\trate := ModelUsageRates[\"gemini-2.5-pro\"] // Use most expensive as fallback\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:235:\t\t\t\t\tactualCost := rate.InputTokens*geminiResp.UsageMetadata.PromptTokenCount + \n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:236:\t\t\t\t\t\t\t\t rate.OutputTokens*geminiResp.UsageMetadata.CandidatesTokenCount\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:263:\t\t// Handle model names like \"google/gemini-2.5-flash\" -> \"gemini-2.5-flash\"\n/Users/mtk19651/project/azure-gateway/gcp/utils.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/utils.go:12:\t\treturn fmt.Errorf(\"unsupported gemini model: %s\", modelName)\n/Users/mtk19651/project/azure-gateway/gcp/utils.go:18:// Example: /v1/projects/mtk-aide-gemini-poc/locations/global/endpoints/openapi/chat/completions\n/Users/mtk19651/project/azure-gateway/gcp/utils.go:22:\treturn \"gemini-pro\" // default fallback\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:17:// TestHelpers provides common testing utilities for gemini package\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:167:\t// Default groups that allow gemini access\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:169:\t\t{Name: \"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:170:\t\t{Name: \"gaisf_swrd_gemini\"}, \n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:171:\t\t{Name: \"gaisf_hwrd_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh:4:# This script runs all tests for the gemini package with various configurations\n/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh:19:PACKAGE_PATH=\"./gemini\"\n/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh:41:if [[ ! -d \"gemini\" ]]; then\n/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh:46:print_status \"Starting test suite for gemini package...\"\n/Users/mtk19651/project/azure-gateway/gcp/README.md:14:- `gemini-2.5-pro`: $1.25 input, $10.00 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:15:- `gemini-2.5-flash`: $0.30 input, $2.50 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:16:- `gemini-2.5-flash-lite`: $0.10 input, $0.40 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:19:- `gemini-2.0-flash`: $0.15 input, $0.60 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:20:- `gemini-2.0-flash-lite`: $0.08 input, $0.30 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:23:- `gemini-pro`: Default legacy model mapping\n/Users/mtk19651/project/azure-gateway/gcp/README.md:30:spendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, encoder, &creds, &gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:16:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:17:\t\t\"gemini-2.5-flash\", \n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:18:\t\t\"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:19:\t\t\"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:20:\t\t\"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:21:\t\t\"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:87:\t\t\tgroups:   []string{\"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:93:\t\t\tgroups:   []string{\"gaisf_swrd_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:99:\t\t\tgroups:   []string{\"gaisf_hwrd_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:111:\t\t\tgroups:   []string{\"gaisf_unknown_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:128:\t\t\t\tRequest:        NewTestRequest(\"gemini-2.5-flash\"),\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:163:\t\t\tExpectPreError: false, // Should fallback to gemini-pro\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:177:\t\t\tExpectPreError: false, // Should fallback to gemini-pro\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:185:\t\t\t\tBody: `{\"model\": \"google/gemini-2.5-pro\"}`,\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:205:\t\t\tExpectPreError: false, // Should fallback to gemini-pro\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:212:\t\t\tRequest: NewTestRequest(\"gemini-2.5-flash\"),\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:247:\t\tRequest:        NewTestRequest(\"gemini-2.5-flash\"),\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:277:\t\tRequest:        NewTestRequest(\"gemini-2.5-flash\"),\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:323:\t\t\treq := NewTestRequest(\"gemini-2.5-flash\")\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:15:\t\t\tname:     \"gemini-2.5-pro exact match\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:16:\t\t\tinput:    \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:17:\t\t\texpected: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:20:\t\t\tname:     \"gemini-2.5-pro with version\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:21:\t\t\tinput:    \"gemini-2.5-pro-v1\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:22:\t\t\texpected: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:25:\t\t\tname:     \"gemini-2.5-flash exact match\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:26:\t\t\tinput:    \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:27:\t\t\texpected: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:30:\t\t\tname:     \"gemini-2.5-flash-lite with version\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:31:\t\t\tinput:    \"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:32:\t\t\texpected: \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:35:\t\t\tname:     \"gemini-2.0-flash with version\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:36:\t\t\tinput:    \"gemini-2.0-flash-001\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:37:\t\t\texpected: \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:40:\t\t\tname:     \"gemini-2.0-flash-lite with version\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:41:\t\t\tinput:    \"gemini-2.0-flash-lite-001\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:42:\t\t\texpected: \"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:47:\t\t\texpected: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:52:\t\t\texpected: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:60:\t\t\tname:     \"legacy gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:61:\t\t\tinput:    \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:62:\t\t\texpected: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:84:\t\t\tname:      \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:85:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:90:\t\t\tname:      \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:91:\t\t\tmodelName: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:96:\t\t\tname:      \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:97:\t\t\tmodelName: \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:102:\t\t\tname:      \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:103:\t\t\tmodelName: \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:108:\t\t\tname:      \"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:109:\t\t\tmodelName: \"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:114:\t\t\tname:      \"gemini-pro legacy\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:115:\t\t\tmodelName: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:121:\t\t\tmodelName: \"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:166:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:167:\t\t\"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:168:\t\t\"gemini-2.5-flash-lite\", \n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:169:\t\t\"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:170:\t\t\"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:171:\t\t\"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:225:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:226:\t\t\"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:241:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:242:\t\t\"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:243:\t\t\"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:19:\t\t\tname:      \"valid gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:20:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:24:\t\t\tname:      \"valid gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:25:\t\t\tmodelName: \"gemini-2.5-flash\", \n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:29:\t\t\tname:      \"valid gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:30:\t\t\tmodelName: \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:34:\t\t\tname:      \"valid gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:35:\t\t\tmodelName: \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:39:\t\t\tname:\n\n... [79 lines truncated] ..."}]},"uuid":"b12a30f3-d5c0-47ca-a9c9-441be1577e68","timestamp":"2025-08-18T03:18:35.719Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:99:\t\t\t{Name: \"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:123:\t\t\tbody:     `{\"model\": \"gemini-2.5-flash\"}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:124:\t\t\texpected: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:128:\t\t\tbody:     `{\"model\": \"google/gemini-2.5-pro\"}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:129:\t\t\texpected: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:133:\t\t\tbody:     `{\"model\": \"google/gemini-2.0-flash\", \"messages\": [{\"role\": \"user\", \"content\": \"hello\"}]}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:134:\t\t\texpected: \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:153:\t\t\tbody:     `{\"model\": \"provider/sub/gemini-2.5-flash-lite\"}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:154:\t\t\texpected: \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:178:\t\t\tname:      \"gemini-2.5-pro with usage\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:179:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:189:\t\t\tname:      \"gemini-2.5-flash with usage\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:190:\t\t\tmodelName: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:201:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:252:\t\t\tname:   \"successful request with gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:255:\t\t\tbody:   `{\"model\": \"gemini-2.5-pro\", \"messages\": [{\"role\": \"user\", \"content\": \"Hello, world!\"}]}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:257:\t\t\t\t{Name: \"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:263:\t\t\tname:   \"request with gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:266:\t\t\tbody:   `{\"model\": \"google/gemini-2.5-flash\", \"messages\": [{\"role\": \"user\", \"content\": \"Test message\"}]}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:268:\t\t\t\t{Name: \"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:277:\t\t\tbody:   `{\"model\": \"gemini-2.5-pro\", \"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}]}`,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:351:\t\t\tpreestimate: 12500, // 100 * 125 (gemini-2.5-pro input rate)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:370:\t\t\texpected:     3000, // 3 chunks * 1000 (gemini-2.5-pro output rate)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:414:\t\t\"gemini-2.5-pro\":        SpendFnGemini25Pro,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:415:\t\t\"gemini-2.5-flash\":      SpendFnGemini25Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:416:\t\t\"gemini-2.5-flash-lite\": SpendFnGemini25FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:417:\t\t\"gemini-2.0-flash\":      SpendFnGemini20Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:418:\t\t\"gemini-2.0-flash-lite\": SpendFnGemini20FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:419:\t\t\"gemini-pro\":            SpendFnGeminiPro,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:447:\t\t\tname:      \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:448:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:452:\t\t\tname:      \"gemini-2.5-flash with version\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:453:\t\t\tmodelName: \"gemini-2.5-flash-v1\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:454:\t\t\texpectOk:  true, // Should normalize to gemini-2.5-flash\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:462:\t\t\tname:      \"legacy gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:463:\t\t\tmodelName: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:485:\tbody := `{\"model\": \"google/gemini-2.5-flash\", \"messages\": [{\"role\": \"user\", \"content\": \"hello world\"}]}`\n/Users/mtk19651/project/azure-gateway/gcp/spendfn_test.go:502:\t\tEstimateUsage(\"gemini-2.5-pro\", usage, 100000)\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:37:\t\t\tname: \"successful gemini-2.5-pro request\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:39:\t\t\t\t\"model\": \"google/gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:56:\t\t\texpectedModel:   \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:61:\t\t\tname: \"successful gemini-2.5-flash request\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:63:\t\t\t\t\"model\": \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:77:\t\t\texpectedModel:   \"gemini-2.5-flash\", \n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:84:\t\t\t\t\"model\": \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:91:\t\t\texpectedModel:   \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:98:\t\t\t\t\"model\": \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:104:\t\t\texpectedModel:  \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:198:\t\t\"model\": \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:275:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:276:\t\t\"gemini-2.5-flash\", \n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:277:\t\t\"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:278:\t\t\"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:279:\t\t\"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/integration_test.go:327:\t\t\"model\": \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:32:\tErrNotAllowedToUseGemini = errors.New(\"you are not allowed to use gemini model\")\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:49:\t\"gemini-2.5-pro\":                      SpendFnGemini25Pro,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:50:\t\"gemini-2.5-flash\":                    SpendFnGemini25Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:51:\t\"gemini-2.5-flash-lite\":               SpendFnGemini25FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:52:\t\"gemini-2.0-flash\":                    SpendFnGemini20Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:53:\t\"gemini-2.0-flash-lite\":               SpendFnGemini20FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:54:\t\"gemini-pro\":                          SpendFnGeminiPro, // Legacy\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:55:\t\"gemini-2.5-flash-lite-preview-06-17\": SpendFnGemini25FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:56:\t\"gemini-2.0-flash-001\":                SpendFnGemini20Flash,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:57:\t\"gemini-2.0-flash-lite-001\":           SpendFnGemini20FlashLite,\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:90:\t\t\t\treturn 0, 0, fmt.Errorf(\"unsupported gemini model: %s\", modelName)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:130:\t\t\t\tgroup := \"gaisf_\" + domain + \"_gemini\"\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:162:\t\t\t\tvar geminiResp GeminiResponse\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:163:\t\t\t\tif err := json.Unmarshal([]byte(body), &geminiResp); err == nil {\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:164:\t\t\t\t\testimate = EstimateUsage(modelName, geminiResp.UsageMetadata, preestimate)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:183:\treturn createGeminiSpendFn(\"gemini-2.5-pro\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:187:\treturn createGeminiSpendFn(\"gemini-2.5-flash\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:191:\treturn createGeminiSpendFn(\"gemini-2.5-flash-lite\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:195:\treturn createGeminiSpendFn(\"gemini-2.0-flash\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:199:\treturn createGeminiSpendFn(\"gemini-2.0-flash-lite\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:203:\treturn createGeminiSpendFn(\"gemini-pro\", crowdapi, qc, smtpserver, encoder, creds, gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:214:\t\t\t\tmodelName = \"gemini-pro\" // fallback\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:227:\t\t\tvar geminiResp GeminiResponse\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:228:\t\t\tmodelName := \"gemini-pro\" // default fallback\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:230:\t\t\tif err := json.Unmarshal([]byte(body), &geminiResp); err == nil {\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:232:\t\t\t\t// We'll apply the most conservative pricing (gemini-2.5-pro rates)\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:233:\t\t\t\tif geminiResp.UsageMetadata.TotalTokenCount > 0 {\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:234:\t\t\t\t\trate := ModelUsageRates[\"gemini-2.5-pro\"] // Use most expensive as fallback\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:235:\t\t\t\t\tactualCost := rate.InputTokens*geminiResp.UsageMetadata.PromptTokenCount + \n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:236:\t\t\t\t\t\t\t\t rate.OutputTokens*geminiResp.UsageMetadata.CandidatesTokenCount\n/Users/mtk19651/project/azure-gateway/gcp/spendfn.go:263:\t\t// Handle model names like \"google/gemini-2.5-flash\" -> \"gemini-2.5-flash\"\n/Users/mtk19651/project/azure-gateway/gcp/utils.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/utils.go:12:\t\treturn fmt.Errorf(\"unsupported gemini model: %s\", modelName)\n/Users/mtk19651/project/azure-gateway/gcp/utils.go:18:// Example: /v1/projects/mtk-aide-gemini-poc/locations/global/endpoints/openapi/chat/completions\n/Users/mtk19651/project/azure-gateway/gcp/utils.go:22:\treturn \"gemini-pro\" // default fallback\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:17:// TestHelpers provides common testing utilities for gemini package\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:167:\t// Default groups that allow gemini access\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:169:\t\t{Name: \"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:170:\t\t{Name: \"gaisf_swrd_gemini\"}, \n/Users/mtk19651/project/azure-gateway/gcp/testhelpers.go:171:\t\t{Name: \"gaisf_hwrd_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh:4:# This script runs all tests for the gemini package with various configurations\n/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh:19:PACKAGE_PATH=\"./gemini\"\n/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh:41:if [[ ! -d \"gemini\" ]]; then\n/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh:46:print_status \"Starting test suite for gemini package...\"\n/Users/mtk19651/project/azure-gateway/gcp/README.md:14:- `gemini-2.5-pro`: $1.25 input, $10.00 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:15:- `gemini-2.5-flash`: $0.30 input, $2.50 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:16:- `gemini-2.5-flash-lite`: $0.10 input, $0.40 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:19:- `gemini-2.0-flash`: $0.15 input, $0.60 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:20:- `gemini-2.0-flash-lite`: $0.08 input, $0.30 output (per million tokens)\n/Users/mtk19651/project/azure-gateway/gcp/README.md:23:- `gemini-pro`: Default legacy model mapping\n/Users/mtk19651/project/azure-gateway/gcp/README.md:30:spendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, encoder, &creds, &gcpcredonce)\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:16:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:17:\t\t\"gemini-2.5-flash\", \n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:18:\t\t\"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:19:\t\t\"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:20:\t\t\"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:21:\t\t\"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:87:\t\t\tgroups:   []string{\"gaisf_oa_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:93:\t\t\tgroups:   []string{\"gaisf_swrd_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:99:\t\t\tgroups:   []string{\"gaisf_hwrd_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:111:\t\t\tgroups:   []string{\"gaisf_unknown_gemini\"},\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:128:\t\t\t\tRequest:        NewTestRequest(\"gemini-2.5-flash\"),\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:163:\t\t\tExpectPreError: false, // Should fallback to gemini-pro\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:177:\t\t\tExpectPreError: false, // Should fallback to gemini-pro\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:185:\t\t\t\tBody: `{\"model\": \"google/gemini-2.5-pro\"}`,\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:205:\t\t\tExpectPreError: false, // Should fallback to gemini-pro\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:212:\t\t\tRequest: NewTestRequest(\"gemini-2.5-flash\"),\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:247:\t\tRequest:        NewTestRequest(\"gemini-2.5-flash\"),\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:277:\t\tRequest:        NewTestRequest(\"gemini-2.5-flash\"),\n/Users/mtk19651/project/azure-gateway/gcp/test_suite_test.go:323:\t\t\treq := NewTestRequest(\"gemini-2.5-flash\")\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:15:\t\t\tname:     \"gemini-2.5-pro exact match\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:16:\t\t\tinput:    \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:17:\t\t\texpected: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:20:\t\t\tname:     \"gemini-2.5-pro with version\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:21:\t\t\tinput:    \"gemini-2.5-pro-v1\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:22:\t\t\texpected: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:25:\t\t\tname:     \"gemini-2.5-flash exact match\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:26:\t\t\tinput:    \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:27:\t\t\texpected: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:30:\t\t\tname:     \"gemini-2.5-flash-lite with version\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:31:\t\t\tinput:    \"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:32:\t\t\texpected: \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:35:\t\t\tname:     \"gemini-2.0-flash with version\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:36:\t\t\tinput:    \"gemini-2.0-flash-001\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:37:\t\t\texpected: \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:40:\t\t\tname:     \"gemini-2.0-flash-lite with version\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:41:\t\t\tinput:    \"gemini-2.0-flash-lite-001\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:42:\t\t\texpected: \"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:47:\t\t\texpected: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:52:\t\t\texpected: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:60:\t\t\tname:     \"legacy gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:61:\t\t\tinput:    \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:62:\t\t\texpected: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:84:\t\t\tname:      \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:85:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:90:\t\t\tname:      \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:91:\t\t\tmodelName: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:96:\t\t\tname:      \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:97:\t\t\tmodelName: \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:102:\t\t\tname:      \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:103:\t\t\tmodelName: \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:108:\t\t\tname:      \"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:109:\t\t\tmodelName: \"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:114:\t\t\tname:      \"gemini-pro legacy\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:115:\t\t\tmodelName: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:121:\t\t\tmodelName: \"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:166:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:167:\t\t\"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:168:\t\t\"gemini-2.5-flash-lite\", \n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:169:\t\t\"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:170:\t\t\"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:171:\t\t\"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:225:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:226:\t\t\"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:241:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:242:\t\t\"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/models_test.go:243:\t\t\"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:19:\t\t\tname:      \"valid gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:20:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:24:\t\t\tname:      \"valid gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:25:\t\t\tmodelName: \"gemini-2.5-flash\", \n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:29:\t\t\tname:      \"valid gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:30:\t\t\tmodelName: \"gemini-2.5-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:34:\t\t\tname:      \"valid gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:35:\t\t\tmodelName: \"gemini-2.0-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:39:\t\t\tname:      \"valid gemini-2.0-flash-lite\", \n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:40:\t\t\tmodelName: \"gemini-2.0-flash-lite\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:44:\t\t\tname:      \"valid legacy gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:45:\t\t\tmodelName: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:50:\t\t\tmodelName: \"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:55:\t\t\tmodelName: \"gemini-2.0-flash-001\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:114:\t\t\tname:     \"gemini api path\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:115:\t\t\tpath:     \"/v1/projects/mtk-aide-gemini-poc/locations/global/endpoints/openapi/chat/completions\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:116:\t\t\texpected: \"gemini-pro\", // Default fallback\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:121:\t\t\texpected: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:126:\t\t\texpected: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:131:\t\t\texpected: \"gemini-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:224:\t\t\tname:      \"gemini-2.5-pro usage\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:225:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:233:\t\t\tname:      \"gemini-2.5-flash usage\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:234:\t\t\tmodelName: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:252:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:312:\t\t\tname:      \"gemini-2.5-pro calculation\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:313:\t\t\tmodelName: \"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:324:\t\t\tname:      \"gemini-2.5-flash calculation\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:325:\t\t\tmodelName: \"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:400:\t\tLogModelUsage(\"gemini-2.5-pro\", largeUsage)\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:407:\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:408:\t\t\"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:410:\t\t\"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/gcp/utils_test.go:451:\t\tLogModelUsage(\"gemini-2.5-pro\", usage)\n/Users/mtk19651/project/azure-gateway/gcp/models.go:1:package gemini\n/Users/mtk19651/project/azure-gateway/gcp/models.go:20:\t\"gemini-2.5-pro\": {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:27:\t\"gemini-2.5-flash\": {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:34:\t\"gemini-2.5-flash-lite\": {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:41:\t\"gemini-2.0-flash\": {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:48:\t\"gemini-2.0-flash-lite\": {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:55:\t\"gemini-pro\": {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:62:\t\"gemini-2.5-flash-lite-preview-06-17\": {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:67:\t\"gemini-2.0-flash-001\": {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:72:\t\"gemini-2.0-flash-lite-001\": {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:91:\tif strings.HasPrefix(modelName, \"gemini-2.5-pro\") {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:92:\t\treturn \"gemini-2.5-pro\"\n/Users/mtk19651/project/azure-gateway/gcp/models.go:94:\tif strings.HasPrefix(modelName, \"gemini-2.5-flash-lite\") {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:95:\t\treturn \"gemini-2.5-flash-lite\"\n/Users/mtk19651/project/azure-gateway/gcp/models.go:97:\tif strings.HasPrefix(modelName, \"gemini-2.5-flash\") {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:98:\t\treturn \"gemini-2.5-flash\"\n/Users/mtk19651/project/azure-gateway/gcp/models.go:100:\tif strings.HasPrefix(modelName, \"gemini-2.0-flash-lite\") {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:101:\t\treturn \"gemini-2.0-flash-lite\"\n/Users/mtk19651/project/azure-gateway/gcp/models.go:103:\tif strings.HasPrefix(modelName, \"gemini-2.0-flash\") {\n/Users/mtk19651/project/azure-gateway/gcp/models.go:104:\t\treturn \"gemini-2.0-flash\"\n/Users/mtk19651/project/azure-gateway/gcp/models.go:115:\t\treturn GeminiUsageRate{}, fmt.Errorf(\"unknown gemini model: %s\", modelName)\n/Users/mtk19651/project/azure-gateway/main_current.go:1893:\tgeminiRegions := []string{\"global\", \"us-central1\", \"us-west4\", \"northamerica-northeast1\", \"us-east4\", \"us-west1\", \"asia-northeast3\", \"asia-southeast1\", \"asia-northeast1\"}\n/Users/mtk19651/project/azure-gateway/main_current.go:1894:\tgeminis := make(map[string]*endpoint, len(geminiRegions))\n/Users/mtk19651/project/azure-gateway/main_current.go:1895:\tfor _, region := range geminiRegions {\n/Users/mtk19651/project/azure-gateway/main_current.go:1896:\t\tgeminis[region] = NewEndpoint(context.Background(), false, endpointconfig{url: \"https://aiplatform.googleapis.com\", labels: []string{\"gcp\", \"gemini-pro\", region}}, tr, logger, common.SpendFn{\n/Users/mtk19651/project/azure-gateway/main_current.go:2046:\t\t\tGeminis:          geminis,\n/Users/mtk19651/project/azure-gateway/main_current.go:2617:\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/v1/projects/mtk-aide-gemini-poc/locations\") {\n/Users/mtk19651/project/azure-gateway/main_current.go:2618:\t\t\t\tfor region, endpoint := range geminis {\n/Users/mtk19651/project/azure-gateway/main_current.go:2619:\t\t\t\t\tif strings.HasPrefix(c.Request.URL.Path[len(\"/v1/projects/mtk-aide-gemini-poc/locations/\"):], region) {\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:33:\t\"gitea.mediatek.inc/davinci/azure-gateway/gemini\"\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:1920:\tgeminiRegions := gemini.GeminiRegions\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:1921:\tgeminis := make(map[string]*endpoint, len(geminiRegions))\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:1922:\tfor _, region := range geminiRegions {\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:1924:\t\tspendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:1925:\t\tgeminis[region] = NewEndpoint(context.Background(), false, endpointconfig{\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:1927:\t\t\tlabels: []string{\"gcp\", \"gemini\", region},\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:2043:\t\t\tGeminis:          geminis,\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:2519:\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/v1/projects/mtk-aide-gemini-poc/locations\") {\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:2520:\t\t\t\tfor region, endpoint := range geminis {\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:2521:\t\t\t\t\tif strings.HasPrefix(c.Request.URL.Path[len(\"/v1/projects/mtk-aide-gemini-poc/locations/\"):], region) {\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/chatHandler.go:71:\t// Google: google/gemini-2.5-flash\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/chatHandler.go:153:\t\tc.Request.URL.Path = path.Join(\"/v1/projects/mtk-aide-gemini-poc/locations/global/endpoints/openapi\", strings.TrimPrefix(c.Request.URL.Path, \"/v1\"))\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:156:\t\t\t\t\t\"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:157:\t\t\t\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:158:\t\t\t\t\t\"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:159:\t\t\t\t\t\"gemini-2.0-flash-001\",\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:160:\t\t\t\t\t\"gemini-2.0-flash-lite-001\",\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:183:\t\t\t\t\t\"gemini-2.5-flash\",\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:184:\t\t\t\t\t\"gemini-2.5-pro\",\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:185:\t\t\t\t\t\"gemini-2.5-flash-lite-preview-06-17\",\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:186:\t\t\t\t\t\"gemini-2.0-flash-001\",\n/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go:187:\t\t\t\t\t\"gemini-2.0-flash-lite-001\",\n/Users/mtk19651/project/azure-gateway/.git/logs/HEAD:156:8fb814696d9acf4ae0e4577ce4d113d714124305 70663dcbd0848da980ba73414eaf08653191e1fd Sheldon Peng <sheldon.peng@mediatek.com> 1751562337 +0800\tcommit: feat(GAIS-5524): support gemini vertex ai api on mtk","numLines":266}}
{"parentUuid":"b12a30f3-d5c0-47ca-a9c9-441be1577e68","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_016sQK3DQHBRnL9Adbw2FEbw","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now let me check which files outside the gcp folder import or reference the gemini folder:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8609,"cache_read_input_tokens":20094,"output_tokens":1}},"type":"assistant","uuid":"ad7e36c1-26c8-44b0-a96b-f5f0268cc6bf","timestamp":"2025-08-18T03:18:38.552Z"}
{"parentUuid":"ad7e36c1-26c8-44b0-a96b-f5f0268cc6bf","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_016sQK3DQHBRnL9Adbw2FEbw","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01PTP9GxJGNbHXzZ6CLxFPQP","name":"Grep","input":{"pattern":"import.*\".*gemini","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8609,"cache_read_input_tokens":20094,"output_tokens":114}},"type":"assistant","uuid":"11780d8c-fe5b-4b7a-bfd7-2249459b45dc","timestamp":"2025-08-18T03:18:39.352Z"}
{"parentUuid":"11780d8c-fe5b-4b7a-bfd7-2249459b45dc","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01PTP9GxJGNbHXzZ6CLxFPQP","type":"tool_result","content":"No matches found"}]},"uuid":"9d356587-c9ba-41f7-a078-0a81c1ad2bc4","timestamp":"2025-08-18T03:18:39.481Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"9d356587-c9ba-41f7-a078-0a81c1ad2bc4","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_015WpXp7apuGHHv6iDwGgyt2","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01RxhUMfUQXGZdYBNDmimgLG","name":"Grep","input":{"pattern":"azure-gateway/gemini","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":8616,"cache_read_input_tokens":20219,"output_tokens":94}},"type":"assistant","uuid":"3a20d3b5-65c3-431c-b56b-51a0a885c59e","timestamp":"2025-08-18T03:18:43.797Z"}
{"parentUuid":"3a20d3b5-65c3-431c-b56b-51a0a885c59e","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01RxhUMfUQXGZdYBNDmimgLG","type":"tool_result","content":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:33:\t\"gitea.mediatek.inc/davinci/azure-gateway/gemini\""}]},"uuid":"4f962aa9-144d-4695-a29b-a10e224f72f6","timestamp":"2025-08-18T03:18:43.928Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go:33:\t\"gitea.mediatek.inc/davinci/azure-gateway/gemini\"","numLines":1}}
{"parentUuid":"4f962aa9-144d-4695-a29b-a10e224f72f6","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_019XmkZtnk3ugGCRRNMbyn9H","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Found the import! Let me update this import path:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":283,"cache_read_input_tokens":28703,"output_tokens":1}},"type":"assistant","uuid":"675ec343-7d6b-46c6-9b71-1ae41cba4ac3","timestamp":"2025-08-18T03:18:46.360Z"}
{"parentUuid":"675ec343-7d6b-46c6-9b71-1ae41cba4ac3","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_019XmkZtnk3ugGCRRNMbyn9H","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01PcrtGNBHgwE2JQV1zM4JuC","name":"Read","input":{"file_path":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":283,"cache_read_input_tokens":28703,"output_tokens":107}},"type":"assistant","uuid":"7543e7f0-b0af-4f07-9abf-5cf34da0b71d","timestamp":"2025-08-18T03:18:46.993Z"}
{"parentUuid":"7543e7f0-b0af-4f07-9abf-5cf34da0b71d","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01PcrtGNBHgwE2JQV1zM4JuC","type":"tool_result","content":"     1→package main\n     2→\n     3→import (\n     4→\t\"bytes\"\n     5→\t\"compress/gzip\"\n     6→\t\"context\"\n     7→\t\"crypto/tls\"\n     8→\t\"encoding/json\"\n     9→\t\"errors\"\n    10→\t\"flag\"\n    11→\t\"fmt\"\n    12→\t\"io\"\n    13→\t\"math\"\n    14→\t\"math/rand\"\n    15→\t\"net\"\n    16→\t\"net/http\"\n    17→\t\"net/http/httptest\"\n    18→\t\"net/http/httputil\"\n    19→\t\"net/url\"\n    20→\t\"os\"\n    21→\t\"os/signal\"\n    22→\t\"regexp\"\n    23→\t\"strconv\"\n    24→\t\"strings\"\n    25→\t\"sync\"\n    26→\t\"sync/atomic\"\n    27→\t\"syscall\"\n    28→\t\"time\"\n    29→\t\"unsafe\"\n    30→\n    31→\t\"gitea.mediatek.inc/davinci/azure-gateway/awsclaude\"\n    32→\t\"gitea.mediatek.inc/davinci/azure-gateway/azure\"\n    33→\t\"gitea.mediatek.inc/davinci/azure-gateway/gemini\"\n    34→\t\"gitea.mediatek.inc/davinci/azure-gateway/common\"\n    35→\t\"gitea.mediatek.inc/davinci/azure-gateway/crowdadapter\"\n    36→\t\"gitea.mediatek.inc/davinci/azure-gateway/dailyreset\"\n    37→\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/header\"\n    38→\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/middleware\"\n    39→\t\"gitea.mediatek.inc/davinci/azure-gateway/poker\"\n    40→\t\"gitea.mediatek.inc/davinci/azure-gateway/quota\"\n    41→\trq \"gitea.mediatek.inc/davinci/azure-gateway/request_queue\"\n    42→\tAPIV1 \"gitea.mediatek.inc/davinci/azure-gateway/router/api/v1\"\n    43→\t\"gitea.mediatek.inc/davinci/azure-gateway/router/auth\"\n    44→\t\"gitea.mediatek.inc/davinci/azure-gateway/service/azurebingsearch\"\n    45→\t\"gitea.mediatek.inc/davinci/azure-gateway/service/user\"\n    46→\n    47→\t_ \"gitea.mediatek.inc/davinci/azure-gateway/docs\"\n    48→\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n    49→\tv4 \"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n    50→\t\"github.com/essentialkaos/go-crowd/v3\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"39d83dda-a0ab-4385-8653-df57e5778797","timestamp":"2025-08-18T03:18:47.014Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","content":"package main\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"gitea.mediatek.inc/davinci/azure-gateway/awsclaude\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/azure\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/gemini\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/common\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/crowdadapter\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/dailyreset\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/header\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/middleware\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/poker\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/quota\"\n\trq \"gitea.mediatek.inc/davinci/azure-gateway/request_queue\"\n\tAPIV1 \"gitea.mediatek.inc/davinci/azure-gateway/router/api/v1\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/router/auth\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/service/azurebingsearch\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/service/user\"\n\n\t_ \"gitea.mediatek.inc/davinci/azure-gateway/docs\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n\tv4 \"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\t\"github.com/essentialkaos/go-crowd/v3\"","numLines":50,"startLine":1,"totalLines":2586}}}
{"parentUuid":"39d83dda-a0ab-4385-8653-df57e5778797","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01SdtGwCgFfAzKvbVS2jx1EU","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01PNwrCUawrd7175dMAPR89q","name":"Edit","input":{"file_path":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","old_string":"gitea.mediatek.inc/davinci/azure-gateway/gemini","new_string":"gitea.mediatek.inc/davinci/azure-gateway/gcp"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":933,"cache_read_input_tokens":28986,"output_tokens":154}},"type":"assistant","uuid":"f7b89eda-9a11-4dc7-a2e3-934bdc5d79c2","timestamp":"2025-08-18T03:18:50.458Z"}
{"parentUuid":"f7b89eda-9a11-4dc7-a2e3-934bdc5d79c2","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01PNwrCUawrd7175dMAPR89q","type":"tool_result","content":"The file /Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    29→\t\"unsafe\"\n    30→\n    31→\t\"gitea.mediatek.inc/davinci/azure-gateway/awsclaude\"\n    32→\t\"gitea.mediatek.inc/davinci/azure-gateway/azure\"\n    33→\t\"gitea.mediatek.inc/davinci/azure-gateway/gcp\"\n    34→\t\"gitea.mediatek.inc/davinci/azure-gateway/common\"\n    35→\t\"gitea.mediatek.inc/davinci/azure-gateway/crowdadapter\"\n    36→\t\"gitea.mediatek.inc/davinci/azure-gateway/dailyreset\"\n    37→\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/header\""}]},"uuid":"1808bec2-67ad-42fa-a77c-bfa85cc944aa","timestamp":"2025-08-18T03:18:50.489Z","toolUseResult":{"filePath":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","oldString":"gitea.mediatek.inc/davinci/azure-gateway/gemini","newString":"gitea.mediatek.inc/davinci/azure-gateway/gcp","originalFile":"package main\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"gitea.mediatek.inc/davinci/azure-gateway/awsclaude\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/azure\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/gemini\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/common\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/crowdadapter\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/dailyreset\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/header\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/middleware\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/poker\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/quota\"\n\trq \"gitea.mediatek.inc/davinci/azure-gateway/request_queue\"\n\tAPIV1 \"gitea.mediatek.inc/davinci/azure-gateway/router/api/v1\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/router/auth\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/service/azurebingsearch\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/service/user\"\n\n\t_ \"gitea.mediatek.inc/davinci/azure-gateway/docs\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n\tv4 \"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\t\"github.com/essentialkaos/go-crowd/v3\"\n\t\"github.com/gin-contrib/requestid\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n\t\"github.com/joho/godotenv\"\n\t\"github.com/pkoukk/tiktoken-go\"\n\ttiktoken_loader \"github.com/pkoukk/tiktoken-go-loader\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/redis/rueidis\"\n\t\"github.com/redis/rueidis/rueidisaside\"\n\tswaggerFiles \"github.com/swaggo/files\"\n\tginSwagger \"github.com/swaggo/gin-swagger\"\n\t\"golang.org/x/exp/slog\"\n\t\"golang.org/x/oauth2/google\"\n)\n\n// UserTokenRequest represents a request to generate a user token with a specified expiration time.\n// ExpirationHours specifies the number of hours the token will be valid for and is a required field.\ntype UserTokenRequest struct {\n\tExpirationHours int             `json:\"expirationHours\" binding:\"required\"`\n\tPayload         *map[string]any `json:\"payload\"`\n}\n\ntype UserLoginRequest struct {\n\tUserTokenRequest\n\tUsername string `json:\"username\" binding:\"required\"`\n\tPassword string `json:\"password\" binding:\"required\"`\n}\n\n// AoaiResp represents the response structure from the API.\n// It contains usage information about the tokens consumed during the request.\ntype AoaiResp struct {\n\tUsage struct {\n\t\t// PromptTokens represents the number of tokens used in the prompt.\n\t\t// This field is used in the original response format.\n\t\tPromptTokens int `json:\"prompt_tokens\"`\n\n\t\t// CompletionTokens represents the number of tokens used in the completion.\n\t\t// This field is used in the original response format.\n\t\tCompletionTokens int `json:\"completion_tokens\"`\n\n\t\t// InputTokens represents the number of tokens used in the input.\n\t\t// This field is used in the new response format.\n\t\tInputTokens int `json:\"input_tokens\"`\n\n\t\t// OutputTokens represents the number of tokens used in the output.\n\t\t// This field is used in the new response format.\n\t\tOutputTokens int `json:\"output_tokens\"`\n\t} `json:\"usage\"`\n}\n\ntype DalleReq struct {\n\tN int `json:\"n\"`\n}\n\ntype ResourceConfig struct {\n\tURL    string `json:\"url\"`\n\tKey    string `json:\"key\"`\n\tSecret string `json:\"secret\"`\n\tRegion string `json:\"region\"`\n\tWeight int    `json:\"weight\"`\n}\n\ntype Provider string\n\nvar (\n\tClaudeV3Provider = Provider(\"anthropic.claude-v3\")\n\tOpenAIProvider   = Provider(\"openai\")\n)\n\ntype DispatchConfig struct {\n\tProvider Provider `json:\"provider\"`\n\tModel    string   `json:\"model\"`\n\tPrice    struct {\n\t\tPrompt     int `json:\"prompt\"`\n\t\tCompletion int `json:\"completion\"`\n\t\tDalleN     int `json:\"dalleN\"`\n\t} `json:\"price\"`\n\tResources map[string]ResourceConfig `json:\"resources\"`\n}\n\nfunc checkInCrowdGroup(crowdapi crowdadapter.Adapter, list, uid string) (int, InListResp) {\n\tif _, ok := crowdapi.(*crowdadapter.Empty); ok {\n\t\treturn http.StatusOK, InListResp{In: true}\n\t}\n\tif uid == \"\" || list == \"\" {\n\t\treturn http.StatusBadRequest, InListResp{Reason: \"uid and list should not be empty\"}\n\t}\n\tif strings.Contains(uid, \"@\") {\n\t\tusers, err := crowdapi.SearchUsers(context.Background(), \"email=\"+uid, crowdadapter.DefaultLimit)\n\t\tif err != nil {\n\t\t\treturn http.StatusInternalServerError, InListResp{Reason: err.Error()}\n\t\t}\n\t\tif len(users) == 0 {\n\t\t\treturn http.StatusNotFound, InListResp{Reason: fmt.Sprintf(\"user not found: %q\", uid)}\n\t\t}\n\t\tuid = users[0].Name\n\t}\n\tgroups, err := crowdapi.GetUserNestedGroups(context.Background(), uid, crowdadapter.DefaultLimit)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, InListResp{Reason: err.Error()}\n\t}\n\tfor _, group := range groups {\n\t\tif group.Name == list {\n\t\t\treturn http.StatusOK, InListResp{In: true}\n\t\t}\n\t}\n\treturn http.StatusOK, InListResp{In: false}\n}\n\nfunc URL(target string) *url.URL {\n\tpurl, err := url.Parse(target)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn purl\n}\n\nvar buffers sync.Pool\n\nfunc NewTeeBufReader(r io.ReadCloser, done func(string)) *TeeBufReader {\n\treturn &TeeBufReader{r: r, w: buffers.Get().(*bytes.Buffer), done: done}\n}\n\ntype TeeBufReader struct {\n\tr    io.ReadCloser\n\tw    *bytes.Buffer\n\tdone func(buf string)\n}\n\nfunc (t *TeeBufReader) Read(p []byte) (n int, err error) {\n\tif t.r == nil {\n\t\treturn 0, io.EOF\n\t}\n\tn, err = t.r.Read(p)\n\tif n > 0 {\n\t\tif n, err := t.w.Write(p[:n]); err != nil {\n\t\t\treturn n, err\n\t\t}\n\t}\n\treturn\n}\n\nfunc (t *TeeBufReader) Close() (err error) {\n\tbs := t.w.Bytes()\n\tt.done(*(*string)(unsafe.Pointer(&bs)))\n\tt.w.Reset()\n\tbuffers.Put(t.w)\n\tif t.r != nil {\n\t\treturn t.r.Close()\n\t}\n\treturn nil\n}\n\ntype LoggingTransport struct {\n\tTransport http.RoundTripper\n\tlogger    *slog.Logger\n\tqueue     *rq.RequestQueue\n\tendpoint  *endpoint\n\tspendFn   common.SpendFn\n\trewrite   func(pr *http.Request) (toproxy bool)\n\treqCount  atomic.Int64\n\trespCount atomic.Int64\n\tlastReset atomic.Int64\n}\n\n// ResetCounters resets reqCount, respCount, and lastReset for daily reset.\nfunc (t *LoggingTransport) ResetCounters() {\n\tt.reqCount.Store(0)\n\tt.respCount.Store(0)\n\tt.lastReset.Store(time.Now().Unix())\n}\n\ntype HeaderLog struct {\n\tKey string `json:\"key\"`\n\tVal string `json:\"val\"`\n}\n\nfunc ToHeaderLogs(hdrs http.Header, apiVersion, dst string, code, chunk, priority, estCost int, ttfb, latency time.Duration) (hl []HeaderLog) {\n\tif code > 0 {\n\t\thl = make([]HeaderLog, 0, len(hdrs)+8)\n\t\thl = append(hl, HeaderLog{Key: \"Status\", Val: strconv.Itoa(code)})\n\t} else {\n\t\thl = make([]HeaderLog, 0, len(hdrs)+7)\n\t}\n\tif dst != \"\" {\n\t\thl = append(hl, HeaderLog{Key: \"Dst\", Val: dst})\n\t}\n\tif apiVersion != \"\" {\n\t\thl = append(hl, HeaderLog{Key: \"ApiVer\", Val: apiVersion})\n\t}\n\thl = append(hl, HeaderLog{Key: \"Cost\", Val: strconv.Itoa(estCost)})\n\thl = append(hl, HeaderLog{Key: \"Chunk\", Val: strconv.Itoa(chunk)})\n\thl = append(hl, HeaderLog{Key: \"Priority\", Val: strconv.Itoa(priority)})\n\thl = append(hl, HeaderLog{Key: \"TTFB\", Val: strconv.Itoa(int(ttfb.Milliseconds()))})\n\thl = append(hl, HeaderLog{Key: \"LAT\", Val: strconv.Itoa(int(latency.Milliseconds()))})\n\n\tfor k, vs := range hdrs {\n\t\tif lh := strings.ToLower(k); lh == \"authorization\" || lh == \"api-key\" || lh == \"x-forward-key\" {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, v := range vs {\n\t\t\thl = append(hl, HeaderLog{Key: k, Val: v})\n\t\t}\n\t}\n\treturn hl\n}\n\nfunc LogCheckBanword(body string, banwords []*regexp.Regexp) error {\n\tfor _, ban := range banwords {\n\t\tif i := ban.FindStringIndex(body); i != nil {\n\t\t\treturn fmt.Errorf(\"forbidden word %q at index %d\", ban, i[0])\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc chunks(in string, n int) (out []string) {\n\tfor len(in) > n {\n\t\tout = append(out, in[:n])\n\t\tin = in[n:]\n\t}\n\tout = append(out, in)\n\treturn\n}\n\nvar (\n\tttfbHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"ttfb_seconds\",\n\t\tHelp:    \"Time to first byte of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tttfbHistogramProxy = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"proxy_ttfb_seconds\",\n\t\tHelp:    \"Time to first byte of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tlatencyHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"duration_seconds\",\n\t\tHelp:    \"Latency of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tlatencyHistogramProxy = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"proxy_duration_seconds\",\n\t\tHelp:    \"Latency of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tcostGuage = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"est_costs\",\n\t\tHelp: \"Estimated costs of azure. 100,000,000 is $1\",\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tsuccessRateGauge = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"success_rates\",\n\t\tHelp: \"Rate of successful requests\",\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tendpointStatusGauge = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"endpoint_status\",\n\t\tHelp: \"endpoint status\",\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tendpointThresholdGauge = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"endpoint_threshold\",\n\t\tHelp: \"endpoint threshold\",\n\t}, []string{\"svc\", \"name\"})\n)\n\nfunc (t *LoggingTransport) RoundTrip(req *http.Request) (resp *http.Response, err error) {\n\tif req.ContentLength > 67108864 { // 64MB\n\t\treq.Body.Close()\n\t\tmsg := \"request body too large\"\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\treturn &http.Response{\n\t\t\tStatusCode:    http.StatusBadRequest,\n\t\t\tBody:          io.NopCloser(strings.NewReader(msg)),\n\t\t\tContentLength: int64(len(msg)),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}, nil\n\t}\n\n\tapiVersion := req.URL.Query().Get(\"api-version\")\n\n\ttoproxy := t.rewrite(req)\n\n\tvar priority int\n\tvar logger *slog.Logger\n\tvar banwords []*regexp.Regexp\n\tvar domain string\n\tif cv := req.Context().Value(\"lc\"); cv != nil {\n\t\tlc := cv.(*common.LoggingContext)\n\t\tpriority = lc.Priority\n\t\tbanwords = lc.Banwords\n\t\tdomain = lc.Domain\n\t\tlogger = t.logger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", req.Header.Get(\"X-Request-ID\"))\n\t} else {\n\t\tlogger = slog.New(slog.NewJSONHandler(io.Discard, nil))\n\t}\n\n\treqbuf := buffers.Get().(*bytes.Buffer)\n\tdefer func() {\n\t\treqbuf.Reset()\n\t\tbuffers.Put(reqbuf)\n\t}()\n\n\tif req.Body != nil && !t.endpoint.config.noreqlog {\n\t\t_, err = io.Copy(reqbuf, req.Body)\n\t\treq.Body.Close()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treqbytes := reqbuf.Bytes()\n\treqcontent := *(*string)(unsafe.Pointer(&reqbytes))\n\treqchunks := chunks(reqcontent, 4000000)\n\n\tdst := t.endpoint.config.labels[len(t.endpoint.config.labels)-1]\n\n\tif err = LogCheckBanword(reqcontent, banwords); err != nil {\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\tif !common.IsAirgappedDomain(domain) {\n\t\t\tfor c, chunk := range reqchunks {\n\t\t\t\tlogger.Info(req.URL.Path, \"req\", chunk, \"hdrs\", ToHeaderLogs(req.Header, apiVersion, dst, 0, c, priority, 0, 0, 0), \"ia\", err.Error())\n\t\t\t}\n\t\t\tlogger.Info(req.URL.Path, \"resp\", err.Error(), \"hdrs\", ToHeaderLogs(header, apiVersion, dst, http.StatusForbidden, 0, priority, 0, 0, 0))\n\t\t}\n\t\treturn &http.Response{\n\t\t\tStatusCode:    http.StatusForbidden,\n\t\t\tBody:          io.NopCloser(strings.NewReader(err.Error())),\n\t\t\tContentLength: int64(len(err.Error())),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}, nil\n\t}\n\tlc, ok := req.Context().Value(\"lc\").(*common.LoggingContext)\n\tif !ok || lc == nil {\n\t\treturn nil, errors.New(\"invalid logging context: not *common.LoggingContext\")\n\t}\n\tif lc.UID == nil {\n\t\treturn nil, errors.New(\"missing UID in logging context\")\n\t}\n\tuser := *lc.UID\n\testimate, remain, err := t.spendFn.Pre(user, domain, req, reqcontent)\n\n\treqSeq := t.reqCount.Add(1)\n\tfor c, chunk := range reqchunks {\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"req\", chunk,\n\t\t\t\"hdrs\", ToHeaderLogs(req.Header, apiVersion, dst, 0, c, priority, estimate, 0, 0),\n\t\t\t\"req_seq\", reqSeq,\n\t\t)\n\t}\n\n\tif err != nil {\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\trespSeq := t.respCount.Add(1)\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"resp\", err.Error(),\n\t\t\t\"hdrs\", ToHeaderLogs(header, apiVersion, dst, http.StatusInternalServerError, 0, priority, -1*estimate, 0, 0),\n\t\t\t\"resp_seq\", respSeq,\n\t\t\t\"rel_req_seq\", reqSeq,\n\t\t)\n\t\tif err == ErrTokenLimit {\n\t\t\treturn &http.Response{\n\t\t\t\tStatusCode:    http.StatusBadRequest,\n\t\t\t\tBody:          io.NopCloser(strings.NewReader(err.Error())),\n\t\t\t\tContentLength: int64(len(err.Error())),\n\t\t\t\tHeader:        header,\n\t\t\t\tRequest:       req,\n\t\t\t\tProto:         req.Proto,\n\t\t\t}, nil\n\t\t}\n\t\treturn &http.Response{\n\t\t\tStatusCode:    http.StatusInternalServerError,\n\t\t\tBody:          io.NopCloser(strings.NewReader(err.Error())),\n\t\t\tContentLength: int64(len(err.Error())),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}, nil\n\t}\n\n\tif remain < 0 {\n\t\tmsg := \"your daily quota is exhausted, please contact your admin if you want more quota\"\n\t\tif se := os.Getenv(\"SUPPORT_EMAIL\"); len(se) > 0 {\n\t\t\tmsg = fmt.Sprintf(\"your daily quota is exhausted, please contact %s if you want more quota\", se)\n\t\t}\n\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\trespSeq := t.respCount.Add(1)\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"resp\", msg,\n\t\t\t\"hdrs\", ToHeaderLogs(header, apiVersion, dst, http.StatusForbidden, 0, priority, -1*estimate, 0, 0),\n\t\t\t\"resp_seq\", respSeq,\n\t\t\t\"rel_req_seq\", reqSeq,\n\t\t)\n\t\tresp := &http.Response{\n\t\t\tStatusCode:    http.StatusForbidden,\n\t\t\tBody:          io.NopCloser(strings.NewReader(msg)),\n\t\t\tContentLength: int64(len(msg)),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}\n\t\tt.spendFn.Post(user, resp, \"\", estimate)\n\n\t\tif t.spendFn.Alert != nil {\n\t\t\tgo t.spendFn.Alert(user, logger)\n\t\t}\n\t\treturn resp, nil\n\t}\n\n\tif !t.endpoint.config.noreqlog {\n\t\treq.Body = io.NopCloser(bytes.NewReader(reqbytes))\n\t}\n\n\tt1 := time.Now()\n\tcostGuage.WithLabelValues(t.endpoint.config.labels...).Add(float64(estimate))\n\n\t// avoid azure returning HTTP 413 header too large\n\treq.Header.Del(\"X-Asst-Desc\")\n\treq.Header.Del(\"X-Asst-Id\")\n\treq.Header.Del(\"X-Asst-Name\")\n\treq.Header.Del(\"X-Thread-Id\")\n\treq.Header.Del(\"X-Stainless-Package-Version\")\n\treq.Header.Del(\"X-Stainless-Lang\")\n\treq.Header.Del(\"X-Stainless-Os\")\n\treq.Header.Del(\"X-Stainless-Runtime\")\n\treq.Header.Del(\"X-Stainless-Arch\")\n\n\tif resp, err = t.Transport.RoundTrip(req); err == nil {\n\t\tttfb := time.Since(t1)\n\t\tif toproxy {\n\t\t\tttfbHistogramProxy.WithLabelValues(t.endpoint.config.labels...).Observe(float64(ttfb.Microseconds() / 1e6))\n\t\t} else {\n\t\t\tttfbHistogram.WithLabelValues(t.endpoint.config.labels...).Observe(float64(ttfb.Microseconds() / 1e6))\n\t\t}\n\n\t\tt.endpoint.recordStatus(resp, ttfb, logger)\n\n\t\treqPath := req.URL.Path\n\t\tresp.Body = NewTeeBufReader(resp.Body, func(b string) {\n\t\t\tfullLatency := time.Since(t1)\n\t\t\tif toproxy {\n\t\t\t\tlatencyHistogramProxy.WithLabelValues(t.endpoint.config.labels...).Observe(float64(fullLatency.Microseconds() / 1e6))\n\t\t\t} else {\n\t\t\t\tlatencyHistogram.WithLabelValues(t.endpoint.config.labels...).Observe(float64(fullLatency.Microseconds() / 1e6))\n\t\t\t}\n\n\t\t\t// Check if the response data is in gzip format\n\t\t\tisGzip := false\n\t\t\tif len(b) > 2 && b[0] == 0x1f && b[1] == 0x8b {\n\t\t\t\tisGzip = true\n\t\t\t}\n\n\t\t\tif isGzip {\n\t\t\t\t// Attempt to decode gzip data\n\t\t\t\treader := bytes.NewReader([]byte(b))\n\t\t\t\tgzipReader, err := gzip.NewReader(reader)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(\"Failed to create gzip reader:\", err)\n\t\t\t\t} else {\n\t\t\t\t\tdecompressedData, err := io.ReadAll(gzipReader)\n\t\t\t\t\tgzipReader.Close()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogger.Error(\"Failed to decompress gzip data:\", err)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = string(decompressedData)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trespchunks := chunks(b, 4000000)\n\t\t\testimate = t.spendFn.Post(user, resp, b, estimate)\n\t\t\tcostGuage.WithLabelValues(t.endpoint.config.labels...).Add(float64(estimate))\n\n\t\t\trespSeq := t.respCount.Add(1)\n\t\t\tfor c, chunk := range respchunks {\n\t\t\t\tlogger.Info(reqPath,\n\t\t\t\t\t\"resp\", chunk,\n\t\t\t\t\t\"hdrs\", ToHeaderLogs(resp.Header, apiVersion, dst, resp.StatusCode, c, priority, estimate, ttfb, fullLatency),\n\t\t\t\t\t\"resp_seq\", respSeq,\n\t\t\t\t\t\"rel_req_seq\", reqSeq,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\tif op := resp.Header.Get(\"Operation-Location\"); op != \"\" {\n\t\t\tif purl, err := url.Parse(op); err == nil {\n\t\t\t\tif envstr(\"DOMAIN_CHECK\", \"oa\") == \"oa\" {\n\t\t\t\t\tpurl.Host = \"gitea.mediatek.inc/davinci/azure-gateway.mediatek.inc\"\n\t\t\t\t} else {\n\t\t\t\t\tpurl.Host = \"mlop-azure-rddmz.mediatek.inc\"\n\t\t\t\t}\n\t\t\t\tresp.Header.Set(\"Operation-Location\", purl.String())\n\t\t\t}\n\t\t}\n\t} else {\n\t\tt.endpoint.recordStatus(nil, 0, logger)\n\t\tttfb := time.Since(t1)\n\t\theader := http.Header{}\n\t\trespSeq := t.respCount.Add(1)\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"resp\", err.Error(),\n\t\t\t\"hdrs\", ToHeaderLogs(header, apiVersion, dst, 500, 0, priority, -1*estimate, ttfb, ttfb),\n\t\t\t\"resp_seq\", respSeq,\n\t\t\t\"rel_req_seq\", reqSeq,\n\t\t)\n\t\tt.spendFn.Post(user, resp, \"\", estimate)\n\t}\n\n\tif t.endpoint.config.ptu && resp != nil && (resp.StatusCode == 429 || resp.StatusCode == 500 || resp.StatusCode == 502) {\n\t\tvar condidate *endpoint\n\t\tretry, _ := strconv.ParseInt(req.Header.Get(\"X-PTU-RETRY\"), 10, 64)\n\t\tretry++\n\t\treq.Header.Set(\"X-PTU-RETRY\", strconv.FormatInt(retry, 10))\n\t\tif retry <= 2 {\n\t\t\tif after, _ := strconv.ParseInt(resp.Header.Get(\"Retry-After-Ms\"), 10, 64); after <= 1500 {\n\t\t\t\tif after == 0 {\n\t\t\t\t\tafter = 500\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * time.Duration(after))\n\t\t\t\tcondidate = t.endpoint\n\t\t\t\tgoto RETRY\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tallOthers := t.endpoint.othersFn()\n\t\t\tcondidates := make([]*endpoint, 0, len(allOthers))\n\t\t\tfor _, e := range allOthers {\n\t\t\t\tif e == t.endpoint {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif e.isOnline() {\n\t\t\t\t\tcondidates = append(condidates, e)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(condidates) > 0 {\n\t\t\t\tcondidate = condidates[rand.Intn(len(condidates))]\n\t\t\t}\n\t\t}\n\tRETRY:\n\t\tif condidate != nil && condidate.proxy.Transport != nil {\n\t\t\tio.ReadAll(resp.Body)\n\t\t\tresp.Body.Close()\n\t\t\treq.Body = io.NopCloser(bytes.NewReader(reqbytes))\n\t\t\tresp, err = condidate.proxy.Transport.RoundTrip(req)\n\t\t}\n\t}\n\n\treturn resp, err\n}\n\ntype InListResp struct {\n\tIn     bool   `json:\"in\"`\n\tReason string `json:\"reason\"`\n}\n\nfunc (p InListResp) ToString() string {\n\tbs, _ := json.Marshal(p)\n\treturn *(*string)(unsafe.Pointer(&bs))\n}\n\ntype InListReq struct {\n\tUid  string `json:\"uid\"`\n\tList string `json:\"list\"`\n}\n\nfunc (p InListReq) ToString() string {\n\tbs, _ := json.Marshal(p)\n\treturn *(*string)(unsafe.Pointer(&bs))\n}\n\ntype endpoint struct {\n\tconfig   endpointconfig\n\tproxy    *httputil.ReverseProxy\n\tothersFn func() []*endpoint\n\tsuccess  uint64\n\ttotal    uint64\n\tdisable  int32\n}\n\nfunc (e *endpoint) isOnline() bool {\n\treturn atomic.LoadInt32(&e.disable) == 0\n}\n\nfunc (e *endpoint) online() {\n\tatomic.CompareAndSwapInt32(&e.disable, 1, 0)\n}\n\nfunc (e *endpoint) offline() bool {\n\tt := atomic.CompareAndSwapInt32(&e.disable, 0, 1)\n\tif t {\n\t\te.reset()\n\t}\n\treturn t\n}\n\nfunc (e *endpoint) reset() {\n\tatomic.StoreUint64(&e.success, 1)\n\tatomic.StoreUint64(&e.total, 1)\n}\n\nfunc (e *endpoint) recordStatus(resp *http.Response, ttfb time.Duration, logger *slog.Logger) (rate float64) {\n\tif logger != nil {\n\t\tlogger = logger.With(\"rqid\", uuid.New().String())\n\t}\n\tif e.othersFn == nil {\n\t\treturn\n\t}\n\tif e.config.judgeFn == nil || (resp != nil && e.config.judgeFn(resp, ttfb)) {\n\t\tatomic.AddUint64(&e.success, 1)\n\t\tif atomic.AddUint64(&e.total, 1) == 61 {\n\t\t\te.reset()\n\t\t}\n\t} else {\n\t\tatomic.AddUint64(&e.total, 1)\n\t}\n\n\ttotal := uint64(0)\n\tsuccess := uint64(0)\n\tendpoints := e.othersFn()\n\trates := make([]float64, 0, len(endpoints))\n\n\tj := 0\n\tfor _, oe := range endpoints {\n\t\tif !oe.isOnline() && oe != e {\n\t\t\tcontinue\n\t\t}\n\t\tptotal := atomic.LoadUint64(&oe.total)\n\t\tpsuccess := atomic.LoadUint64(&oe.success)\n\t\tif ptotal < psuccess {\n\t\t\tptotal = psuccess\n\t\t}\n\t\ttotal += ptotal\n\t\tsuccess += psuccess\n\t\trates = append(rates, float64(psuccess)/float64(ptotal))\n\t\tif oe == e {\n\t\t\tj = len(rates) - 1\n\t\t}\n\t}\n\tif total == 0 {\n\t\treturn\n\t}\n\n\tmean := float64(success) / float64(total)\n\tstdv := float64(0)\n\tfor _, r := range rates {\n\t\tstdv += math.Pow((r - mean), 2)\n\t}\n\tstdv = math.Sqrt(stdv / float64(len(rates)))\n\tthreshold := mean - 1.9*stdv\n\tif threshold > 0.9 {\n\t\tthreshold = 0.9\n\t}\n\tendpointThresholdGauge.WithLabelValues(e.config.labels[:2]...).Set(threshold)\n\n\tif (!e.config.ptu && rates[j] < threshold) && e.config.testReqFn != nil && e.offline() {\n\t\tvar header http.Header\n\t\tvar statusCode int\n\t\tif resp != nil {\n\t\t\theader = resp.Header\n\t\t\tstatusCode = resp.StatusCode\n\t\t}\n\t\tlogger.Info(\"endpoint_off\", \"req\", e.config.labels, \"hdrs\", ToHeaderLogs(header, \"\", \"\", statusCode, 0, 0, 0, 0, 0))\n\t\tgo func(threshold float64, testReqFn func() *http.Request) {\n\t\t\tfor i := 0; ; i++ {\n\t\t\t\tres := httptest.NewRecorder()\n\t\t\t\te.proxy.ServeHTTP(res, testReqFn())\n\t\t\t\tresp := res.Result()\n\t\t\t\tio.ReadAll(resp.Body)\n\t\t\t\tresp.Body.Close()\n\t\t\t\tptotal := atomic.LoadUint64(&e.total)\n\t\t\t\tpsuccess := atomic.LoadUint64(&e.success)\n\t\t\t\tif ptotal < psuccess {\n\t\t\t\t\tptotal = psuccess\n\t\t\t\t}\n\t\t\t\trate := float64(psuccess) / float64(ptotal)\n\t\t\t\tif rate > threshold {\n\t\t\t\t\te.online()\n\t\t\t\t\tlogger.Info(\"endpoint_on\", \"req\", e.config.labels, \"hdrs\", ToHeaderLogs(resp.Header, \"\", \"\", resp.StatusCode, i, 0, 0, 0, 0))\n\t\t\t\t\tsuccessRateGauge.WithLabelValues(e.config.labels...).Set(rate)\n\t\t\t\t\tendpointStatusGauge.WithLabelValues(e.config.labels...).Set(1)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t}\n\t\t}(threshold, e.config.testReqFn)\n\t}\n\n\tif e.config.judgeFn != nil {\n\t\tsuccessRateGauge.WithLabelValues(e.config.labels...).Set(rates[j])\n\t\tif e.isOnline() {\n\t\t\tendpointStatusGauge.WithLabelValues(e.config.labels...).Set(1)\n\t\t} else {\n\t\t\tendpointStatusGauge.WithLabelValues(e.config.labels...).Set(0)\n\t\t}\n\t}\n\treturn rate\n}\n\ntype dispatcher struct {\n\tonline   []*endpoint\n\tfallback *endpoint\n\tweight   int\n}\n\nfunc (d *dispatcher) pick(req *http.Request) *endpoint {\n\tif len(d.online) == 0 {\n\t\treturn d.fallback\n\t}\n\n\tlc, ok := req.Context().Value(\"lc\").(*common.LoggingContext)\n\tvar user string\n\tif !ok || lc == nil {\n\t\tpanic(\"invalid logging context: not *common.LoggingContext\")\n\t}\n\tif lc.UID != nil {\n\t\tuser = *lc.UID\n\t}\n\n\tif dst := req.Header.Get(\"X-DST\"); dst != \"\" {\n\t\tfor _, e := range d.online {\n\t\t\tif strings.Contains(e.config.url, dst) {\n\t\t\t\treturn e\n\t\t\t}\n\t\t}\n\t}\n\n\tc := 0\n\tw := rand.Intn(d.weight)\n\n\tfor _, e := range d.online {\n\t\tif e.config.ptu {\n\t\t\tif len(ptuVIPs) == 0 || ptuVIPs[user] {\n\t\t\t\treturn e\n\t\t\t}\n\t\t\tif e.isOnline() {\n\t\t\t\treturn e\n\t\t\t}\n\t\t}\n\t\tif c += e.config.weight; w < c {\n\t\t\tif !e.isOnline() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn e\n\t\t}\n\t}\n\n\treturn d.fallback\n}\n\nfunc (d *dispatcher) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\t// Check if request context is cancelled before proceeding\n\tselect {\n\tcase <-req.Context().Done():\n\t\t// Context cancelled - likely client disconnection\n\t\tlogger.Warn(\"Request context cancelled in dispatcher\",\n\t\t\t\"path\", req.URL.Path,\n\t\t\t\"error\", req.Context().Err(),\n\t\t\t\"method\", req.Method)\n\t\treturn\n\tdefault:\n\t\t// Context is still active, proceed\n\t}\n\n\tendpoint := d.pick(req)\n\tif endpoint == nil || endpoint.proxy == nil {\n\t\thttp.Error(rw, \"Service temporarily unavailable\", http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\n\t// Log the proxy handoff for debugging\n\tlogger.Debug(\"Dispatcher forwarding to endpoint\",\n\t\t\"path\", req.URL.Path,\n\t\t\"endpoint\", endpoint.config.labels)\n\n\t// Check once more before calling the reverse proxy\n\tselect {\n\tcase <-req.Context().Done():\n\t\tlogger.Warn(\"Request context cancelled just before proxy\",\n\t\t\t\"path\", req.URL.Path,\n\t\t\t\"error\", req.Context().Err())\n\t\treturn\n\tdefault:\n\t\tendpoint.proxy.ServeHTTP(rw, req)\n\t}\n}\n\nvar (\n\tproxyUsers map[string]bool\n\tptuVIPs    map[string]bool\n)\n\nfunc init() {\n\tbuffers = sync.Pool{New: func() any { return bytes.NewBuffer(make([]byte, 0, 4096)) }}\n\tproxyUsers = make(map[string]bool, 20)\n\tfor _, u := range strings.Split(os.Getenv(\"PROXY_USERS\"), \",\") {\n\t\tif u = strings.TrimSpace(u); u != \"\" {\n\t\t\tproxyUsers[strings.ToLower(u)] = true\n\t\t\tproxyUsers[strings.ToUpper(u)] = true\n\t\t}\n\t}\n\tptuVIPs = make(map[string]bool, 20)\n\tfor _, u := range strings.Split(os.Getenv(\"PTU_VIPS\"), \",\") {\n\t\tif u = strings.TrimSpace(u); u != \"\" {\n\t\t\tptuVIPs[strings.ToLower(u)] = true\n\t\t\tptuVIPs[strings.ToUpper(u)] = true\n\t\t}\n\t}\n}\n\nvar globalDailyResetController = dailyreset.New()\n\nfunc NewEndpoint(ctx context.Context, useproxy bool, config endpointconfig, tr http.RoundTripper, logger *slog.Logger, spendfn common.SpendFn) *endpoint {\n\tvar proxy, proxyKey string\n\tif useproxy {\n\t\tproxy = envstr(\"AZURE_PROXY_IP\", \"\")\n\t\tproxyKey = envstr(\"AZURE_PROXY_KEY\", envmust(\"JWT_SECRET_KEY\"))\n\t}\n\n\tdst := URL(config.url)\n\te := &endpoint{config: config, total: 1, success: 1}\n\te.proxy = httputil.NewSingleHostReverseProxy(dst)\n\ttransport := &LoggingTransport{\n\t\tTransport: tr,\n\t\tlogger:    logger,\n\t\tqueue:     rq.NewRequestQueue(),\n\t\tspendFn:   spendfn,\n\t\tendpoint:  e,\n\t\trewrite: func(pr *http.Request) (toproxy bool) {\n\t\t\tif proxy != \"\" {\n\t\t\t\tpr.Header.Set(\"X-Forward-To\", fmt.Sprintf(\"%s://%s\", dst.Scheme, dst.Host))\n\t\t\t\tpr.Header.Set(\"X-Forward-Key\", proxyKey)\n\t\t\t\tpr.URL.Scheme = \"http\"\n\t\t\t\tpr.URL.Host = proxy\n\t\t\t\tpr.Host = proxy\n\t\t\t\ttoproxy = true\n\t\t\t} else {\n\t\t\t\tpr.Header.Del(\"X-Forward-To\")\n\t\t\t\tpr.Header.Del(\"X-Forward-Key\")\n\t\t\t\tpr.URL.Scheme = dst.Scheme\n\t\t\t\tpr.URL.Host = dst.Host\n\t\t\t\tpr.Host = dst.Host\n\t\t\t\ttoproxy = false\n\t\t\t}\n\t\t\tpr.Header.Del(\"Authorization\")\n\t\t\tpr.Header.Del(\"api-key\")\n\t\t\tfor k, v := range config.hdrs {\n\t\t\t\tpr.Header.Set(k, v)\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t}\n\n\t// Initialize lastReset with current time\n\ttransport.lastReset.Store(time.Now().Unix())\n\tglobalDailyResetController.Register(transport)\n\n\te.proxy.Transport = transport\n\treturn e\n}\n\nfunc NewDaviciShareServerFunc(storeApiUrl, davinciUrl string) func(*gin.Context) {\n\tp := httputil.NewSingleHostReverseProxy(URL(storeApiUrl))\n\treturn func(c *gin.Context) {\n\t\tc.Request.Header.Set(\"X-Mail-Url\", davinciUrl)\n\t\tc.Request.URL.Path = \"/api/share/shareChat\"\n\t\tp.ServeHTTP(c.Writer, c.Request)\n\t}\n}\n\ntype endpointconfig struct {\n\tweight   int\n\turl      string\n\thdrs     map[string]string\n\tnoreqlog bool\n\tptu      bool\n\tlabels   []string\n\n\tjudgeFn   func(resp *http.Response, ttfb time.Duration) bool\n\ttestReqFn func() *http.Request\n}\n\nfunc NewDispatcher(tr http.RoundTripper, logger *slog.Logger, useproxy bool, spendfn common.SpendFn, configs []endpointconfig) *dispatcher {\n\td := &dispatcher{\n\t\tonline: make([]*endpoint, 0, len(configs)),\n\t}\n\tif len(configs) == 0 {\n\t\treturn d\n\t}\n\tfor _, c := range configs {\n\t\td.online = append(d.online, NewEndpoint(context.Background(), useproxy, c, tr, logger, spendfn))\n\t\td.weight += c.weight\n\t}\n\tfor _, e := range d.online {\n\t\te.othersFn = func() []*endpoint {\n\t\t\treturn d.online\n\t\t}\n\t}\n\td.fallback = d.online[len(d.online)-1]\n\treturn d\n}\n\n// aoaiWithKey initializes an endpoint configuration for Azure OpenAI API calls.\n// It constructs the configuration based on the provided parameters and the model type.\n//\n// If the url parameter is non-empty, the function uses it directly with an \"Authorization\" header.\n// Otherwise, it builds a base URL from the name and configures headers with the provided API key.\n//\n// For models containing \"dalle\" (case-insensitive), it returns a configuration with an \"api-key\" header\n// without setting any deadline or special performance testing behavior.\n//\n// For other models, it sets a default deadline of 60 seconds, but extends it to 150 seconds for models\n// ending with \"32k\", \"16k\", or containing \"gpt-4\". It also determines if the special \"ptu\" mode should\n// be enabled when name equals \"aideopenaijapaneast\" and model equals \"aide-gpt-4o\".\n//\n// In ptu mode, the function sets a judge function that always returns true and defines\n// a specific test request targeting the chat completions endpoint.\n// For general cases, a judge function is defined to check that the response status is neither 429 nor\n// in the 500 range, and that the time-to-first-byte (ttfb) is below the set deadline.\n// The test request function is adjusted based on the model (e.g., using \"completions\" for some models,\n// \"embeddings\" for others, or \"chat/completions\" by default).\n//\n// Parameters:\n//\n//\tweight int:\n//\t  The traffic weight assigned to this endpoint.\n//\tname string:\n//\t  The identifier used to construct the base URL if no override URL is provided.\n//\tmodel string:\n//\t  The model variant which affects headers, deadline configuration, and endpoint path.\n//\tkey string:\n//\t  The API key used either as an \"api-key\" or \"Authorization\" header depending on the scenario.\n//\turl string:\n//\t  An optional URL override; if provided, it bypasses the base URL construction.\n//\n// Returns:\n//\n//\tendpointconfig:\n//\t  A structure encompassing the endpoint URL, HTTP headers, associated labels, and the functions\n//\t  (judgeFn and testReqFn) used for response validation and test request generation.\nfunc aoaiWithKey(weight int, name, model, key, url string) endpointconfig {\n\tif url != \"\" {\n\t\treturn endpointconfig{\n\t\t\tweight: weight,\n\t\t\turl:    url,\n\t\t\thdrs:   map[string]string{\"Authorization\": key},\n\t\t\tlabels: []string{\"azure\", model, name},\n\t\t}\n\t}\n\n\tbaseURL := fmt.Sprintf(\"https://%s.openai.azure.com\", name)\n\n\t// If the model contains \"dalle\", no additional deadline or ptu configuration is needed\n\tif strings.Contains(strings.ToLower(model), \"dalle\") {\n\t\treturn endpointconfig{\n\t\t\tweight: weight,\n\t\t\turl:    baseURL,\n\t\t\thdrs:   map[string]string{\"api-key\": key},\n\t\t\tlabels: []string{\"aoai\", model, name},\n\t\t}\n\t}\n\n\t// Set deadline\n\tdeadline := time.Second * 60\n\tif strings.HasSuffix(model, \"32k\") || strings.HasSuffix(model, \"16k\") || strings.Contains(model, \"gpt-4\") {\n\t\tdeadline = time.Second * 150\n\t}\n\n\tptu := name == \"aideopenaijapaneast\" && (model == \"aide-gpt-4.1\")\n\n\t// Create a common configuration\n\tcfg := endpointconfig{\n\t\tptu:    ptu,\n\t\tweight: weight,\n\t\turl:    baseURL,\n\t\thdrs:   map[string]string{\"api-key\": key},\n\t\tlabels: []string{\"aoai\", model, name},\n\t}\n\n\t// If ptu is true, set judgeFn to always return true\n\tif ptu {\n\t\tcfg.judgeFn = func(resp *http.Response, ttfb time.Duration) bool {\n\t\t\treturn true\n\t\t}\n\t\tcfg.testReqFn = func() *http.Request {\n\t\t\tpayload := strings.NewReader(`{\"messages\":[{\"role\": \"user\",\"content\": \"Hi\"}]}`)\n\t\t\treq, err := http.NewRequest(http.MethodPost, fmt.Sprintf(\"%s/openai/deployments/%s/chat/completions?api-version=2024-02-01\", baseURL, model), payload)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\treq.Header.Set(\"api-key\", key)\n\t\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\t\treturn req\n\t\t}\n\t\treturn cfg\n\t}\n\n\t// Define default judgeFn and testReqFn for normal cases\n\tcfg.judgeFn = func(resp *http.Response, ttfb time.Duration) bool {\n\t\treturn resp.StatusCode != 429 && resp.StatusCode < 500 && ttfb < deadline\n\t}\n\tcfg.testReqFn = func() *http.Request {\n\t\tendpoint := \"chat/completions\"\n\t\tpayload := strings.NewReader(`{\"messages\":[{\"role\": \"user\",\"content\": \"Hi\"}]}`)\n\t\tif model == \"aide-davinci-003\" || model == \"aide-code-davinci-002\" {\n\t\t\tendpoint = \"completions\"\n\t\t\tpayload = strings.NewReader(`{\"prompt\": \"Hi\"}`)\n\t\t} else if strings.Contains(model, \"embedding\") {\n\t\t\tendpoint = \"embeddings\"\n\t\t\tpayload = strings.NewReader(`{\"input\": [\"Hi\"]}`)\n\t\t}\n\t\treq, err := http.NewRequest(http.MethodPost, fmt.Sprintf(\"%s/openai/deployments/%s/%s?api-version=2024-02-01\", baseURL, model, endpoint), payload)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treq.Header.Set(\"api-key\", key)\n\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\treturn req\n\t}\n\n\treturn cfg\n}\n\nfunc aoai(weight int, name, model string) endpointconfig {\n\treturn aoaiWithKey(weight, name, model, envmust(\"AZURE_OPAI_KEY_\"+name), \"\")\n}\n\nfunc aoaiNoReqLog(weight int, name, model string) endpointconfig {\n\tconfig := aoaiWithKey(weight, name, model, envmust(\"AZURE_OPAI_KEY_\"+name), \"\")\n\tconfig.noreqlog = true\n\treturn config\n}\n\nvar (\n\tErrTokenLimit        = errors.New(\"your input exceeds the token limit\")\n\tVisionStreamDisabled = errors.New(\"streaming gpt-4-turbo-vision responses is disabled\")\n\tVisionNotAllowed     = errors.New(\"you are not allowed to use gpt-4-turbo-vision\")\n\tGPT4NotAllowed       = errors.New(\"you are not allowed to use gpt-4\")\n\tDomainNotAllowed     = errors.New(\"you are not allowed to use the model in this domain\")\n)\n\ntype Message struct {\n\tRole    string          `json:\"role\"`\n\tContent json.RawMessage `json:\"content\"`\n}\n\ntype MessageContent struct {\n\tType string `json:\"type\"`\n\tText string `json:\"text\"`\n}\n\nfunc (m Message) HasImages() bool {\n\tvar content []MessageContent\n\tif json.Unmarshal(m.Content, &content) == nil {\n\t\tfor _, c := range content {\n\t\t\tif c.Type == \"image_url\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (m Message) SplitImageMessages() (Message, int) {\n\tif !m.HasImages() {\n\t\treturn m, 0\n\t}\n\tvar oldContents, newContents []MessageContent\n\timageCount := 0\n\tif json.Unmarshal(m.Content, &oldContents) == nil {\n\t\tfor _, c := range oldContents {\n\t\t\tif c.Type == \"image_url\" {\n\t\t\t\timageCount++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewContents = append(newContents, c)\n\t\t}\n\t}\n\tvar newMessage Message\n\tnewMessage.Role = m.Role\n\tnewMessage.Content, _ = json.Marshal(newContents)\n\n\treturn newMessage, imageCount\n}\n\ntype streambody struct {\n\tStream   bool      `json:\"stream\"`\n\tMessages []Message `json:\"messages\"`\n}\n\nfunc (sb streambody) CountToken(encoder *tiktoken.Tiktoken, fallbackTokens int) int {\n\thasImages := false\n\tfor _, m := range sb.Messages {\n\t\tif m.HasImages() {\n\t\t\thasImages = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !hasImages {\n\t\tbody, err := json.Marshal(sb)\n\t\tif err != nil {\n\t\t\treturn fallbackTokens\n\t\t}\n\t\treturn len(encoder.Encode(string(body), nil, nil))\n\t}\n\n\ttotalImageCount := 0\n\tvar textContents []Message\n\tfor _, m := range sb.Messages {\n\t\tif m.HasImages() {\n\t\t\ttextContent, imageCount := m.SplitImageMessages()\n\t\t\ttextContents = append(textContents, textContent)\n\t\t\ttotalImageCount += imageCount\n\t\t} else {\n\t\t\ttextContents = append(textContents, m)\n\t\t}\n\t}\n\n\ttextBody, err := json.Marshal(textContents)\n\tif err != nil {\n\t\treturn fallbackTokens\n\t}\n\ttextToken := len(encoder.Encode(string(textBody), nil, nil))\n\t// https://learn.microsoft.com/en-us/azure/ai-services/openai/overview#image-tokens-gpt-4-turbo-with-vision\n\t// max image token = 170 * 8 + 85 = 1445\n\timageToken := 1445 * totalImageCount\n\n\treturn textToken + imageToken\n}\n\nfunc aoaiSpend(model string, capgpt4 bool, crowdapi crowdadapter.Adapter, qc quota.QuotaClient, smtpserver string, encoder *tiktoken.Tiktoken, promptrate, completionrate int) common.SpendFn {\n\treturn common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tvar checkCrowd bool\n\t\t\tvar groups []crowdadapter.CrowdGroup\n\t\t\tif _, ok := crowdapi.(*crowdadapter.CrowdAPI); ok {\n\t\t\t\tcheckCrowd = true\n\t\t\t}\n\t\t\tif checkCrowd && (common.IsAirgappedDomain(domain) || common.IsAirgappedDomain(req.Header.Get(\"X-Domain\"))) {\n\t\t\t\tgroups, err = crowdapi.GetUserNestedGroups(req.Context(), user, crowdadapter.DefaultLimit)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, 0, err\n\t\t\t\t}\n\t\t\t\tpermit := false\n\t\t\t\tgroup := \"gaisf_\" + domain + \"_\" + strings.ReplaceAll(model, \"-\", \"_\")\n\t\t\t\tfor _, g := range groups {\n\t\t\t\t\tif g.Name == group {\n\t\t\t\t\t\tpermit = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !permit {\n\t\t\t\t\treturn 0, 0, fmt.Errorf(\"%w: %s\", DomainNotAllowed, group)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar tokens int\n\t\t\tif strings.Contains(model, \"gpt-4o\") || strings.Contains(model, \"gpt-4.1\") || strings.Contains(model, \"vision\") {\n\t\t\t\ttokens = 2000\n\t\t\t\tvar sb streambody\n\t\t\t\tif err := json.Unmarshal([]byte(body), &sb); err != nil {\n\t\t\t\t\treturn 0, 0, err\n\t\t\t\t}\n\t\t\t\ttokens = sb.CountToken(encoder, tokens)\n\t\t\t} else {\n\t\t\t\ttokens = len(encoder.Encode(body, nil, nil))\n\t\t\t}\n\n\t\t\tif checkCrowd && capgpt4 && strings.Contains(model, \"aide-gpt-4\") {\n\t\t\t\tif groups == nil {\n\t\t\t\t\tgroups, err = crowdapi.GetUserNestedGroups(req.Context(), user, crowdadapter.DefaultLimit)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, 0, err\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif model == \"aide-gpt-4-turbo-vision\" {\n\t\t\t\t\tpermit := false\n\t\t\t\t\tif domain == \"oa\" {\n\t\t\t\t\tL3:\n\t\t\t\t\t\tfor _, g := range groups {\n\t\t\t\t\t\t\tswitch g.Name {\n\t\t\t\t\t\t\tcase \"gaisf_io_gpt4_vision\", \"gaisf_oa_gpt4_vision\", \"gaisf_oa_gpt4_turbo_vision\":\n\t\t\t\t\t\t\t\tpermit = true\n\t\t\t\t\t\t\t\tbreak L3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if domain == \"swrd\" {\n\t\t\t\t\tL4:\n\t\t\t\t\t\tfor _, g := range groups {\n\t\t\t\t\t\t\tswitch g.Name {\n\t\t\t\t\t\t\tcase \"gaisf_swrd_gpt4_vision\", \"gaisf_swrd_gpt4_turbo_vision\":\n\t\t\t\t\t\t\t\tpermit = true\n\t\t\t\t\t\t\t\tbreak L4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !permit {\n\t\t\t\t\t\treturn 0, 0, VisionNotAllowed\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens > int(8000*1.1) && (model == \"aide-gpt-4-turbo\")) ||\n\t\t\t\t\t(tokens > int(16000*1.1) && (model == \"aide-gpt-4o\")) ||\n\t\t\t\t\t(tokens > int(16000*1.1) && (model == \"aide-gpt-4o-mini\")) {\n\t\t\t\t\tif !common.CheckTokenLimitPermision(domain, tokens, groups) {\n\t\t\t\t\t\treturn 0, 0, ErrTokenLimit\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\testimate = tokens * promptrate\n\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\treturn\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif resp == nil {\n\t\t\t\testimate = preestimate * -1\n\t\t\t} else if preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\testimate = preestimate * -1\n\t\t\t} else if strings.Contains(resp.Header.Get(\"content-type\"), \"text/event-stream\") {\n\t\t\t\testimate = strings.Count(body, \"\\ndata: {\") * completionrate\n\t\t\t} else {\n\t\t\t\tvar resp AoaiResp\n\t\t\t\tif err := json.Unmarshal([]byte(body), &resp); err == nil {\n\t\t\t\t\tif resp.Usage.PromptTokens > 0 && resp.Usage.CompletionTokens > 0 {\n\t\t\t\t\t\testimate = completionrate*resp.Usage.CompletionTokens + promptrate*resp.Usage.PromptTokens - preestimate\n\t\t\t\t\t} else if resp.Usage.InputTokens > 0 && resp.Usage.OutputTokens > 0 {\n\t\t\t\t\t\testimate = completionrate*resp.Usage.OutputTokens + promptrate*resp.Usage.InputTokens - preestimate\n\t\t\t\t\t} else {\n\t\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif estimate != 0 {\n\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t}\n}\n\n\nfunc enrichCSESHeaders(r *http.Request, domain, proj, tkid string, payload *map[string]any) error {\n\tlc, ok := r.Context().Value(\"lc\").(*common.LoggingContext)\n\tif !ok || lc == nil {\n\t\treturn errors.New(\"invalid logging context: not *common.LoggingContext\")\n\t}\n\tif lc.UID == nil {\n\t\treturn errors.New(\"missing UID in logging context\")\n\t}\n\tuid := *lc.UID\n\tif r.Header.Get(\"X-Domain\") == \"hwrd\" {\n\t\tdomain = \"hwrd\"\n\t}\n\tr.Header.Set(\"grpc-metadata-x-user-proxy-name\", uid)\n\tr.Header.Set(\"grpc-metadata-x-user-name\", uid)\n\tr.Header.Set(\"grpc-metadata-x-user-proxy-domain\", domain)\n\tr.Header.Set(\"grpc-metadata-x-user-domain\", domain)\n\tr.Header.Set(\"grpc-metadata-x-app-name\", proj)\n\tr.Header.Set(\"grpc-metadata-x-task-id\", tkid)\n\n\tif payload != nil {\n\t\tif v, ok := (*payload)[\"project\"]; ok {\n\t\t\tr.Header.Set(\"grpc-metadata-x-project-code\", v.(string))\n\t\t}\n\t}\n\tif code := r.Header.Get(\"X-Project-Code\"); code != \"\" {\n\t\tr.Header.Set(\"grpc-metadata-x-project-code\", code)\n\t}\n\treturn nil\n}\n\n//\t@title\t\t\t\t\t\tGAISF Gateway API\n//\t@version\t\t\t\t\t1.0\n//\t@description\t\t\t\tThis is the API documentation for the GAISF Gateway.\n//\t@BasePath\t\t\t\t\t/v1\n//\t@securityDefinitions.apikey\tBearerAuth\n//\t@in\t\t\t\t\t\t\theader\n//\t@name\t\t\t\t\t\tAuthorization\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tglobalDailyResetController.Start(ctx)\n\tvar envfile string\n\tflag.StringVar(&envfile, \"env-file\", \".env\", \"Read in a file of environment variables\")\n\tflag.Parse()\n\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\n\tif err := godotenv.Load(envfile); err == nil {\n\t\tlogger.Info(\"loading config file\", \"file\", envfile)\n\t}\n\n\tjwtKey := envmust(\"JWT_SECRET_KEY\")\n\tdomain := envstr(\"DOMAIN_CHECK\", \"oa\")\n\t// (permMgr initialization moved later where crowdapi is available)\n\n\tif !common.Domain(domain).IsValid() {\n\t\tpanic(\"DOMAIN_CHECK must be set to an airgapped domain\")\n\t}\n\n\tuserServiceURL := envstr(\"USER_SERVICE\", \"http://user-service:8080\")\n\n\tsmtpserver := \"smtp.mediatek.com:25\"\n\n\tif smtp := envstr(\"SMTP_SERVER\", \"\"); smtp != \"\" {\n\t\tsmtpserver = smtp\n\t}\n\n\tredisurl := envmust(\"REDIS_URL\")\n\n\tcapping := envstr(\"ENABLE_CAPPING\", \"true\")\n\n\tvar err error\n\tvar crowdapi crowdadapter.Adapter\n\n\trueidisopt := rueidis.ClientOption{InitAddress: []string{redisurl}}\n\tif strings.Contains(redisurl, \"://\") {\n\t\trueidisopt = rueidis.MustParseURL(redisurl)\n\t}\n\trueidisopt.CacheSizeEachConn = 64 * (1 << 20)\n\trac, err := rueidisaside.NewClient(rueidisaside.ClientOption{ClientOption: rueidisopt})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trc := rac.Client()\n\n\tswitch envstr(\"CROWD_IMPL_TYPE\", \"crowd\") {\n\tcase \"crowd\":\n\t\tcrowdapi, err = crowdadapter.NewCrowdAPI(envmust(\"CROWD_USERNAME\"), envmust(\"CROWD_PASSWORD\"), rac)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\tcase \"none\":\n\t\tcrowdapi = &crowdadapter.Empty{}\n\tdefault:\n\t\tpanic(\"unexpected CROWD_IMPL_TYPE\")\n\t}\n\n\tpermMgr := common.NewModelPermissionManager(jwtKey, crowdapi)\n\ttr := http.DefaultTransport.(*http.Transport).Clone()\n\ttr.MaxIdleConns = 10000\n\ttr.MaxIdleConnsPerHost = 1000\n\ttr.ResponseHeaderTimeout = 0\n\tif resolver := os.Getenv(\"RESOLVER_ADDR\"); resolver != \"\" {\n\t\tdialer := net.Dialer{\n\t\t\tResolver: &net.Resolver{\n\t\t\t\tPreferGo: true,\n\t\t\t\tDial: func(ctx context.Context, network, address string) (net.Conn, error) {\n\t\t\t\t\treturn (&net.Dialer{}).DialContext(ctx, \"tcp\", resolver)\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\ttr.DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\taddr = strings.Replace(addr, \"mtklm-core.mediatek.inc\", \"10.225.43.241\", 1)\n\t\t\treturn dialer.DialContext(ctx, network, addr)\n\t\t}\n\t}\n\tif strings.Contains(os.Getenv(\"CSES_LLM_API_URL\"), \"mtklm-hwrd.mediatek.inc\") {\n\t\tdialer := &tls.Dialer{\n\t\t\tConfig: &tls.Config{\n\t\t\t\tInsecureSkipVerify: true,\n\t\t\t},\n\t\t}\n\t\ttr.DialTLSContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\tif strings.Contains(addr, \"mtklm-hwrd.mediatek.inc\") {\n\t\t\t\treturn dialer.DialContext(ctx, network, \"10.10.46.14:443\")\n\t\t\t}\n\t\t\treturn dialer.DialContext(ctx, network, addr)\n\t\t}\n\t}\n\n\tqc := quota.NewRedisQuotaClient(rc, capping == \"true\")\n\n\ttiktoken.SetBpeLoader(tiktoken_loader.NewOfflineLoader())\n\tcl100k, err := tiktoken.GetEncoding(\"cl100k_base\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tp50k, err := tiktoken.GetEncoding(\"p50k_base\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar aoaidispatchers map[string]*dispatcher\n\tvar aoaifallback *endpoint\n\tbedrockendpoint := make(map[string]*endpoint)\n\n\t// AOAI pricing and endpoint configuration\n\t// Price: https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/\n\taoaidispatchers = map[string]*dispatcher{\n\t\t\"aide-gpt-4-turbo\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4-turbo\", true, crowdapi, qc, smtpserver, cl100k, 1000, 1500*2), []endpointconfig{\n\t\t\taoai(480, \"aideopenaicanadaeast\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaieastus2\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaifrancecentral\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(900, \"aideopenainorwayeast\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(900, \"aideopenaisouthindia\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaiwestus\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(900, \"aideopenaiswedencentral\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaiuksouth\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenainorthcentralus\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaisouthcentralus\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaieastus\", \"aide-gpt-4-turbo\"),\n\t\t}),\n\t\t// for AIDE internal use\n\t\t\"aide-gpt-4-turbo-1106\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4-turbo-1106\", true, crowdapi, qc, smtpserver, cl100k, 1000, 1500*2), []endpointconfig{\n\t\t\taoai(5000, \"aideopenaiaustraliaeast\", \"aide-gpt-4-turbo-1106\"),\n\t\t}),\n\t\t// for AIDE internal use\n\t\t\"aide-gpt-4o-0806\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4o-0806\", true, crowdapi, qc, smtpserver, cl100k, 500, 1500), []endpointconfig{\n\t\t\taoai(5000, \"aideopenaieastus\", \"aide-gpt-4o-0806\"),\n\t\t}),\n\t\t\"aide-gpt-4o\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4o\", true, crowdapi, qc, smtpserver, cl100k, 500, 1500), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaijapaneast\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaiwestus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenainorthcentralus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaisouthcentralus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaieastus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaiwestus3\", \"aide-gpt-4o\"),\n\t\t}),\n\t\t\"aide-gpt-4o-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4o-mini\", true, crowdapi, qc, smtpserver, cl100k, 15, 60), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus\", \"aide-gpt-4o-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4o-mini\"),\n\t\t\taoai(60000, \"aideopenaijapaneast\", \"aide-gpt-4o-mini\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4o-mini\"),\n\t\t}),\n\t\t\"aide-gpt-4.1\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4.1\", true, crowdapi, qc, smtpserver, cl100k, 200, 800), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4.1\"),\n\t\t\taoai(600000, \"aideopenaijapaneast\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaicanadaeast\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaiaustraliaeast\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenainorthcentralus\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaisouthcentralus\", \"aide-gpt-4.1\"),\n\t\t}),\n\t\t\"aide-gpt-4.1-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4.1-mini\", true, crowdapi, qc, smtpserver, cl100k, 40, 160), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4.1-mini\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4.1-mini\"),\n\t\t}),\n\t\t\"aide-gpt-4.1-nano\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4.1-nano\", true, crowdapi, qc, smtpserver, cl100k, 10, 40), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4.1-nano\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4.1-nano\"),\n\t\t}),\n\t\t\"aide-gpt-5\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5\", true, crowdapi, qc, smtpserver, cl100k, 125, 1000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5\"),\n\t\t}),\n\t\t\"aide-gpt-5-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5-mini\", true, crowdapi, qc, smtpserver, cl100k, 250, 200), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5-mini\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5-mini\"),\n\t\t}),\n\t\t\"aide-gpt-5-nano\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5-nano\", true, crowdapi, qc, smtpserver, cl100k, 5, 40), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5-nano\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5-nano\"),\n\t\t}),\n\t\t\"aide-gpt-5-chat\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5-chat\", true, crowdapi, qc, smtpserver, cl100k, 125, 1000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5-chat\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5-chat\"),\n\t\t}),\n\t\t\"aide-o1-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o1-mini\", true, crowdapi, qc, smtpserver, cl100k, 300, 1200), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o1-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o1-mini\"),\n\t\t}),\n\t\t\"aide-o1\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o1\", true, crowdapi, qc, smtpserver, cl100k, 1500, 6000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o1\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o1\"),\n\t\t}),\n\t\t// o1-preview will be deprecated if o1 is stable\n\t\t\"aide-o1-preview\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o1-preview\", true, crowdapi, qc, smtpserver, cl100k, 1500, 6000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o1-preview\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o1-preview\"),\n\t\t}),\n\t\t\"aide-o3-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o3-mini\", true, crowdapi, qc, smtpserver, cl100k, 110, 440), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o3-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o3-mini\"),\n\t\t}),\n\t\t\"aide-o3\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o3\", true, crowdapi, qc, smtpserver, cl100k, 200, 800), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o3\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o3\"),\n\t\t}),\n\t\t\"aide-o3-pro\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o3-pro\", true, crowdapi, qc, smtpserver, cl100k, 2000, 8000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o3-pro\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o3-pro\"),\n\t\t}),\n\t\t\"aide-o4-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o4-mini\", true, crowdapi, qc, smtpserver, cl100k, 110, 440), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o4-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o4-mini\"),\n\t\t}),\n\t\t\"aide-gpt-4-turbo-vision\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4-turbo-vision\", true, crowdapi, qc, smtpserver, cl100k, 1000, 1500*2), []endpointconfig{\n\t\t\taoai(10, \"aideopenaiaustraliaeast\", \"aide-gpt-4-turbo-vision\"),\n\t\t\taoai(10, \"aideopenaiwestus\", \"aide-gpt-4-turbo-vision\"),\n\t\t\taoai(10, \"aideopenaiswitzerlandnorth\", \"aide-gpt-4-turbo-vision\"),\n\t\t\taoai(10, \"aideopenaiswedencentral\", \"aide-gpt-4-turbo-vision\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo-16k-4k\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo-16k-4k\", true, crowdapi, qc, smtpserver, cl100k, 100, 200), []endpointconfig{\n\t\t\taoai(720, \"aideopenaiaustraliaeast\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(3720, \"aideopenaicanadaeast\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaifrancecentral\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaisouthindia\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaiwestus\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaiuksouth\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(1800, \"aideopenainorthcentralus\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaisouthcentralus\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo\", false, crowdapi, qc, smtpserver, cl100k, 150, 200), []endpointconfig{\n\t\t\taoai(1440, \"aideopenaifrancecentral\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(720, \"aideopenaisouthcentralus\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1440, \"aideopenaiuksouth\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(900, \"aideopenaicanadaeast\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaijapaneast\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(900, \"aideopenainorthcentralus\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaieastus2\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaiaustraliaeast\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(3000, \"aideopenaiswitzerlandnorth\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(3000, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaieastus\", \"aide-gpt-35-turbo\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo-instruct\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo-instruct\", false, crowdapi, qc, smtpserver, cl100k, 150, 200), []endpointconfig{\n\t\t\taoai(1440, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo-instruct\"),\n\t\t\taoai(1440, \"aideopenaieastus\", \"aide-gpt-35-turbo-instruct\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo-16k\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo-16k\", false, crowdapi, qc, smtpserver, cl100k, 300, 400), []endpointconfig{\n\t\t\taoai(1440, \"aideopenaifrancecentral\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(3000, \"aideopenaiuksouth\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(900, \"aideopenaicanadaeast\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaijapaneast\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(900, \"aideopenainorthcentralus\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(3000, \"aideopenaieastus2\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaiaustraliaeast\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaiswitzerlandnorth\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1440, \"aideopenaieastus\", \"aide-gpt-35-turbo-16k\"),\n\t\t}),\n\t\t\"aide-text-embedding-3-large\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-3-large\", false, crowdapi, qc, smtpserver, cl100k, 13, 13), []endpointconfig{\n\t\t\taoai(2100, \"aideopenaicanadaeast\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaieastus\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaieastus2\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaifrancecentral\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaijapaneast\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaisouthindia\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaiswedencentral\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaiuksouth\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaiwestus3\", \"aide-text-embedding-3-large\"),\n\t\t}),\n\t\t\"aide-text-embedding-3-small\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-3-small\", false, crowdapi, qc, smtpserver, cl100k, 2, 2), []endpointconfig{\n\t\t\taoai(2100, \"aideopenaicanadaeast\", \"aide-text-embedding-3-small\"),\n\t\t\taoai(2100, \"aideopenaieastus\", \"aide-text-embedding-3-small\"),\n\t\t\taoai(2100, \"aideopenaieastus2\", \"aide-text-embedding-3-small\"),\n\t\t}),\n\t\t\"aide-text-embedding-ada-002-v2\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-ada-002-v2\", false, crowdapi, qc, smtpserver, cl100k, 10, 10), []endpointconfig{\n\t\t\taoai(4200, \"aideopenaiwesteurope\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(4200, \"aideopenaieastus2\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(4200, \"aideopenaisouthcentralus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiaustraliaeast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaicanadaeast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaijapaneast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiswitzerlandnorth\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenainorthcentralus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiuksouth\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaifrancecentral\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiswedencentral\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(1380, \"aideopenaieastus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiwestus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenainorwayeast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaisouthindia\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaisouthafricanorth\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiwestus3\", \"aide-text-embedding-ada-002-v2\"),\n\t\t}),\n\t\t\"aide-text-embedding-ada-002\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-ada-002\", false, crowdapi, qc, smtpserver, cl100k, 10, 10), []endpointconfig{\n\t\t\taoai(20, \"aideopenaieastus\", \"aide-text-embedding-ada-002\"),\n\t\t}),\n\t\t\"aide-davinci-003\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-davinci-003\", false, crowdapi, qc, smtpserver, p50k, 2000, 2000), []endpointconfig{\n\t\t\taoai(600, \"aideopenaieastus\", \"aide-davinci-003\"),\n\t\t}),\n\t\t\"aide-code-davinci-002\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-code-davinci-002\", false, crowdapi, qc, smtpserver, p50k, 1000, 1000), []endpointconfig{\n\t\t\taoai(600, \"aideopenaieastus\", \"aide-code-davinci-002\"),\n\t\t}),\n\t\t\"aide-whisper\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\testimate = 6000000 // assume 10 minute\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoaiNoReqLog(3, \"aideopenaieastus2\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenainorthcentralus\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenainorwayeast\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenaisouthindia\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenaiswedencentral\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenaiwesteurope\", \"aide-whisper\"),\n\t\t}),\n\t\t\"aide-tts\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\testimate = 15000000 // assume 10000 characters\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(3, \"aideopenainorthcentralus\", \"aide-tts\"),\n\t\t\taoai(3, \"aideopenaiswedencentral\", \"aide-tts\"),\n\t\t}),\n\t\t\"aide-gpt-4o-realtime-preview\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\treturn\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(500, \"aideopenaieastus2\", \"aide-gpt-4o-realtime-preview\"),\n\t\t\taoai(500, \"aideopenaiswedencentral\", \"aide-gpt-4o-realtime-preview\"),\n\t\t}),\n\t\t\"aide-tts-hd\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\testimate = 30000000 // assume 10000 characters\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(3, \"aideopenainorthcentralus\", \"aide-tts-hd\"),\n\t\t\taoai(3, \"aideopenaiswedencentral\", \"aide-tts-hd\"),\n\t\t}),\n\t\t\"Dalle3\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\tvar dreq DalleReq\n\t\t\t\tif err := json.Unmarshal([]byte(body), &dreq); err == nil {\n\t\t\t\t\testimate = dreq.N * 4000000 // $4 for 100 images\n\t\t\t\t}\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(240, \"aideopenaiswedencentral\", \"dalle-3\"),\n\t\t\taoai(240, \"aideopenaiaustraliaeast\", \"dalle-3\"),\n\t\t\taoai(240, \"aideopenaieastus\", \"dalle-3\"),\n\t\t}),\n\t\t\"dalle\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\tvar dreq DalleReq\n\t\t\t\tif err := json.Unmarshal([]byte(body), &dreq); err == nil {\n\t\t\t\t\testimate = dreq.N * 2000000 // $2 for 100 images\n\t\t\t\t}\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(1380, \"aideopenaieastus\", \"dalle\"),\n\t\t}),\n\t\t\"dalleget\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\treturn 0, 1, nil\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(1380, \"aideopenaieastus\", \"dalleget\"),\n\t\t}),\n\t}\n\taoaifallback = NewEndpoint(context.Background(), true, aoai(0, \"aideopenaieastus\", \"other\"), tr, logger, aoaiSpend(\"\", true, crowdapi, qc, smtpserver, cl100k, 200, 150))\n\n\tassistantsAPIResource := envstr(\"ASSISTANTS_API_RESOURCE\", \"aideopenaiaustraliaeast\")\n\tassistantsAPI := NewEndpoint(context.Background(), false, endpointconfig{\n\t\turl:    fmt.Sprintf(\"https://%s.openai.azure.com\", assistantsAPIResource),\n\t\thdrs:   map[string]string{\"api-key\": envstr(\"AZURE_OPAI_KEY_\"+strings.ReplaceAll(assistantsAPIResource, \"-\", \"_\"), \"\")},\n\t\tlabels: []string{\"aoai\", \"assistants\", assistantsAPIResource},\n\t}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"/runs\") {\n\t\t\t\testimate = 1000000 // estimated assistants api costs $10 for 1000 runs\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tazurecognitive := NewEndpoint(context.Background(), true, endpointconfig{url: envstr(\"AZURE_COGNITIVE_HOST\", \"https://aide-cognitive-multi.cognitiveservices.azure.com\"), hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envmust(\"AZURE_COGNITIVE_KEY\"),\n\t}, noreqlog: true, labels: []string{\"cogn\", \"ocr\", \"azure-cognitive-multi\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"read/analyze\") {\n\t\t\t\testimate = 100000 // OCR api costs $1 for 1000 calls\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif strings.Contains(req.URL.Path, \":analyze\") {\n\t\t\t\testimate = 1000000 // document api costs $10 per 1,000 pages\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tsttxy := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://southeastasia.stt.speech.microsoft.com\", hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envstr(\"SPEECH_API_KEY\", envmust(\"AZURE_COGNITIVE_KEY\")),\n\t}, noreqlog: true, labels: []string{\"cogn\", \"stt\", \"southeastasia\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tcustomvoice := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://southeastasia.customvoice.api.speech.microsoft.com\", hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envmust(\"AZURE_COGNITIVE_KEY\"),\n\t}, labels: []string{\"cogn\", \"tts\", \"southeastasia\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"batchsynthesis\") {\n\t\t\t\testimate = 100000 // TTS api costs $1 for 1 hour\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tbing := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://api.bing.microsoft.com\", hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envstr(\"AZURE_BING_KEY\", \"\"),\n\t}, labels: []string{\"cogn\", \"bing\", \"southeastasia\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"batchsynthesis\") {\n\t\t\t\testimate = 300000 // search api costs $3 for 1000 calls\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tcsesLLMAPIURL := envstr(\"CSES_LLM_API_URL\", \"https://mtklm-core.mediatek.inc\")\n\n\tmtklmr := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://mtklm-mr.mediatek.inc\", labels: []string{\"mtkmr\", \"cses\", \"c\"}, hdrs: map[string]string{\n\t\t\"Authorization\": \"Bearer \" + envstr(\"CSES_LLM_MR_API_KEY\", \"\"),\n\t}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tmtkcreatetoken := os.Getenv(\"CREATE_MTK_RESEARCH_COM_LLM_API_TOKEN\")\n\n\tmtkcreate := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://create.mtkresearch.com\", labels: []string{\"mtkmr\", \"cses\", \"c\"}, hdrs: map[string]string{\n\t\t\"Authorization\": fmt.Sprintf(\"Bearer %s\", mtkcreatetoken),\n\t}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tmtklcore := NewEndpoint(context.Background(), false, endpointconfig{url: csesLLMAPIURL, labels: []string{\"mtkcore\", \"cses\", \"c\"}, hdrs: map[string]string{\n\t\t\"Authorization\": \"Bearer \" + envstr(\"CSES_LLM_API_KEY\", \"\"),\n\t}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tmodel := extractModel(req.URL.Path, body)\n\t\t\tif model != \"\" {\n\t\t\t\tif ok := permMgr.CheckServicePermission(req.Context(), req, model, domain, user, crowdapi); !ok {\n\t\t\t\t\treturn 0, 1, DomainNotAllowed\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tvar creds *google.Credentials\n\tvar gcpcredonce sync.Once\n\n\tgeminiRegions := gemini.GeminiRegions\n\tgeminis := make(map[string]*endpoint, len(geminiRegions))\n\tfor _, region := range geminiRegions {\n\t\t// Use smart SpendFn that can handle multiple Gemini models dynamically\n\t\tspendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)\n\t\tgeminis[region] = NewEndpoint(context.Background(), false, endpointconfig{\n\t\t\turl:    \"https://aiplatform.googleapis.com\",\n\t\t\tlabels: []string{\"gcp\", \"gemini\", region},\n\t\t}, tr, logger, spendFn)\n\t}\n\n\tdavinciShareProd := NewDaviciShareServerFunc(envstr(\"STORE_API_PROD_URL\", \"http://store-api-prod.default.svc.cluster.mke\"), envstr(\"DAVINCI_PROD_URL\", \"https://davinci.mediatek.inc/\"))\n\tdavinciShareStag := NewDaviciShareServerFunc(envstr(\"STORE_API_STAG_URL\", \"http://store-api-stag.default.svc.cluster.mke\"), envstr(\"DAVINCI_STAG_URL\", \"https://davinci-io.mediatek.inc/\"))\n\n\tawsKey := os.Getenv(\"AWS_ACCESS_KEY\")\n\tawsSecret := os.Getenv(\"AWS_SECRET_KEY\")\n\tawssigner := v4.NewSigner()\n\tsignAwsReq := awsclaude.SignAwsReq(awssigner, awsKey, awsSecret)\n\n\tawsdispatchers := make(map[string]*dispatcher)\n\tawsModelEndpointConfigs := make(map[string][]endpointconfig)\n\tmodelIDSpendFnKey := make(map[string]string)\n\tfor modelKey, arn := range awsclaude.ModelARNs {\n\t\tregion := awsclaude.GetRegionFromArn(arn)\n\t\tmodelWithVersion := awsclaude.GetModelWithVersionFromArn(arn)\n\t\tmodelId := awsclaude.GetModelIDFromModelWithVersion(modelWithVersion)\n\n\t\tendpointUrl := awsclaude.GetEndpointFromRegion(region)\n\t\tspendFnKey := awsclaude.ModelKeyToSpendFnKey(modelKey) // 例如 \"claude-v3-5-haiku\"\n\t\tmodelIDSpendFnKey[modelId] = spendFnKey\n\n\t\tspendFnFactory, ok := awsclaude.SpendFnMap[spendFnKey]\n\t\tif !ok {\n\t\t\tpanic(\"no spendFn for model: \" + modelKey)\n\t\t}\n\n\t\tfn := spendFnFactory(signAwsReq, crowdapi, qc, smtpserver, cl100k)\n\t\tepcForArn := endpointconfig{\n\t\t\tweight: 1,\n\t\t\turl:    endpointUrl,\n\t\t\tlabels: []string{\"awsbedrock\", modelKey, region},\n\t\t}\n\t\tbedrockendpoint[modelKey] = NewEndpoint(\n\t\t\tcontext.Background(), false, epcForArn, tr, logger, fn,\n\t\t)\n\n\t\tepcForModelId := endpointconfig{\n\t\t\tweight: 1,\n\t\t\turl:    endpointUrl + \"/model/\" + modelWithVersion,\n\t\t\tlabels: []string{\"awsbedrock\", modelKey, region},\n\t\t}\n\n\t\tawsModelEndpointConfigs[modelId] = append(awsModelEndpointConfigs[modelId], epcForModelId)\n\t}\n\n\tfor modelId, epcs := range awsModelEndpointConfigs {\n\t\tspendFnKey := modelIDSpendFnKey[modelId]\n\t\tspendFn := awsclaude.SpendFnMap[spendFnKey](signAwsReq, crowdapi, qc, smtpserver, cl100k)\n\t\tawsdispatchers[modelId] = NewDispatcher(tr, logger, false, spendFn, epcs)\n\t}\n\n\t// update modelMapGroupSVC\n\t// Initialize ModelPermissionManager before usage below\n\t// permMgr already initialized above using jwtKey and crowdapi\n\tmodelGroupSvc := NewModelGroupService(domain, logger)\n\tinitParams := ModelGroupInitParams{\n\t\tDomain:         domain,\n\t\tAOAIDispatcher: aoaidispatchers,\n\t\tAWSDispatcher:  awsdispatchers,\n\t\t// Use the injected model permission manager's map\n\t\tModelPermissionMap: permMgr.Map,\n\t\tClaudeGroups:       map[string]map[string]string{}, // ClaudeGroups temporarily disabled, replaced with an empty map. TODO: Restore when fixed.\n\t}\n\tmodelGroupSvc.InitAllModelGroups(initParams)\n\tenableModelCheck := envBool(\"ENABLE_MODEL_CHECK\", false)\n\n\tallowedLogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\n\tuserService := user.NewEngine(userServiceURL, jwtKey, crowdapi)\n\tjwtVeriHandler := APIV1.JWTVerifyHandler(userService)\n\tgin.SetMode(gin.ReleaseMode)\n\tapp := gin.New()\n\tapp.Use(gin.Recovery())\n\tapp.Use(header.Options)\n\tapp.Use(header.Secure)\n\tapp.Use(requestid.New())\n\tapp.GET(\"/\", func(c *gin.Context) {\n\t\tc.AbortWithStatus(http.StatusOK)\n\t})\n\t// Add auth routers\n\tauth.RegisterRoutes(app, domain, jwtKey, userService)\n\tapp.GET(\"/metrics\", gin.WrapH(promhttp.Handler()))\n\tapp.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\t{\n\t\tv1 := app.Group(\"/v1\")\n\t\tv1.GET(\"/version\", APIV1.GetVersion)\n\t\tv1.POST(\"/token\",\n\t\t\tjwtVeriHandler,\n\t\t\tmiddleware.VerifyAdmin(crowdapi, \"gaisf_admins\"),\n\t\t\tAPIV1.JWTSignHandler(\n\t\t\t\tcrowdapi,\n\t\t\t\tuserService,\n\t\t\t),\n\t\t)\n\t\tv1.POST(\"/services/:uid/token\",\n\t\t\tjwtVeriHandler,\n\t\t\tmiddleware.VerifyAdmin(crowdapi, \"gaisf_admins\"),\n\t\t\tAPIV1.ServiceJWTSignHandler(\n\t\t\t\tcrowdapi,\n\t\t\t\tuserService,\n\t\t\t),\n\t\t)\n\t\tv1.GET(\"/models\", jwtVeriHandler, APIV1.UserModelsHandler(domain, crowdapi, modelGroupSvc, false))\n\t\tv1.GET(\"/admin/models\", jwtVeriHandler, APIV1.UserModelsHandler(domain, crowdapi, modelGroupSvc, true))\n\n\t\tawsClaudeModels := make(map[string]interface{})\n\t\tfor k := range awsdispatchers {\n\t\t\tawsClaudeModels[k] = struct{}{}\n\t\t}\n\t\tdeps := &ChatHandlerDeps{\n\t\t\tAoaidDispatchers: aoaidispatchers,\n\t\t\tDomain:           domain,\n\t\t\tMtklcore:         mtklcore,\n\t\t\tGeminis:          geminis,\n\t\t\tCrowdapi:         crowdapi,\n\t\t\tBuffers:          &buffers,\n\t\t\tAwsClaudesModels: awsClaudeModels,\n\t\t}\n\t\tif enableModelCheck {\n\t\t\tv1.POST(\"/chat/completions\", jwtVeriHandler, modelGroupSvc.CompletionsMiddleware(domain), deps.ChatCompletionsHandler)\n\t\t} else {\n\t\t\tv1.POST(\"/chat/completions\", jwtVeriHandler, deps.ChatCompletionsHandler)\n\t\t}\n\t\tv1.GET(\"/users/:uid/cap\", jwtVeriHandler, APIV1.UserCapHandler(qc))\n\t\tv1.POST(\"/users/:uid/token\", jwtVeriHandler, APIV1.UserTokenHandler(userService))\n\t\tv1.POST(\"/token/check\", jwtVeriHandler, APIV1.TokenCheckHandler)\n\t\tv1.POST(\"/login\", jwtVeriHandler, APIV1.LoginHandler(userService))\n\t}\n\tapp.POST(\"/verify\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"project\": lc.Project, \"tokenId\": lc.TokenID, \"account\": lc.Account, \"domain\": lc.Domain})\n\t})\n\tapp.GET(\"/in\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tlogger := allowedLogger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", ctx.Request.Header.Get(\"X-Request-ID\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"req\", InListReq{Uid: ctx.Query(\"uid\"), List: ctx.Query(\"list\")}.ToString(), \"hdrs\", ToHeaderLogs(ctx.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\n\t\tstatus, resp := checkInCrowdGroup(crowdapi, ctx.Query(\"list\"), ctx.Query(\"uid\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"resp\", resp.ToString())\n\t\tctx.AbortWithStatusJSON(status, resp)\n\t})\n\n\t// POST /bing-search endpoint\n\t// --- credential init, only once ---\n\tazureBingCfg, _ := azurebingsearch.GetConfig()\n\tazureBingCred, _ := azidentity.NewClientSecretCredential(\n\t\tazureBingCfg.TenantID,\n\t\tazureBingCfg.ClientID,\n\t\tazureBingCfg.ClientSecret,\n\t\tnil,\n\t)\n\n\tapp.POST(\"/bing-search\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tvar req struct {\n\t\t\tQ string `json:\"q\"`\n\t\t}\n\t\tif err := ctx.ShouldBindJSON(&req); err != nil || req.Q == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"missing q\"})\n\t\t\treturn\n\t\t}\n\t\tresult, err := azurebingsearch.BingSearch(context.Background(), req.Q, azureBingCred)\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\n\t\t\t\"project\": lc.Project,\n\t\t\t\"tokenId\": lc.TokenID,\n\t\t\t\"account\": lc.Account,\n\t\t\t\"domain\":  lc.Domain,\n\t\t\t\"result\":  result,\n\t\t})\n\t})\n\n\tapp.GET(\"/searchusers\", func(ctx *gin.Context) {\n\t\tcql := ctx.Query(\"cql\")\n\t\tlimit, ok := getLimit(ctx)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tusers, err := crowdapi.SearchUsers(context.Background(), cql, limit)\n\t\tif err == crowd.ErrNoPerms {\n\t\t\tctx.AbortWithError(http.StatusForbidden, err)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, users)\n\t})\n\n\tapp.GET(\"/searchgroups\", func(ctx *gin.Context) {\n\t\tcql := ctx.Query(\"cql\")\n\t\tlimit, ok := getLimit(ctx)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tgroups, err := crowdapi.SearchGroups(context.Background(), cql, limit)\n\t\tif err == crowd.ErrNoPerms {\n\t\t\tctx.AbortWithError(http.StatusForbidden, err)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, groups)\n\t})\n\n\tapp.GET(\"/groupmembers\", func(ctx *gin.Context) {\n\t\tgroup := ctx.Query(\"group\")\n\t\tlimit, ok := getLimit(ctx)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tusers, err := crowdapi.GetGroupNestedUsers(context.Background(), group, limit)\n\t\tif err == crowd.ErrNoPerms {\n\t\t\tctx.AbortWithError(http.StatusForbidden, err)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tif strings.Contains(err.Error(), \"status code 404\") {\n\t\t\t\tctx.AbortWithError(http.StatusNotFound, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, users)\n\t})\n\tapp.GET(\"/allowed\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tlogger := allowedLogger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", ctx.Request.Header.Get(\"X-Request-ID\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"req\", common.AllowedReq{Uid: ctx.Query(\"uid\"), Domain: ctx.Query(\"domain\")}.ToString(), \"hdrs\", ToHeaderLogs(ctx.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\n\t\tstatus, resp := common.CheckPIM(crowdapi, ctx.Query(\"domain\"), ctx.Query(\"uid\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"resp\", resp.ToString())\n\t\tctx.AbortWithStatusJSON(status, resp)\n\t})\n\tapp.GET(\"/getcap\", func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tusage, cap, err := qc.GetCap(ctx.Request.Context(), uid)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"usage\": usage, \"cap\": cap, \"uid\": uid})\n\t})\n\tapp.POST(\"/charge\", func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tcost, err := strconv.Atoi(ctx.Query(\"cost\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tif cost < 0 {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, errors.New(\"the cost should be >= 0\"))\n\t\t\treturn\n\t\t}\n\t\tremain, err := qc.Spend(ctx, uid, cost)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"remain\": remain, \"uid\": uid})\n\t})\n\tapp.POST(\"/setcap\", func(ctx *gin.Context) {\n\t\tif ctx.Request.Header.Get(\"jwt-enc\") != jwtKey {\n\t\t\tctx.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"invalid jwt-enc header\"})\n\t\t\treturn\n\t\t}\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"uid is required\"})\n\t\t\treturn\n\t\t}\n\t\tcap, err := strconv.Atoi(ctx.Query(\"cap\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid cap value\"})\n\t\t\treturn\n\t\t}\n\t\tend, err := time.Parse(\"2006-01-02\", ctx.Query(\"end\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid end format\"})\n\t\t\treturn\n\t\t}\n\t\tif err = qc.SetCap(ctx.Request.Context(), uid, cap, end.Unix()); err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to set cap\"})\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{})\n\t})\n\t// Set a session cookie in Redis with a custom TTL\n\tapp.POST(\"/setSessionCookie\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tuserName := ctx.PostForm(\"user_name\")\n\t\tcookie := ctx.PostForm(\"cookie\")\n\t\tttlSecondsStr := ctx.PostForm(\"ttlSeconds\")\n\t\tttlSeconds, err := strconv.Atoi(ttlSecondsStr)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tif err := qc.SetSessionCookie(ctx, userName, cookie, ttlSeconds); err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.Status(http.StatusOK)\n\t})\n\t// Get a session cookie from Redis\n\tapp.GET(\"/getSessionCookie\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tuserName := ctx.Query(\"user_name\")\n\t\tcookie, err := qc.GetSessionCookie(ctx, userName)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tif cookie == \"\" {\n\t\t\tctx.AbortWithStatus(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, gin.H{\"cookie\": cookie})\n\t})\n\tapp.POST(\"/checkrate\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc, ok := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tif !ok || lc == nil || lc.UID == nil || *lc.UID == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"user not found in context\"})\n\t\t\treturn\n\t\t}\n\t\tuid := *lc.UID\n\t\tok, req, cap, gap, err := qc.Limit(ctx.Request.Context(), strings.ToUpper(uid))\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"ok\": ok, \"req\": req, \"cap\": cap, \"gap\": gap})\n\t})\n\tapp.POST(\"/setreq\", jwtVeriHandler, middleware.VerifyAdmin(crowdapi, \"gaisf_admins\"), func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"uid is required\"})\n\t\t\treturn\n\t\t}\n\t\treq, err := strconv.Atoi(ctx.Query(\"req\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid req\"})\n\t\t\treturn\n\t\t}\n\t\tgap, err := strconv.Atoi(ctx.Query(\"gap\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid gap\"})\n\t\t\treturn\n\t\t}\n\t\tif err = qc.SetLimit(ctx.Request.Context(), uid, int64(req), int64(gap)); err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to set limit\"})\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{})\n\t})\n\tapp.GET(\"/getreq\", func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, errors.New(\"uid is required\"))\n\t\t\treturn\n\t\t}\n\t\tret, err := qc.GetLimit(ctx.Request.Context(), uid)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"req\": ret[0], \"gap\": ret[1]})\n\t})\n\tapp.GET(\"/time\", func(ctx *gin.Context) {\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"ts\": time.Now()})\n\t})\n\tapp.POST(\"/spend\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc, ok := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tif !ok || lc == nil || lc.UID == nil || *lc.UID == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"user not found in context\"})\n\t\t\treturn\n\t\t}\n\t\tuid := *lc.UID\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, errors.New(\"uid is required\"))\n\t\t\treturn\n\t\t}\n\t\tspend, err := strconv.Atoi(ctx.Query(\"spend\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tremain, err := qc.Spend(ctx.Request.Context(), uid, spend)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"remain\": remain})\n\t})\n\n\t// davinciProcxyRouter is a Gin middleware function that handles routing and authentication for various API endpoints.\n\t// It performs the following main functions:\n\t//   - Validates domain access and user authentication\n\t//   - Enforces X-User-Id header requirement for cost allocation\n\t//   - Routes requests to appropriate services based on URL path:\n\t//     * LLM models (v3)\n\t//     * OpenAI services (including DALL-E)\n\t//     * Anthropic Claude models\n\t//     * Bing search\n\t//     * Azure Cognitive Services (vision, form recognition)\n\t//     * Speech services (text-to-speech, speech-to-text)\n\t//     * Gemini API endpoints\n\t//     * Davinci chat sharing\n\t//   - Performs PIM checks for certain endpoints\n\t//   - Enriches headers with required information\n\t//   - Handles timeout simulation for testing\n\t// Parameters:\n\t//   - c: Gin context containing the HTTP request and response information\n\tdavinciProcxyRouter := func(c *gin.Context) {\n\t\tlc := c.MustGet(\"lc\").(*common.LoggingContext)\n\t\tif lc.UID == nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": gin.H{\n\t\t\t\t\"code\":    strconv.Itoa(http.StatusForbidden),\n\t\t\t\t\"message\": \"missing UID in logging context\",\n\t\t\t}})\n\t\t\treturn\n\t\t}\n\t\tif lc.Domain == \"\" {\n\t\t\tlc.Domain = \"oa\"\n\t\t}\n\t\tif (domain == \"oa\" && lc.Domain != domain) || ((common.IsAirgappedDomain(domain) || common.IsAirgappedDomain(c.Request.Header.Get(\"X-Domain\"))) && !common.IsAirgappedDomain(lc.Domain)) {\n\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": gin.H{\n\t\t\t\t\"code\":    strconv.Itoa(http.StatusForbidden),\n\t\t\t\t\"message\": fmt.Sprintf(\"token for domain %q is prohibited here\", lc.Domain),\n\t\t\t}})\n\t\t\treturn\n\t\t}\n\t\tendUser := *lc.UID\n\t\tif endUser == \"\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": gin.H{\n\t\t\t\t\"code\":    strconv.Itoa(http.StatusForbidden),\n\t\t\t\t\"message\": \"The X-User-Id request header is now mandatory for cost allocation. Please set the parameter with \\\"mtkxxxxx\\\" for allocating to the end user's department or \\\"srv_xxxx\\\" for background jobs.\",\n\t\t\t}})\n\t\t\treturn\n\t\t}\n\n\t\t// Check if the request is for a specific endpoint that requires PIM check\n\t\t// and if the request method is POST, PUT, or GET with specific path prefix\n\t\t// If so, perform the PIM check and update the X-User-Id header if necessary\n\t\t// If the PIM check fails, abort the request with the appropriate status and response\n\t\t// If the PIM check passes, update the LoggingContext with the response data (Banwords)\n\t\tif !strings.HasPrefix(c.Request.URL.Path, \"/llm/v3\") &&\n\t\t\t(c.Request.Method == http.MethodPost ||\n\t\t\t\tc.Request.Method == http.MethodPut ||\n\t\t\t\t(c.Request.Method == http.MethodGet && strings.HasPrefix(c.Request.URL.Path, \"/v7.0\"))) {\n\t\t\tstatus, resp := common.CheckPIM(crowdapi, lc.Domain, endUser)\n\t\t\tif status != http.StatusOK {\n\t\t\t\tlogger := allowedLogger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", c.Request.Header.Get(\"X-Request-ID\"))\n\t\t\t\tlogger.Info(c.Request.URL.Path, \"req\", \"checkpim\", \"hdrs\", ToHeaderLogs(c.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\t\t\t\tlogger.Info(c.Request.URL.Path, \"resp\", resp.ToString(), \"hdrs\", ToHeaderLogs(c.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\t\t\t\tc.AbortWithStatusJSON(status, resp)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif resp.UID != \"\" && resp.UID != endUser {\n\t\t\t\tc.Request.Header.Set(\"X-User-Id\", resp.UID)\n\t\t\t}\n\t\t\tlc.Banwords = resp.Banwords\n\t\t}\n\n\t\tif strings.HasPrefix(c.Request.URL.Path, \"/timeout\") {\n\t\t\tduration, _ := time.ParseDuration(c.Query(\"dur\"))\n\t\t\ttime.Sleep(duration)\n\t\t\tc.JSON(http.StatusOK, gin.H{\"duration\": duration})\n\t\t\treturn\n\t\t}\n\n\t\tif c.Request.Method != http.MethodDelete {\n\n\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/model/anthropic\") {\n\t\t\t\tmodelId := strings.Split(c.Request.URL.Path, \"/\")[2]\n\t\t\t\tdispatcher, ok := awsdispatchers[modelId]\n\t\t\t\tif !ok {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusNotFound, gin.H{\"error\": \"model not found\"})\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tparts := strings.Split(c.Request.URL.Path, \"/\")\n\t\t\t\tc.Request.URL.Path = \"/\"\n\t\t\t\tif len(parts) > 3 {\n\t\t\t\t\tc.Request.URL.Path = \"/\" + strings.Join(parts[3:], \"/\")\n\t\t\t\t}\n\n\t\t\t\tdispatcher.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// route aws bedrock with bedrock arn\n\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/model/\") {\n\t\t\t\tmodelKey := awsclaude.ParseBedrockModelKeyFromPath(c.Request.URL.Path)\n\t\t\t\tif ep, ok := bedrockendpoint[modelKey]; ok && ep != nil {\n\t\t\t\t\tep.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/llm/v3/models/mtkresearch\") {\n\t\t\t\tif err := enrichCSESHeaders(c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)), domain, lc.Project, lc.TokenID, lc.Payload); err != nil {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif mtkcreatetoken != \"\" {\n\t\t\t\t\tmtkcreate.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t} else {\n\t\t\t\t\tmtklmr.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/llm/v3/info\") {\n\t\t\t\tif err := enrichCSESHeaders(c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)), domain, lc.Project, lc.TokenID, lc.Payload); err != nil {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmtklcore.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/llm/v3/models\") {\n\t\t\t\tif err := enrichCSESHeaders(c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)), domain, lc.Project, lc.TokenID, lc.Payload); err != nil {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmtklcore.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/openai/\") {\n\t\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/openai/assistants\") {\n\t\t\t\t\tassistantsAPI.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/openai/threads\") {\n\t\t\t\t\tassistantsAPI.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/openai/files\") {\n\t\t\t\t\tassistantsAPI.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tdeployment := extractURLSlug(c.Request.URL.Path, 3)\n\t\t\t\tswitch deployment {\n\t\t\t\tcase \"generations:submit\": // DALL·E submit\n\t\t\t\t\tdeployment = \"dalle\"\n\t\t\t\tcase \"images\": // DALL·E get\n\t\t\t\t\tdeployment = \"dalleget\"\n\t\t\t\t}\n\t\t\t\tif d, ok := aoaidispatchers[deployment]; ok {\n\t\t\t\t\t// Check and set default api-version only if needed\n\t\t\t\t\t// See the reference: https://learn.microsoft.com/en-us/azure/ai-services/openai/reference\n\t\t\t\t\tq := c.Request.URL.Query()\n\t\t\t\t\tif q.Get(\"api-version\") == \"\" {\n\t\t\t\t\t\tq.Set(\"api-version\", azure.OpenAIAPIVersion)\n\t\t\t\t\t\tc.Request.URL.RawQuery = q.Encode()\n\t\t\t\t\t}\n\t\t\t\t\td.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t} else {\n\t\t\t\t\tif aoaifallback == nil || aoaifallback.proxy == nil {\n\t\t\t\t\t\tc.AbortWithStatus(http.StatusNotFound)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\taoaifallback.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/v7.0/search\") {\n\t\t\t\tbing.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/vision\") {\n\t\t\t\tif c.Request.ContentLength > 1024*1024*10 {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": gin.H{\n\t\t\t\t\t\t\"code\": strconv.Itoa(http.StatusBadRequest),\n\t\t\t\t\t}})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tazurecognitive.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/formrecognizer\") {\n\t\t\t\tazurecognitive.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/api/texttospeech\") {\n\t\t\t\tcustomvoice.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/speech/recognition/conversation/cognitiveservices\") {\n\t\t\t\tsttxy.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/v1/projects/mtk-aide-gemini-poc/locations\") {\n\t\t\t\tfor region, endpoint := range geminis {\n\t\t\t\t\tif strings.HasPrefix(c.Request.URL.Path[len(\"/v1/projects/mtk-aide-gemini-poc/locations/\"):], region) {\n\t\t\t\t\t\tendpoint.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.AbortWithStatus(http.StatusNotFound)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tdeployment := extractURLSlug(c.Request.URL.Path, 1)\n\n\t\t\t\tif d, ok := aoaidispatchers[deployment]; ok {\n\t\t\t\t\tc.Request.URL.Path = strings.TrimPrefix(c.Request.URL.Path, \"/\"+deployment)\n\t\t\t\t\td.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif strings.HasPrefix(c.Request.URL.Path, \"/davinci/share-chat\") {\n\t\t\tdavinciShareProd(c)\n\t\t\treturn\n\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/davinci-io/share-chat\") {\n\t\t\tdavinciShareStag(c)\n\t\t\treturn\n\t\t}\n\t\tc.AbortWithStatus(http.StatusNotFound)\n\t}\n\n\tenableLLMOverride := envBool(\"ENABLE_OVERRIDE_LLM\", false)\n\tif enableLLMOverride {\n\t\tinitOverriddenMiddleware()\n\t\tapp.NoRoute(header.Options, jwtVeriHandler, overrideMiddleware, davinciProcxyRouter)\n\t} else {\n\t\tapp.NoRoute(header.Options, jwtVeriHandler, davinciProcxyRouter)\n\t}\n\n\tgo func() {\n\t\tsrv := &http.Server{\n\t\t\tAddr:              \":\" + envstr(\"SERVER_PORT\", \"8080\"),\n\t\t\tHandler:           app.Handler(),\n\t\t\tReadHeaderTimeout: time.Minute,\n\t\t\tReadTimeout:       0, // intentionally 0\n\t\t\tWriteTimeout:      0, // intentionally 0\n\t\t\tMaxHeaderBytes:    http.DefaultMaxHeaderBytes,\n\t\t}\n\t\tif err := srv.ListenAndServe(); err != http.ErrServerClosed {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tpoker := poker.DavinciPoker{\n\t\tUsername:    envstr(\"IA_USERNAME\", \"\"),\n\t\tPassword:    envstr(\"IA_PASSWORD\", \"\"),\n\t\tBotTenantID: envstr(\"BOT_TENANT_ID\", \"\"),\n\t\tBotID:       envstr(\"BOT_ID\", \"\"),\n\t\tBotPassword: envstr(\"BOT_PASSWORD\", \"\"),\n\t}\n\tgo poker.RunLoop(30 * time.Minute)\n\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\t<-sigs\n\tcancel()\n\ttime.Sleep(5 * time.Second)\n}\n","structuredPatch":[{"oldStart":30,"oldLines":7,"newStart":30,"newLines":7,"lines":[" ","   \"gitea.mediatek.inc/davinci/azure-gateway/awsclaude\"","   \"gitea.mediatek.inc/davinci/azure-gateway/azure\"","-  \"gitea.mediatek.inc/davinci/azure-gateway/gemini\"","+  \"gitea.mediatek.inc/davinci/azure-gateway/gcp\"","   \"gitea.mediatek.inc/davinci/azure-gateway/common\"","   \"gitea.mediatek.inc/davinci/azure-gateway/crowdadapter\"","   \"gitea.mediatek.inc/davinci/azure-gateway/dailyreset\""]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"1808bec2-67ad-42fa-a77c-bfa85cc944aa","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01JaNx2n6u9wy1hrHNJPrF6v","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now let me check if there are any other files that might reference the gemini folder path:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1482,"cache_read_input_tokens":28835,"output_tokens":1}},"type":"assistant","uuid":"6764631a-4c36-494d-b213-1f4041490390","timestamp":"2025-08-18T03:18:53.309Z"}
{"parentUuid":"6764631a-4c36-494d-b213-1f4041490390","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01JaNx2n6u9wy1hrHNJPrF6v","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01ND1UmDZZmduXg1dq9ddEXy","name":"Grep","input":{"pattern":"azure-gateway/gemini","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1482,"cache_read_input_tokens":28835,"output_tokens":100}},"type":"assistant","uuid":"e353aa96-7505-4e81-954c-092631049ba4","timestamp":"2025-08-18T03:18:53.830Z"}
{"parentUuid":"e353aa96-7505-4e81-954c-092631049ba4","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01ND1UmDZZmduXg1dq9ddEXy","type":"tool_result","content":"No files found"}]},"uuid":"35eba314-788c-494b-a519-572b03198c96","timestamp":"2025-08-18T03:18:53.963Z","toolUseResult":{"mode":"files_with_matches","filenames":[],"numFiles":0}}
{"parentUuid":"35eba314-788c-494b-a519-572b03198c96","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01WMPzBpPJxq4wDJ9MUQddhD","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Let me also check for any other imports or references in the other files:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":115,"cache_read_input_tokens":30317,"output_tokens":1}},"type":"assistant","uuid":"e3ae5494-7d1c-4a78-9cd8-315555b598d9","timestamp":"2025-08-18T03:18:56.924Z"}
{"parentUuid":"e3ae5494-7d1c-4a78-9cd8-315555b598d9","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01WMPzBpPJxq4wDJ9MUQddhD","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01QKNXSBcfEuas399HwCNmr4","name":"Read","input":{"file_path":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/chatHandler.go","limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":115,"cache_read_input_tokens":30317,"output_tokens":112}},"type":"assistant","uuid":"25a1a1e7-cefb-4f9f-846f-989767e7bf96","timestamp":"2025-08-18T03:18:57.334Z"}
{"parentUuid":"25a1a1e7-cefb-4f9f-846f-989767e7bf96","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01QKNXSBcfEuas399HwCNmr4","type":"tool_result","content":"     1→package main\n     2→\n     3→import (\n     4→\t\"bytes\"\n     5→\t\"context\"\n     6→\t\"encoding/json\"\n     7→\t\"fmt\"\n     8→\t\"io\"\n     9→\t\"net/http\"\n    10→\t\"path\"\n    11→\t\"strings\"\n    12→\t\"sync\"\n    13→\n    14→\t\"gitea.mediatek.inc/davinci/azure-gateway/awsclaude\"\n    15→\t\"gitea.mediatek.inc/davinci/azure-gateway/azure\"\n    16→\t\"gitea.mediatek.inc/davinci/azure-gateway/common\"\n    17→\t\"gitea.mediatek.inc/davinci/azure-gateway/crowdadapter\"\n    18→\n    19→\t\"github.com/appleboy/com/bytesconv\"\n    20→\t\"github.com/bytedance/sonic\"\n    21→\t\"github.com/gin-gonic/gin\"\n    22→)\n    23→\n    24→// ChatHandlerDeps defines dependencies for chat completions handler.\n    25→type ChatHandlerDeps struct {\n    26→\tAoaidDispatchers map[string]*dispatcher\n    27→\tDomain           string\n    28→\tMtklcore         *endpoint\n    29→\tGeminis          map[string]*endpoint\n    30→\tCrowdapi         crowdadapter.Adapter\n    31→\tBuffers          *sync.Pool\n    32→\tAwsClaudesModels map[string]interface{}\n    33→}\n    34→\n    35→// ChatCompletionsHandler handles chat completions requests.\n    36→func (h *ChatHandlerDeps) ChatCompletionsHandler(c *gin.Context) {\n    37→\t// Get logging context from middleware\n    38→\tlc := c.MustGet(\"lc\").(*common.LoggingContext)\n    39→\n    40→\t// Read and preserve the original request body\n    41→\trawBody, err := c.GetRawData()\n    42→\tif err != nil {\n    43→\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to read request body\"})\n    44→\t\treturn\n    45→\t}\n    46→\n    47→\t// Extract the model name from the request body\n    48→\t// Partial parsing for model replacement\n    49→\tvar reqBody map[string]json.RawMessage\n    50→\tif err := sonic.Unmarshal(rawBody, &reqBody); err != nil {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"fd7fd66d-8bc3-4afe-b478-480f8ae1f0a9","timestamp":"2025-08-18T03:18:57.371Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/chatHandler.go","content":"package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"path\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"gitea.mediatek.inc/davinci/azure-gateway/awsclaude\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/azure\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/common\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/crowdadapter\"\n\n\t\"github.com/appleboy/com/bytesconv\"\n\t\"github.com/bytedance/sonic\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n// ChatHandlerDeps defines dependencies for chat completions handler.\ntype ChatHandlerDeps struct {\n\tAoaidDispatchers map[string]*dispatcher\n\tDomain           string\n\tMtklcore         *endpoint\n\tGeminis          map[string]*endpoint\n\tCrowdapi         crowdadapter.Adapter\n\tBuffers          *sync.Pool\n\tAwsClaudesModels map[string]interface{}\n}\n\n// ChatCompletionsHandler handles chat completions requests.\nfunc (h *ChatHandlerDeps) ChatCompletionsHandler(c *gin.Context) {\n\t// Get logging context from middleware\n\tlc := c.MustGet(\"lc\").(*common.LoggingContext)\n\n\t// Read and preserve the original request body\n\trawBody, err := c.GetRawData()\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": \"Failed to read request body\"})\n\t\treturn\n\t}\n\n\t// Extract the model name from the request body\n\t// Partial parsing for model replacement\n\tvar reqBody map[string]json.RawMessage\n\tif err := sonic.Unmarshal(rawBody, &reqBody); err != nil {","numLines":50,"startLine":1,"totalLines":198}}}
{"parentUuid":"fd7fd66d-8bc3-4afe-b478-480f8ae1f0a9","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_016VgJ6Zm7H8Fs5HH46nH1nP","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"I can see in the chatHandler.go file there's a reference to \"Geminis\" field on line 29, but this is just a field name and doesn't need to be changed since you mentioned the code names can stay as \"gemini\". Let me check the modelGroupsData.go file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1336,"cache_read_input_tokens":29919,"output_tokens":1}},"type":"assistant","uuid":"28a7709e-e16b-440c-adce-9ba7381e3a64","timestamp":"2025-08-18T03:19:01.007Z"}
{"parentUuid":"28a7709e-e16b-440c-adce-9ba7381e3a64","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_016VgJ6Zm7H8Fs5HH46nH1nP","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01HoJJxEebJC3cDEsFBBFtLg","name":"Grep","input":{"pattern":"gemini","path":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/modelGroupsData.go","output_mode":"content","-n":true,"head_limit":10}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1336,"cache_read_input_tokens":29919,"output_tokens":220}},"type":"assistant","uuid":"cc00715c-4995-49ef-9c94-89ac77274ca0","timestamp":"2025-08-18T03:19:02.205Z"}
{"parentUuid":"cc00715c-4995-49ef-9c94-89ac77274ca0","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01HoJJxEebJC3cDEsFBBFtLg","type":"tool_result","content":"156:\t\t\t\t\t\"gemini-2.5-flash\",\n157:\t\t\t\t\t\"gemini-2.5-pro\",\n158:\t\t\t\t\t\"gemini-2.5-flash-lite-preview-06-17\",\n159:\t\t\t\t\t\"gemini-2.0-flash-001\",\n160:\t\t\t\t\t\"gemini-2.0-flash-lite-001\",\n183:\t\t\t\t\t\"gemini-2.5-flash\",\n184:\t\t\t\t\t\"gemini-2.5-pro\",\n185:\t\t\t\t\t\"gemini-2.5-flash-lite-preview-06-17\",\n186:\t\t\t\t\t\"gemini-2.0-flash-001\",\n187:\t\t\t\t\t\"gemini-2.0-flash-lite-001\","}]},"uuid":"e5fc4cd4-a0d1-4ec5-a59e-12bcf7bd8c82","timestamp":"2025-08-18T03:19:02.231Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"156:\t\t\t\t\t\"gemini-2.5-flash\",\n157:\t\t\t\t\t\"gemini-2.5-pro\",\n158:\t\t\t\t\t\"gemini-2.5-flash-lite-preview-06-17\",\n159:\t\t\t\t\t\"gemini-2.0-flash-001\",\n160:\t\t\t\t\t\"gemini-2.0-flash-lite-001\",\n183:\t\t\t\t\t\"gemini-2.5-flash\",\n184:\t\t\t\t\t\"gemini-2.5-pro\",\n185:\t\t\t\t\t\"gemini-2.5-flash-lite-preview-06-17\",\n186:\t\t\t\t\t\"gemini-2.0-flash-001\",\n187:\t\t\t\t\t\"gemini-2.0-flash-lite-001\",","numLines":10}}
{"parentUuid":"e5fc4cd4-a0d1-4ec5-a59e-12bcf7bd8c82","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01MEEkhekaK3gaUE9LxZxrHT","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Let me also check the main_current.go file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1225,"cache_read_input_tokens":30432,"output_tokens":1}},"type":"assistant","uuid":"d30064af-f7bc-47a9-93de-64eda0857183","timestamp":"2025-08-18T03:19:05.455Z"}
{"parentUuid":"d30064af-f7bc-47a9-93de-64eda0857183","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01MEEkhekaK3gaUE9LxZxrHT","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_012DWbLMePKfZjfwpuqm7Qgv","name":"Grep","input":{"pattern":"azure-gateway/gemini","path":"/Users/mtk19651/project/azure-gateway/main_current.go","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1225,"cache_read_input_tokens":30432,"output_tokens":142}},"type":"assistant","uuid":"4ff22148-99f0-43cf-bf80-fa4c959bc796","timestamp":"2025-08-18T03:19:05.711Z"}
{"parentUuid":"4ff22148-99f0-43cf-bf80-fa4c959bc796","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_012DWbLMePKfZjfwpuqm7Qgv","type":"tool_result","content":"No matches found"}]},"uuid":"9a6b90d7-2568-4f53-81eb-56b443b1b9e0","timestamp":"2025-08-18T03:19:05.737Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"9a6b90d7-2568-4f53-81eb-56b443b1b9e0","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01DfjYg3WaawsSNg9N6ss55c","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Let me check if there are any references to the gemini package usage (not just imports):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":157,"cache_read_input_tokens":31657,"output_tokens":1}},"type":"assistant","uuid":"2df002f4-ceb7-4b76-8542-c1a2e1aa657c","timestamp":"2025-08-18T03:19:08.649Z"}
{"parentUuid":"2df002f4-ceb7-4b76-8542-c1a2e1aa657c","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01DfjYg3WaawsSNg9N6ss55c","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01CYTV3WTqcdykgHqb94Qpjb","name":"Grep","input":{"pattern":"gemini\\.","path":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":157,"cache_read_input_tokens":31657,"output_tokens":153}},"type":"assistant","uuid":"caab4fbb-f36e-4ff8-9352-d9f23618d70e","timestamp":"2025-08-18T03:19:09.468Z"}
{"parentUuid":"caab4fbb-f36e-4ff8-9352-d9f23618d70e","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01CYTV3WTqcdykgHqb94Qpjb","type":"tool_result","content":"1920:\tgeminiRegions := gemini.GeminiRegions\n1924:\t\tspendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)"}]},"uuid":"9116a542-2f6e-43a2-972e-ec5d2fed2c69","timestamp":"2025-08-18T03:19:09.496Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"1920:\tgeminiRegions := gemini.GeminiRegions\n1924:\t\tspendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)","numLines":2}}
{"parentUuid":"9116a542-2f6e-43a2-972e-ec5d2fed2c69","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_012cgzJHTrGUSwXegPJoH8Sj","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now I need to update these gemini package references to gcp:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":902,"cache_read_input_tokens":31255,"output_tokens":1}},"type":"assistant","uuid":"6e15fe94-3c7d-4a18-aa10-5b775e0c6b91","timestamp":"2025-08-18T03:19:11.934Z"}
{"parentUuid":"6e15fe94-3c7d-4a18-aa10-5b775e0c6b91","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_012cgzJHTrGUSwXegPJoH8Sj","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_019ZcRo8C2s9rhT3uQeSnYhA","name":"Edit","input":{"file_path":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","old_string":"\tgeminiRegions := gemini.GeminiRegions","new_string":"\tgeminiRegions := gcp.GeminiRegions"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":902,"cache_read_input_tokens":31255,"output_tokens":157}},"type":"assistant","uuid":"f20c935a-2a84-4588-90c4-0b3f1498d384","timestamp":"2025-08-18T03:19:12.818Z"}
{"parentUuid":"f20c935a-2a84-4588-90c4-0b3f1498d384","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_019ZcRo8C2s9rhT3uQeSnYhA","type":"tool_result","content":"The file /Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1916→\n  1917→\tvar creds *google.Credentials\n  1918→\tvar gcpcredonce sync.Once\n  1919→\n  1920→\tgeminiRegions := gcp.GeminiRegions\n  1921→\tgeminis := make(map[string]*endpoint, len(geminiRegions))\n  1922→\tfor _, region := range geminiRegions {\n  1923→\t\t// Use smart SpendFn that can handle multiple Gemini models dynamically\n  1924→\t\tspendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)"}]},"uuid":"aa4bc4cb-7f2c-4035-b56e-75ca595e43c2","timestamp":"2025-08-18T03:19:12.852Z","toolUseResult":{"filePath":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","oldString":"\tgeminiRegions := gemini.GeminiRegions","newString":"\tgeminiRegions := gcp.GeminiRegions","originalFile":"package main\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"gitea.mediatek.inc/davinci/azure-gateway/awsclaude\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/azure\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/gcp\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/common\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/crowdadapter\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/dailyreset\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/header\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/middleware\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/poker\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/quota\"\n\trq \"gitea.mediatek.inc/davinci/azure-gateway/request_queue\"\n\tAPIV1 \"gitea.mediatek.inc/davinci/azure-gateway/router/api/v1\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/router/auth\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/service/azurebingsearch\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/service/user\"\n\n\t_ \"gitea.mediatek.inc/davinci/azure-gateway/docs\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n\tv4 \"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\t\"github.com/essentialkaos/go-crowd/v3\"\n\t\"github.com/gin-contrib/requestid\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n\t\"github.com/joho/godotenv\"\n\t\"github.com/pkoukk/tiktoken-go\"\n\ttiktoken_loader \"github.com/pkoukk/tiktoken-go-loader\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/redis/rueidis\"\n\t\"github.com/redis/rueidis/rueidisaside\"\n\tswaggerFiles \"github.com/swaggo/files\"\n\tginSwagger \"github.com/swaggo/gin-swagger\"\n\t\"golang.org/x/exp/slog\"\n\t\"golang.org/x/oauth2/google\"\n)\n\n// UserTokenRequest represents a request to generate a user token with a specified expiration time.\n// ExpirationHours specifies the number of hours the token will be valid for and is a required field.\ntype UserTokenRequest struct {\n\tExpirationHours int             `json:\"expirationHours\" binding:\"required\"`\n\tPayload         *map[string]any `json:\"payload\"`\n}\n\ntype UserLoginRequest struct {\n\tUserTokenRequest\n\tUsername string `json:\"username\" binding:\"required\"`\n\tPassword string `json:\"password\" binding:\"required\"`\n}\n\n// AoaiResp represents the response structure from the API.\n// It contains usage information about the tokens consumed during the request.\ntype AoaiResp struct {\n\tUsage struct {\n\t\t// PromptTokens represents the number of tokens used in the prompt.\n\t\t// This field is used in the original response format.\n\t\tPromptTokens int `json:\"prompt_tokens\"`\n\n\t\t// CompletionTokens represents the number of tokens used in the completion.\n\t\t// This field is used in the original response format.\n\t\tCompletionTokens int `json:\"completion_tokens\"`\n\n\t\t// InputTokens represents the number of tokens used in the input.\n\t\t// This field is used in the new response format.\n\t\tInputTokens int `json:\"input_tokens\"`\n\n\t\t// OutputTokens represents the number of tokens used in the output.\n\t\t// This field is used in the new response format.\n\t\tOutputTokens int `json:\"output_tokens\"`\n\t} `json:\"usage\"`\n}\n\ntype DalleReq struct {\n\tN int `json:\"n\"`\n}\n\ntype ResourceConfig struct {\n\tURL    string `json:\"url\"`\n\tKey    string `json:\"key\"`\n\tSecret string `json:\"secret\"`\n\tRegion string `json:\"region\"`\n\tWeight int    `json:\"weight\"`\n}\n\ntype Provider string\n\nvar (\n\tClaudeV3Provider = Provider(\"anthropic.claude-v3\")\n\tOpenAIProvider   = Provider(\"openai\")\n)\n\ntype DispatchConfig struct {\n\tProvider Provider `json:\"provider\"`\n\tModel    string   `json:\"model\"`\n\tPrice    struct {\n\t\tPrompt     int `json:\"prompt\"`\n\t\tCompletion int `json:\"completion\"`\n\t\tDalleN     int `json:\"dalleN\"`\n\t} `json:\"price\"`\n\tResources map[string]ResourceConfig `json:\"resources\"`\n}\n\nfunc checkInCrowdGroup(crowdapi crowdadapter.Adapter, list, uid string) (int, InListResp) {\n\tif _, ok := crowdapi.(*crowdadapter.Empty); ok {\n\t\treturn http.StatusOK, InListResp{In: true}\n\t}\n\tif uid == \"\" || list == \"\" {\n\t\treturn http.StatusBadRequest, InListResp{Reason: \"uid and list should not be empty\"}\n\t}\n\tif strings.Contains(uid, \"@\") {\n\t\tusers, err := crowdapi.SearchUsers(context.Background(), \"email=\"+uid, crowdadapter.DefaultLimit)\n\t\tif err != nil {\n\t\t\treturn http.StatusInternalServerError, InListResp{Reason: err.Error()}\n\t\t}\n\t\tif len(users) == 0 {\n\t\t\treturn http.StatusNotFound, InListResp{Reason: fmt.Sprintf(\"user not found: %q\", uid)}\n\t\t}\n\t\tuid = users[0].Name\n\t}\n\tgroups, err := crowdapi.GetUserNestedGroups(context.Background(), uid, crowdadapter.DefaultLimit)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, InListResp{Reason: err.Error()}\n\t}\n\tfor _, group := range groups {\n\t\tif group.Name == list {\n\t\t\treturn http.StatusOK, InListResp{In: true}\n\t\t}\n\t}\n\treturn http.StatusOK, InListResp{In: false}\n}\n\nfunc URL(target string) *url.URL {\n\tpurl, err := url.Parse(target)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn purl\n}\n\nvar buffers sync.Pool\n\nfunc NewTeeBufReader(r io.ReadCloser, done func(string)) *TeeBufReader {\n\treturn &TeeBufReader{r: r, w: buffers.Get().(*bytes.Buffer), done: done}\n}\n\ntype TeeBufReader struct {\n\tr    io.ReadCloser\n\tw    *bytes.Buffer\n\tdone func(buf string)\n}\n\nfunc (t *TeeBufReader) Read(p []byte) (n int, err error) {\n\tif t.r == nil {\n\t\treturn 0, io.EOF\n\t}\n\tn, err = t.r.Read(p)\n\tif n > 0 {\n\t\tif n, err := t.w.Write(p[:n]); err != nil {\n\t\t\treturn n, err\n\t\t}\n\t}\n\treturn\n}\n\nfunc (t *TeeBufReader) Close() (err error) {\n\tbs := t.w.Bytes()\n\tt.done(*(*string)(unsafe.Pointer(&bs)))\n\tt.w.Reset()\n\tbuffers.Put(t.w)\n\tif t.r != nil {\n\t\treturn t.r.Close()\n\t}\n\treturn nil\n}\n\ntype LoggingTransport struct {\n\tTransport http.RoundTripper\n\tlogger    *slog.Logger\n\tqueue     *rq.RequestQueue\n\tendpoint  *endpoint\n\tspendFn   common.SpendFn\n\trewrite   func(pr *http.Request) (toproxy bool)\n\treqCount  atomic.Int64\n\trespCount atomic.Int64\n\tlastReset atomic.Int64\n}\n\n// ResetCounters resets reqCount, respCount, and lastReset for daily reset.\nfunc (t *LoggingTransport) ResetCounters() {\n\tt.reqCount.Store(0)\n\tt.respCount.Store(0)\n\tt.lastReset.Store(time.Now().Unix())\n}\n\ntype HeaderLog struct {\n\tKey string `json:\"key\"`\n\tVal string `json:\"val\"`\n}\n\nfunc ToHeaderLogs(hdrs http.Header, apiVersion, dst string, code, chunk, priority, estCost int, ttfb, latency time.Duration) (hl []HeaderLog) {\n\tif code > 0 {\n\t\thl = make([]HeaderLog, 0, len(hdrs)+8)\n\t\thl = append(hl, HeaderLog{Key: \"Status\", Val: strconv.Itoa(code)})\n\t} else {\n\t\thl = make([]HeaderLog, 0, len(hdrs)+7)\n\t}\n\tif dst != \"\" {\n\t\thl = append(hl, HeaderLog{Key: \"Dst\", Val: dst})\n\t}\n\tif apiVersion != \"\" {\n\t\thl = append(hl, HeaderLog{Key: \"ApiVer\", Val: apiVersion})\n\t}\n\thl = append(hl, HeaderLog{Key: \"Cost\", Val: strconv.Itoa(estCost)})\n\thl = append(hl, HeaderLog{Key: \"Chunk\", Val: strconv.Itoa(chunk)})\n\thl = append(hl, HeaderLog{Key: \"Priority\", Val: strconv.Itoa(priority)})\n\thl = append(hl, HeaderLog{Key: \"TTFB\", Val: strconv.Itoa(int(ttfb.Milliseconds()))})\n\thl = append(hl, HeaderLog{Key: \"LAT\", Val: strconv.Itoa(int(latency.Milliseconds()))})\n\n\tfor k, vs := range hdrs {\n\t\tif lh := strings.ToLower(k); lh == \"authorization\" || lh == \"api-key\" || lh == \"x-forward-key\" {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, v := range vs {\n\t\t\thl = append(hl, HeaderLog{Key: k, Val: v})\n\t\t}\n\t}\n\treturn hl\n}\n\nfunc LogCheckBanword(body string, banwords []*regexp.Regexp) error {\n\tfor _, ban := range banwords {\n\t\tif i := ban.FindStringIndex(body); i != nil {\n\t\t\treturn fmt.Errorf(\"forbidden word %q at index %d\", ban, i[0])\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc chunks(in string, n int) (out []string) {\n\tfor len(in) > n {\n\t\tout = append(out, in[:n])\n\t\tin = in[n:]\n\t}\n\tout = append(out, in)\n\treturn\n}\n\nvar (\n\tttfbHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"ttfb_seconds\",\n\t\tHelp:    \"Time to first byte of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tttfbHistogramProxy = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"proxy_ttfb_seconds\",\n\t\tHelp:    \"Time to first byte of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tlatencyHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"duration_seconds\",\n\t\tHelp:    \"Latency of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tlatencyHistogramProxy = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"proxy_duration_seconds\",\n\t\tHelp:    \"Latency of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tcostGuage = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"est_costs\",\n\t\tHelp: \"Estimated costs of azure. 100,000,000 is $1\",\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tsuccessRateGauge = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"success_rates\",\n\t\tHelp: \"Rate of successful requests\",\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tendpointStatusGauge = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"endpoint_status\",\n\t\tHelp: \"endpoint status\",\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tendpointThresholdGauge = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"endpoint_threshold\",\n\t\tHelp: \"endpoint threshold\",\n\t}, []string{\"svc\", \"name\"})\n)\n\nfunc (t *LoggingTransport) RoundTrip(req *http.Request) (resp *http.Response, err error) {\n\tif req.ContentLength > 67108864 { // 64MB\n\t\treq.Body.Close()\n\t\tmsg := \"request body too large\"\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\treturn &http.Response{\n\t\t\tStatusCode:    http.StatusBadRequest,\n\t\t\tBody:          io.NopCloser(strings.NewReader(msg)),\n\t\t\tContentLength: int64(len(msg)),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}, nil\n\t}\n\n\tapiVersion := req.URL.Query().Get(\"api-version\")\n\n\ttoproxy := t.rewrite(req)\n\n\tvar priority int\n\tvar logger *slog.Logger\n\tvar banwords []*regexp.Regexp\n\tvar domain string\n\tif cv := req.Context().Value(\"lc\"); cv != nil {\n\t\tlc := cv.(*common.LoggingContext)\n\t\tpriority = lc.Priority\n\t\tbanwords = lc.Banwords\n\t\tdomain = lc.Domain\n\t\tlogger = t.logger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", req.Header.Get(\"X-Request-ID\"))\n\t} else {\n\t\tlogger = slog.New(slog.NewJSONHandler(io.Discard, nil))\n\t}\n\n\treqbuf := buffers.Get().(*bytes.Buffer)\n\tdefer func() {\n\t\treqbuf.Reset()\n\t\tbuffers.Put(reqbuf)\n\t}()\n\n\tif req.Body != nil && !t.endpoint.config.noreqlog {\n\t\t_, err = io.Copy(reqbuf, req.Body)\n\t\treq.Body.Close()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treqbytes := reqbuf.Bytes()\n\treqcontent := *(*string)(unsafe.Pointer(&reqbytes))\n\treqchunks := chunks(reqcontent, 4000000)\n\n\tdst := t.endpoint.config.labels[len(t.endpoint.config.labels)-1]\n\n\tif err = LogCheckBanword(reqcontent, banwords); err != nil {\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\tif !common.IsAirgappedDomain(domain) {\n\t\t\tfor c, chunk := range reqchunks {\n\t\t\t\tlogger.Info(req.URL.Path, \"req\", chunk, \"hdrs\", ToHeaderLogs(req.Header, apiVersion, dst, 0, c, priority, 0, 0, 0), \"ia\", err.Error())\n\t\t\t}\n\t\t\tlogger.Info(req.URL.Path, \"resp\", err.Error(), \"hdrs\", ToHeaderLogs(header, apiVersion, dst, http.StatusForbidden, 0, priority, 0, 0, 0))\n\t\t}\n\t\treturn &http.Response{\n\t\t\tStatusCode:    http.StatusForbidden,\n\t\t\tBody:          io.NopCloser(strings.NewReader(err.Error())),\n\t\t\tContentLength: int64(len(err.Error())),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}, nil\n\t}\n\tlc, ok := req.Context().Value(\"lc\").(*common.LoggingContext)\n\tif !ok || lc == nil {\n\t\treturn nil, errors.New(\"invalid logging context: not *common.LoggingContext\")\n\t}\n\tif lc.UID == nil {\n\t\treturn nil, errors.New(\"missing UID in logging context\")\n\t}\n\tuser := *lc.UID\n\testimate, remain, err := t.spendFn.Pre(user, domain, req, reqcontent)\n\n\treqSeq := t.reqCount.Add(1)\n\tfor c, chunk := range reqchunks {\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"req\", chunk,\n\t\t\t\"hdrs\", ToHeaderLogs(req.Header, apiVersion, dst, 0, c, priority, estimate, 0, 0),\n\t\t\t\"req_seq\", reqSeq,\n\t\t)\n\t}\n\n\tif err != nil {\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\trespSeq := t.respCount.Add(1)\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"resp\", err.Error(),\n\t\t\t\"hdrs\", ToHeaderLogs(header, apiVersion, dst, http.StatusInternalServerError, 0, priority, -1*estimate, 0, 0),\n\t\t\t\"resp_seq\", respSeq,\n\t\t\t\"rel_req_seq\", reqSeq,\n\t\t)\n\t\tif err == ErrTokenLimit {\n\t\t\treturn &http.Response{\n\t\t\t\tStatusCode:    http.StatusBadRequest,\n\t\t\t\tBody:          io.NopCloser(strings.NewReader(err.Error())),\n\t\t\t\tContentLength: int64(len(err.Error())),\n\t\t\t\tHeader:        header,\n\t\t\t\tRequest:       req,\n\t\t\t\tProto:         req.Proto,\n\t\t\t}, nil\n\t\t}\n\t\treturn &http.Response{\n\t\t\tStatusCode:    http.StatusInternalServerError,\n\t\t\tBody:          io.NopCloser(strings.NewReader(err.Error())),\n\t\t\tContentLength: int64(len(err.Error())),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}, nil\n\t}\n\n\tif remain < 0 {\n\t\tmsg := \"your daily quota is exhausted, please contact your admin if you want more quota\"\n\t\tif se := os.Getenv(\"SUPPORT_EMAIL\"); len(se) > 0 {\n\t\t\tmsg = fmt.Sprintf(\"your daily quota is exhausted, please contact %s if you want more quota\", se)\n\t\t}\n\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\trespSeq := t.respCount.Add(1)\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"resp\", msg,\n\t\t\t\"hdrs\", ToHeaderLogs(header, apiVersion, dst, http.StatusForbidden, 0, priority, -1*estimate, 0, 0),\n\t\t\t\"resp_seq\", respSeq,\n\t\t\t\"rel_req_seq\", reqSeq,\n\t\t)\n\t\tresp := &http.Response{\n\t\t\tStatusCode:    http.StatusForbidden,\n\t\t\tBody:          io.NopCloser(strings.NewReader(msg)),\n\t\t\tContentLength: int64(len(msg)),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}\n\t\tt.spendFn.Post(user, resp, \"\", estimate)\n\n\t\tif t.spendFn.Alert != nil {\n\t\t\tgo t.spendFn.Alert(user, logger)\n\t\t}\n\t\treturn resp, nil\n\t}\n\n\tif !t.endpoint.config.noreqlog {\n\t\treq.Body = io.NopCloser(bytes.NewReader(reqbytes))\n\t}\n\n\tt1 := time.Now()\n\tcostGuage.WithLabelValues(t.endpoint.config.labels...).Add(float64(estimate))\n\n\t// avoid azure returning HTTP 413 header too large\n\treq.Header.Del(\"X-Asst-Desc\")\n\treq.Header.Del(\"X-Asst-Id\")\n\treq.Header.Del(\"X-Asst-Name\")\n\treq.Header.Del(\"X-Thread-Id\")\n\treq.Header.Del(\"X-Stainless-Package-Version\")\n\treq.Header.Del(\"X-Stainless-Lang\")\n\treq.Header.Del(\"X-Stainless-Os\")\n\treq.Header.Del(\"X-Stainless-Runtime\")\n\treq.Header.Del(\"X-Stainless-Arch\")\n\n\tif resp, err = t.Transport.RoundTrip(req); err == nil {\n\t\tttfb := time.Since(t1)\n\t\tif toproxy {\n\t\t\tttfbHistogramProxy.WithLabelValues(t.endpoint.config.labels...).Observe(float64(ttfb.Microseconds() / 1e6))\n\t\t} else {\n\t\t\tttfbHistogram.WithLabelValues(t.endpoint.config.labels...).Observe(float64(ttfb.Microseconds() / 1e6))\n\t\t}\n\n\t\tt.endpoint.recordStatus(resp, ttfb, logger)\n\n\t\treqPath := req.URL.Path\n\t\tresp.Body = NewTeeBufReader(resp.Body, func(b string) {\n\t\t\tfullLatency := time.Since(t1)\n\t\t\tif toproxy {\n\t\t\t\tlatencyHistogramProxy.WithLabelValues(t.endpoint.config.labels...).Observe(float64(fullLatency.Microseconds() / 1e6))\n\t\t\t} else {\n\t\t\t\tlatencyHistogram.WithLabelValues(t.endpoint.config.labels...).Observe(float64(fullLatency.Microseconds() / 1e6))\n\t\t\t}\n\n\t\t\t// Check if the response data is in gzip format\n\t\t\tisGzip := false\n\t\t\tif len(b) > 2 && b[0] == 0x1f && b[1] == 0x8b {\n\t\t\t\tisGzip = true\n\t\t\t}\n\n\t\t\tif isGzip {\n\t\t\t\t// Attempt to decode gzip data\n\t\t\t\treader := bytes.NewReader([]byte(b))\n\t\t\t\tgzipReader, err := gzip.NewReader(reader)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(\"Failed to create gzip reader:\", err)\n\t\t\t\t} else {\n\t\t\t\t\tdecompressedData, err := io.ReadAll(gzipReader)\n\t\t\t\t\tgzipReader.Close()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogger.Error(\"Failed to decompress gzip data:\", err)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = string(decompressedData)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trespchunks := chunks(b, 4000000)\n\t\t\testimate = t.spendFn.Post(user, resp, b, estimate)\n\t\t\tcostGuage.WithLabelValues(t.endpoint.config.labels...).Add(float64(estimate))\n\n\t\t\trespSeq := t.respCount.Add(1)\n\t\t\tfor c, chunk := range respchunks {\n\t\t\t\tlogger.Info(reqPath,\n\t\t\t\t\t\"resp\", chunk,\n\t\t\t\t\t\"hdrs\", ToHeaderLogs(resp.Header, apiVersion, dst, resp.StatusCode, c, priority, estimate, ttfb, fullLatency),\n\t\t\t\t\t\"resp_seq\", respSeq,\n\t\t\t\t\t\"rel_req_seq\", reqSeq,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\tif op := resp.Header.Get(\"Operation-Location\"); op != \"\" {\n\t\t\tif purl, err := url.Parse(op); err == nil {\n\t\t\t\tif envstr(\"DOMAIN_CHECK\", \"oa\") == \"oa\" {\n\t\t\t\t\tpurl.Host = \"gitea.mediatek.inc/davinci/azure-gateway.mediatek.inc\"\n\t\t\t\t} else {\n\t\t\t\t\tpurl.Host = \"mlop-azure-rddmz.mediatek.inc\"\n\t\t\t\t}\n\t\t\t\tresp.Header.Set(\"Operation-Location\", purl.String())\n\t\t\t}\n\t\t}\n\t} else {\n\t\tt.endpoint.recordStatus(nil, 0, logger)\n\t\tttfb := time.Since(t1)\n\t\theader := http.Header{}\n\t\trespSeq := t.respCount.Add(1)\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"resp\", err.Error(),\n\t\t\t\"hdrs\", ToHeaderLogs(header, apiVersion, dst, 500, 0, priority, -1*estimate, ttfb, ttfb),\n\t\t\t\"resp_seq\", respSeq,\n\t\t\t\"rel_req_seq\", reqSeq,\n\t\t)\n\t\tt.spendFn.Post(user, resp, \"\", estimate)\n\t}\n\n\tif t.endpoint.config.ptu && resp != nil && (resp.StatusCode == 429 || resp.StatusCode == 500 || resp.StatusCode == 502) {\n\t\tvar condidate *endpoint\n\t\tretry, _ := strconv.ParseInt(req.Header.Get(\"X-PTU-RETRY\"), 10, 64)\n\t\tretry++\n\t\treq.Header.Set(\"X-PTU-RETRY\", strconv.FormatInt(retry, 10))\n\t\tif retry <= 2 {\n\t\t\tif after, _ := strconv.ParseInt(resp.Header.Get(\"Retry-After-Ms\"), 10, 64); after <= 1500 {\n\t\t\t\tif after == 0 {\n\t\t\t\t\tafter = 500\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * time.Duration(after))\n\t\t\t\tcondidate = t.endpoint\n\t\t\t\tgoto RETRY\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tallOthers := t.endpoint.othersFn()\n\t\t\tcondidates := make([]*endpoint, 0, len(allOthers))\n\t\t\tfor _, e := range allOthers {\n\t\t\t\tif e == t.endpoint {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif e.isOnline() {\n\t\t\t\t\tcondidates = append(condidates, e)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(condidates) > 0 {\n\t\t\t\tcondidate = condidates[rand.Intn(len(condidates))]\n\t\t\t}\n\t\t}\n\tRETRY:\n\t\tif condidate != nil && condidate.proxy.Transport != nil {\n\t\t\tio.ReadAll(resp.Body)\n\t\t\tresp.Body.Close()\n\t\t\treq.Body = io.NopCloser(bytes.NewReader(reqbytes))\n\t\t\tresp, err = condidate.proxy.Transport.RoundTrip(req)\n\t\t}\n\t}\n\n\treturn resp, err\n}\n\ntype InListResp struct {\n\tIn     bool   `json:\"in\"`\n\tReason string `json:\"reason\"`\n}\n\nfunc (p InListResp) ToString() string {\n\tbs, _ := json.Marshal(p)\n\treturn *(*string)(unsafe.Pointer(&bs))\n}\n\ntype InListReq struct {\n\tUid  string `json:\"uid\"`\n\tList string `json:\"list\"`\n}\n\nfunc (p InListReq) ToString() string {\n\tbs, _ := json.Marshal(p)\n\treturn *(*string)(unsafe.Pointer(&bs))\n}\n\ntype endpoint struct {\n\tconfig   endpointconfig\n\tproxy    *httputil.ReverseProxy\n\tothersFn func() []*endpoint\n\tsuccess  uint64\n\ttotal    uint64\n\tdisable  int32\n}\n\nfunc (e *endpoint) isOnline() bool {\n\treturn atomic.LoadInt32(&e.disable) == 0\n}\n\nfunc (e *endpoint) online() {\n\tatomic.CompareAndSwapInt32(&e.disable, 1, 0)\n}\n\nfunc (e *endpoint) offline() bool {\n\tt := atomic.CompareAndSwapInt32(&e.disable, 0, 1)\n\tif t {\n\t\te.reset()\n\t}\n\treturn t\n}\n\nfunc (e *endpoint) reset() {\n\tatomic.StoreUint64(&e.success, 1)\n\tatomic.StoreUint64(&e.total, 1)\n}\n\nfunc (e *endpoint) recordStatus(resp *http.Response, ttfb time.Duration, logger *slog.Logger) (rate float64) {\n\tif logger != nil {\n\t\tlogger = logger.With(\"rqid\", uuid.New().String())\n\t}\n\tif e.othersFn == nil {\n\t\treturn\n\t}\n\tif e.config.judgeFn == nil || (resp != nil && e.config.judgeFn(resp, ttfb)) {\n\t\tatomic.AddUint64(&e.success, 1)\n\t\tif atomic.AddUint64(&e.total, 1) == 61 {\n\t\t\te.reset()\n\t\t}\n\t} else {\n\t\tatomic.AddUint64(&e.total, 1)\n\t}\n\n\ttotal := uint64(0)\n\tsuccess := uint64(0)\n\tendpoints := e.othersFn()\n\trates := make([]float64, 0, len(endpoints))\n\n\tj := 0\n\tfor _, oe := range endpoints {\n\t\tif !oe.isOnline() && oe != e {\n\t\t\tcontinue\n\t\t}\n\t\tptotal := atomic.LoadUint64(&oe.total)\n\t\tpsuccess := atomic.LoadUint64(&oe.success)\n\t\tif ptotal < psuccess {\n\t\t\tptotal = psuccess\n\t\t}\n\t\ttotal += ptotal\n\t\tsuccess += psuccess\n\t\trates = append(rates, float64(psuccess)/float64(ptotal))\n\t\tif oe == e {\n\t\t\tj = len(rates) - 1\n\t\t}\n\t}\n\tif total == 0 {\n\t\treturn\n\t}\n\n\tmean := float64(success) / float64(total)\n\tstdv := float64(0)\n\tfor _, r := range rates {\n\t\tstdv += math.Pow((r - mean), 2)\n\t}\n\tstdv = math.Sqrt(stdv / float64(len(rates)))\n\tthreshold := mean - 1.9*stdv\n\tif threshold > 0.9 {\n\t\tthreshold = 0.9\n\t}\n\tendpointThresholdGauge.WithLabelValues(e.config.labels[:2]...).Set(threshold)\n\n\tif (!e.config.ptu && rates[j] < threshold) && e.config.testReqFn != nil && e.offline() {\n\t\tvar header http.Header\n\t\tvar statusCode int\n\t\tif resp != nil {\n\t\t\theader = resp.Header\n\t\t\tstatusCode = resp.StatusCode\n\t\t}\n\t\tlogger.Info(\"endpoint_off\", \"req\", e.config.labels, \"hdrs\", ToHeaderLogs(header, \"\", \"\", statusCode, 0, 0, 0, 0, 0))\n\t\tgo func(threshold float64, testReqFn func() *http.Request) {\n\t\t\tfor i := 0; ; i++ {\n\t\t\t\tres := httptest.NewRecorder()\n\t\t\t\te.proxy.ServeHTTP(res, testReqFn())\n\t\t\t\tresp := res.Result()\n\t\t\t\tio.ReadAll(resp.Body)\n\t\t\t\tresp.Body.Close()\n\t\t\t\tptotal := atomic.LoadUint64(&e.total)\n\t\t\t\tpsuccess := atomic.LoadUint64(&e.success)\n\t\t\t\tif ptotal < psuccess {\n\t\t\t\t\tptotal = psuccess\n\t\t\t\t}\n\t\t\t\trate := float64(psuccess) / float64(ptotal)\n\t\t\t\tif rate > threshold {\n\t\t\t\t\te.online()\n\t\t\t\t\tlogger.Info(\"endpoint_on\", \"req\", e.config.labels, \"hdrs\", ToHeaderLogs(resp.Header, \"\", \"\", resp.StatusCode, i, 0, 0, 0, 0))\n\t\t\t\t\tsuccessRateGauge.WithLabelValues(e.config.labels...).Set(rate)\n\t\t\t\t\tendpointStatusGauge.WithLabelValues(e.config.labels...).Set(1)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t}\n\t\t}(threshold, e.config.testReqFn)\n\t}\n\n\tif e.config.judgeFn != nil {\n\t\tsuccessRateGauge.WithLabelValues(e.config.labels...).Set(rates[j])\n\t\tif e.isOnline() {\n\t\t\tendpointStatusGauge.WithLabelValues(e.config.labels...).Set(1)\n\t\t} else {\n\t\t\tendpointStatusGauge.WithLabelValues(e.config.labels...).Set(0)\n\t\t}\n\t}\n\treturn rate\n}\n\ntype dispatcher struct {\n\tonline   []*endpoint\n\tfallback *endpoint\n\tweight   int\n}\n\nfunc (d *dispatcher) pick(req *http.Request) *endpoint {\n\tif len(d.online) == 0 {\n\t\treturn d.fallback\n\t}\n\n\tlc, ok := req.Context().Value(\"lc\").(*common.LoggingContext)\n\tvar user string\n\tif !ok || lc == nil {\n\t\tpanic(\"invalid logging context: not *common.LoggingContext\")\n\t}\n\tif lc.UID != nil {\n\t\tuser = *lc.UID\n\t}\n\n\tif dst := req.Header.Get(\"X-DST\"); dst != \"\" {\n\t\tfor _, e := range d.online {\n\t\t\tif strings.Contains(e.config.url, dst) {\n\t\t\t\treturn e\n\t\t\t}\n\t\t}\n\t}\n\n\tc := 0\n\tw := rand.Intn(d.weight)\n\n\tfor _, e := range d.online {\n\t\tif e.config.ptu {\n\t\t\tif len(ptuVIPs) == 0 || ptuVIPs[user] {\n\t\t\t\treturn e\n\t\t\t}\n\t\t\tif e.isOnline() {\n\t\t\t\treturn e\n\t\t\t}\n\t\t}\n\t\tif c += e.config.weight; w < c {\n\t\t\tif !e.isOnline() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn e\n\t\t}\n\t}\n\n\treturn d.fallback\n}\n\nfunc (d *dispatcher) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\t// Check if request context is cancelled before proceeding\n\tselect {\n\tcase <-req.Context().Done():\n\t\t// Context cancelled - likely client disconnection\n\t\tlogger.Warn(\"Request context cancelled in dispatcher\",\n\t\t\t\"path\", req.URL.Path,\n\t\t\t\"error\", req.Context().Err(),\n\t\t\t\"method\", req.Method)\n\t\treturn\n\tdefault:\n\t\t// Context is still active, proceed\n\t}\n\n\tendpoint := d.pick(req)\n\tif endpoint == nil || endpoint.proxy == nil {\n\t\thttp.Error(rw, \"Service temporarily unavailable\", http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\n\t// Log the proxy handoff for debugging\n\tlogger.Debug(\"Dispatcher forwarding to endpoint\",\n\t\t\"path\", req.URL.Path,\n\t\t\"endpoint\", endpoint.config.labels)\n\n\t// Check once more before calling the reverse proxy\n\tselect {\n\tcase <-req.Context().Done():\n\t\tlogger.Warn(\"Request context cancelled just before proxy\",\n\t\t\t\"path\", req.URL.Path,\n\t\t\t\"error\", req.Context().Err())\n\t\treturn\n\tdefault:\n\t\tendpoint.proxy.ServeHTTP(rw, req)\n\t}\n}\n\nvar (\n\tproxyUsers map[string]bool\n\tptuVIPs    map[string]bool\n)\n\nfunc init() {\n\tbuffers = sync.Pool{New: func() any { return bytes.NewBuffer(make([]byte, 0, 4096)) }}\n\tproxyUsers = make(map[string]bool, 20)\n\tfor _, u := range strings.Split(os.Getenv(\"PROXY_USERS\"), \",\") {\n\t\tif u = strings.TrimSpace(u); u != \"\" {\n\t\t\tproxyUsers[strings.ToLower(u)] = true\n\t\t\tproxyUsers[strings.ToUpper(u)] = true\n\t\t}\n\t}\n\tptuVIPs = make(map[string]bool, 20)\n\tfor _, u := range strings.Split(os.Getenv(\"PTU_VIPS\"), \",\") {\n\t\tif u = strings.TrimSpace(u); u != \"\" {\n\t\t\tptuVIPs[strings.ToLower(u)] = true\n\t\t\tptuVIPs[strings.ToUpper(u)] = true\n\t\t}\n\t}\n}\n\nvar globalDailyResetController = dailyreset.New()\n\nfunc NewEndpoint(ctx context.Context, useproxy bool, config endpointconfig, tr http.RoundTripper, logger *slog.Logger, spendfn common.SpendFn) *endpoint {\n\tvar proxy, proxyKey string\n\tif useproxy {\n\t\tproxy = envstr(\"AZURE_PROXY_IP\", \"\")\n\t\tproxyKey = envstr(\"AZURE_PROXY_KEY\", envmust(\"JWT_SECRET_KEY\"))\n\t}\n\n\tdst := URL(config.url)\n\te := &endpoint{config: config, total: 1, success: 1}\n\te.proxy = httputil.NewSingleHostReverseProxy(dst)\n\ttransport := &LoggingTransport{\n\t\tTransport: tr,\n\t\tlogger:    logger,\n\t\tqueue:     rq.NewRequestQueue(),\n\t\tspendFn:   spendfn,\n\t\tendpoint:  e,\n\t\trewrite: func(pr *http.Request) (toproxy bool) {\n\t\t\tif proxy != \"\" {\n\t\t\t\tpr.Header.Set(\"X-Forward-To\", fmt.Sprintf(\"%s://%s\", dst.Scheme, dst.Host))\n\t\t\t\tpr.Header.Set(\"X-Forward-Key\", proxyKey)\n\t\t\t\tpr.URL.Scheme = \"http\"\n\t\t\t\tpr.URL.Host = proxy\n\t\t\t\tpr.Host = proxy\n\t\t\t\ttoproxy = true\n\t\t\t} else {\n\t\t\t\tpr.Header.Del(\"X-Forward-To\")\n\t\t\t\tpr.Header.Del(\"X-Forward-Key\")\n\t\t\t\tpr.URL.Scheme = dst.Scheme\n\t\t\t\tpr.URL.Host = dst.Host\n\t\t\t\tpr.Host = dst.Host\n\t\t\t\ttoproxy = false\n\t\t\t}\n\t\t\tpr.Header.Del(\"Authorization\")\n\t\t\tpr.Header.Del(\"api-key\")\n\t\t\tfor k, v := range config.hdrs {\n\t\t\t\tpr.Header.Set(k, v)\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t}\n\n\t// Initialize lastReset with current time\n\ttransport.lastReset.Store(time.Now().Unix())\n\tglobalDailyResetController.Register(transport)\n\n\te.proxy.Transport = transport\n\treturn e\n}\n\nfunc NewDaviciShareServerFunc(storeApiUrl, davinciUrl string) func(*gin.Context) {\n\tp := httputil.NewSingleHostReverseProxy(URL(storeApiUrl))\n\treturn func(c *gin.Context) {\n\t\tc.Request.Header.Set(\"X-Mail-Url\", davinciUrl)\n\t\tc.Request.URL.Path = \"/api/share/shareChat\"\n\t\tp.ServeHTTP(c.Writer, c.Request)\n\t}\n}\n\ntype endpointconfig struct {\n\tweight   int\n\turl      string\n\thdrs     map[string]string\n\tnoreqlog bool\n\tptu      bool\n\tlabels   []string\n\n\tjudgeFn   func(resp *http.Response, ttfb time.Duration) bool\n\ttestReqFn func() *http.Request\n}\n\nfunc NewDispatcher(tr http.RoundTripper, logger *slog.Logger, useproxy bool, spendfn common.SpendFn, configs []endpointconfig) *dispatcher {\n\td := &dispatcher{\n\t\tonline: make([]*endpoint, 0, len(configs)),\n\t}\n\tif len(configs) == 0 {\n\t\treturn d\n\t}\n\tfor _, c := range configs {\n\t\td.online = append(d.online, NewEndpoint(context.Background(), useproxy, c, tr, logger, spendfn))\n\t\td.weight += c.weight\n\t}\n\tfor _, e := range d.online {\n\t\te.othersFn = func() []*endpoint {\n\t\t\treturn d.online\n\t\t}\n\t}\n\td.fallback = d.online[len(d.online)-1]\n\treturn d\n}\n\n// aoaiWithKey initializes an endpoint configuration for Azure OpenAI API calls.\n// It constructs the configuration based on the provided parameters and the model type.\n//\n// If the url parameter is non-empty, the function uses it directly with an \"Authorization\" header.\n// Otherwise, it builds a base URL from the name and configures headers with the provided API key.\n//\n// For models containing \"dalle\" (case-insensitive), it returns a configuration with an \"api-key\" header\n// without setting any deadline or special performance testing behavior.\n//\n// For other models, it sets a default deadline of 60 seconds, but extends it to 150 seconds for models\n// ending with \"32k\", \"16k\", or containing \"gpt-4\". It also determines if the special \"ptu\" mode should\n// be enabled when name equals \"aideopenaijapaneast\" and model equals \"aide-gpt-4o\".\n//\n// In ptu mode, the function sets a judge function that always returns true and defines\n// a specific test request targeting the chat completions endpoint.\n// For general cases, a judge function is defined to check that the response status is neither 429 nor\n// in the 500 range, and that the time-to-first-byte (ttfb) is below the set deadline.\n// The test request function is adjusted based on the model (e.g., using \"completions\" for some models,\n// \"embeddings\" for others, or \"chat/completions\" by default).\n//\n// Parameters:\n//\n//\tweight int:\n//\t  The traffic weight assigned to this endpoint.\n//\tname string:\n//\t  The identifier used to construct the base URL if no override URL is provided.\n//\tmodel string:\n//\t  The model variant which affects headers, deadline configuration, and endpoint path.\n//\tkey string:\n//\t  The API key used either as an \"api-key\" or \"Authorization\" header depending on the scenario.\n//\turl string:\n//\t  An optional URL override; if provided, it bypasses the base URL construction.\n//\n// Returns:\n//\n//\tendpointconfig:\n//\t  A structure encompassing the endpoint URL, HTTP headers, associated labels, and the functions\n//\t  (judgeFn and testReqFn) used for response validation and test request generation.\nfunc aoaiWithKey(weight int, name, model, key, url string) endpointconfig {\n\tif url != \"\" {\n\t\treturn endpointconfig{\n\t\t\tweight: weight,\n\t\t\turl:    url,\n\t\t\thdrs:   map[string]string{\"Authorization\": key},\n\t\t\tlabels: []string{\"azure\", model, name},\n\t\t}\n\t}\n\n\tbaseURL := fmt.Sprintf(\"https://%s.openai.azure.com\", name)\n\n\t// If the model contains \"dalle\", no additional deadline or ptu configuration is needed\n\tif strings.Contains(strings.ToLower(model), \"dalle\") {\n\t\treturn endpointconfig{\n\t\t\tweight: weight,\n\t\t\turl:    baseURL,\n\t\t\thdrs:   map[string]string{\"api-key\": key},\n\t\t\tlabels: []string{\"aoai\", model, name},\n\t\t}\n\t}\n\n\t// Set deadline\n\tdeadline := time.Second * 60\n\tif strings.HasSuffix(model, \"32k\") || strings.HasSuffix(model, \"16k\") || strings.Contains(model, \"gpt-4\") {\n\t\tdeadline = time.Second * 150\n\t}\n\n\tptu := name == \"aideopenaijapaneast\" && (model == \"aide-gpt-4.1\")\n\n\t// Create a common configuration\n\tcfg := endpointconfig{\n\t\tptu:    ptu,\n\t\tweight: weight,\n\t\turl:    baseURL,\n\t\thdrs:   map[string]string{\"api-key\": key},\n\t\tlabels: []string{\"aoai\", model, name},\n\t}\n\n\t// If ptu is true, set judgeFn to always return true\n\tif ptu {\n\t\tcfg.judgeFn = func(resp *http.Response, ttfb time.Duration) bool {\n\t\t\treturn true\n\t\t}\n\t\tcfg.testReqFn = func() *http.Request {\n\t\t\tpayload := strings.NewReader(`{\"messages\":[{\"role\": \"user\",\"content\": \"Hi\"}]}`)\n\t\t\treq, err := http.NewRequest(http.MethodPost, fmt.Sprintf(\"%s/openai/deployments/%s/chat/completions?api-version=2024-02-01\", baseURL, model), payload)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\treq.Header.Set(\"api-key\", key)\n\t\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\t\treturn req\n\t\t}\n\t\treturn cfg\n\t}\n\n\t// Define default judgeFn and testReqFn for normal cases\n\tcfg.judgeFn = func(resp *http.Response, ttfb time.Duration) bool {\n\t\treturn resp.StatusCode != 429 && resp.StatusCode < 500 && ttfb < deadline\n\t}\n\tcfg.testReqFn = func() *http.Request {\n\t\tendpoint := \"chat/completions\"\n\t\tpayload := strings.NewReader(`{\"messages\":[{\"role\": \"user\",\"content\": \"Hi\"}]}`)\n\t\tif model == \"aide-davinci-003\" || model == \"aide-code-davinci-002\" {\n\t\t\tendpoint = \"completions\"\n\t\t\tpayload = strings.NewReader(`{\"prompt\": \"Hi\"}`)\n\t\t} else if strings.Contains(model, \"embedding\") {\n\t\t\tendpoint = \"embeddings\"\n\t\t\tpayload = strings.NewReader(`{\"input\": [\"Hi\"]}`)\n\t\t}\n\t\treq, err := http.NewRequest(http.MethodPost, fmt.Sprintf(\"%s/openai/deployments/%s/%s?api-version=2024-02-01\", baseURL, model, endpoint), payload)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treq.Header.Set(\"api-key\", key)\n\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\treturn req\n\t}\n\n\treturn cfg\n}\n\nfunc aoai(weight int, name, model string) endpointconfig {\n\treturn aoaiWithKey(weight, name, model, envmust(\"AZURE_OPAI_KEY_\"+name), \"\")\n}\n\nfunc aoaiNoReqLog(weight int, name, model string) endpointconfig {\n\tconfig := aoaiWithKey(weight, name, model, envmust(\"AZURE_OPAI_KEY_\"+name), \"\")\n\tconfig.noreqlog = true\n\treturn config\n}\n\nvar (\n\tErrTokenLimit        = errors.New(\"your input exceeds the token limit\")\n\tVisionStreamDisabled = errors.New(\"streaming gpt-4-turbo-vision responses is disabled\")\n\tVisionNotAllowed     = errors.New(\"you are not allowed to use gpt-4-turbo-vision\")\n\tGPT4NotAllowed       = errors.New(\"you are not allowed to use gpt-4\")\n\tDomainNotAllowed     = errors.New(\"you are not allowed to use the model in this domain\")\n)\n\ntype Message struct {\n\tRole    string          `json:\"role\"`\n\tContent json.RawMessage `json:\"content\"`\n}\n\ntype MessageContent struct {\n\tType string `json:\"type\"`\n\tText string `json:\"text\"`\n}\n\nfunc (m Message) HasImages() bool {\n\tvar content []MessageContent\n\tif json.Unmarshal(m.Content, &content) == nil {\n\t\tfor _, c := range content {\n\t\t\tif c.Type == \"image_url\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (m Message) SplitImageMessages() (Message, int) {\n\tif !m.HasImages() {\n\t\treturn m, 0\n\t}\n\tvar oldContents, newContents []MessageContent\n\timageCount := 0\n\tif json.Unmarshal(m.Content, &oldContents) == nil {\n\t\tfor _, c := range oldContents {\n\t\t\tif c.Type == \"image_url\" {\n\t\t\t\timageCount++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewContents = append(newContents, c)\n\t\t}\n\t}\n\tvar newMessage Message\n\tnewMessage.Role = m.Role\n\tnewMessage.Content, _ = json.Marshal(newContents)\n\n\treturn newMessage, imageCount\n}\n\ntype streambody struct {\n\tStream   bool      `json:\"stream\"`\n\tMessages []Message `json:\"messages\"`\n}\n\nfunc (sb streambody) CountToken(encoder *tiktoken.Tiktoken, fallbackTokens int) int {\n\thasImages := false\n\tfor _, m := range sb.Messages {\n\t\tif m.HasImages() {\n\t\t\thasImages = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !hasImages {\n\t\tbody, err := json.Marshal(sb)\n\t\tif err != nil {\n\t\t\treturn fallbackTokens\n\t\t}\n\t\treturn len(encoder.Encode(string(body), nil, nil))\n\t}\n\n\ttotalImageCount := 0\n\tvar textContents []Message\n\tfor _, m := range sb.Messages {\n\t\tif m.HasImages() {\n\t\t\ttextContent, imageCount := m.SplitImageMessages()\n\t\t\ttextContents = append(textContents, textContent)\n\t\t\ttotalImageCount += imageCount\n\t\t} else {\n\t\t\ttextContents = append(textContents, m)\n\t\t}\n\t}\n\n\ttextBody, err := json.Marshal(textContents)\n\tif err != nil {\n\t\treturn fallbackTokens\n\t}\n\ttextToken := len(encoder.Encode(string(textBody), nil, nil))\n\t// https://learn.microsoft.com/en-us/azure/ai-services/openai/overview#image-tokens-gpt-4-turbo-with-vision\n\t// max image token = 170 * 8 + 85 = 1445\n\timageToken := 1445 * totalImageCount\n\n\treturn textToken + imageToken\n}\n\nfunc aoaiSpend(model string, capgpt4 bool, crowdapi crowdadapter.Adapter, qc quota.QuotaClient, smtpserver string, encoder *tiktoken.Tiktoken, promptrate, completionrate int) common.SpendFn {\n\treturn common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tvar checkCrowd bool\n\t\t\tvar groups []crowdadapter.CrowdGroup\n\t\t\tif _, ok := crowdapi.(*crowdadapter.CrowdAPI); ok {\n\t\t\t\tcheckCrowd = true\n\t\t\t}\n\t\t\tif checkCrowd && (common.IsAirgappedDomain(domain) || common.IsAirgappedDomain(req.Header.Get(\"X-Domain\"))) {\n\t\t\t\tgroups, err = crowdapi.GetUserNestedGroups(req.Context(), user, crowdadapter.DefaultLimit)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, 0, err\n\t\t\t\t}\n\t\t\t\tpermit := false\n\t\t\t\tgroup := \"gaisf_\" + domain + \"_\" + strings.ReplaceAll(model, \"-\", \"_\")\n\t\t\t\tfor _, g := range groups {\n\t\t\t\t\tif g.Name == group {\n\t\t\t\t\t\tpermit = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !permit {\n\t\t\t\t\treturn 0, 0, fmt.Errorf(\"%w: %s\", DomainNotAllowed, group)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar tokens int\n\t\t\tif strings.Contains(model, \"gpt-4o\") || strings.Contains(model, \"gpt-4.1\") || strings.Contains(model, \"vision\") {\n\t\t\t\ttokens = 2000\n\t\t\t\tvar sb streambody\n\t\t\t\tif err := json.Unmarshal([]byte(body), &sb); err != nil {\n\t\t\t\t\treturn 0, 0, err\n\t\t\t\t}\n\t\t\t\ttokens = sb.CountToken(encoder, tokens)\n\t\t\t} else {\n\t\t\t\ttokens = len(encoder.Encode(body, nil, nil))\n\t\t\t}\n\n\t\t\tif checkCrowd && capgpt4 && strings.Contains(model, \"aide-gpt-4\") {\n\t\t\t\tif groups == nil {\n\t\t\t\t\tgroups, err = crowdapi.GetUserNestedGroups(req.Context(), user, crowdadapter.DefaultLimit)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, 0, err\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif model == \"aide-gpt-4-turbo-vision\" {\n\t\t\t\t\tpermit := false\n\t\t\t\t\tif domain == \"oa\" {\n\t\t\t\t\tL3:\n\t\t\t\t\t\tfor _, g := range groups {\n\t\t\t\t\t\t\tswitch g.Name {\n\t\t\t\t\t\t\tcase \"gaisf_io_gpt4_vision\", \"gaisf_oa_gpt4_vision\", \"gaisf_oa_gpt4_turbo_vision\":\n\t\t\t\t\t\t\t\tpermit = true\n\t\t\t\t\t\t\t\tbreak L3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if domain == \"swrd\" {\n\t\t\t\t\tL4:\n\t\t\t\t\t\tfor _, g := range groups {\n\t\t\t\t\t\t\tswitch g.Name {\n\t\t\t\t\t\t\tcase \"gaisf_swrd_gpt4_vision\", \"gaisf_swrd_gpt4_turbo_vision\":\n\t\t\t\t\t\t\t\tpermit = true\n\t\t\t\t\t\t\t\tbreak L4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !permit {\n\t\t\t\t\t\treturn 0, 0, VisionNotAllowed\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens > int(8000*1.1) && (model == \"aide-gpt-4-turbo\")) ||\n\t\t\t\t\t(tokens > int(16000*1.1) && (model == \"aide-gpt-4o\")) ||\n\t\t\t\t\t(tokens > int(16000*1.1) && (model == \"aide-gpt-4o-mini\")) {\n\t\t\t\t\tif !common.CheckTokenLimitPermision(domain, tokens, groups) {\n\t\t\t\t\t\treturn 0, 0, ErrTokenLimit\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\testimate = tokens * promptrate\n\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\treturn\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif resp == nil {\n\t\t\t\testimate = preestimate * -1\n\t\t\t} else if preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\testimate = preestimate * -1\n\t\t\t} else if strings.Contains(resp.Header.Get(\"content-type\"), \"text/event-stream\") {\n\t\t\t\testimate = strings.Count(body, \"\\ndata: {\") * completionrate\n\t\t\t} else {\n\t\t\t\tvar resp AoaiResp\n\t\t\t\tif err := json.Unmarshal([]byte(body), &resp); err == nil {\n\t\t\t\t\tif resp.Usage.PromptTokens > 0 && resp.Usage.CompletionTokens > 0 {\n\t\t\t\t\t\testimate = completionrate*resp.Usage.CompletionTokens + promptrate*resp.Usage.PromptTokens - preestimate\n\t\t\t\t\t} else if resp.Usage.InputTokens > 0 && resp.Usage.OutputTokens > 0 {\n\t\t\t\t\t\testimate = completionrate*resp.Usage.OutputTokens + promptrate*resp.Usage.InputTokens - preestimate\n\t\t\t\t\t} else {\n\t\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif estimate != 0 {\n\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t}\n}\n\n\nfunc enrichCSESHeaders(r *http.Request, domain, proj, tkid string, payload *map[string]any) error {\n\tlc, ok := r.Context().Value(\"lc\").(*common.LoggingContext)\n\tif !ok || lc == nil {\n\t\treturn errors.New(\"invalid logging context: not *common.LoggingContext\")\n\t}\n\tif lc.UID == nil {\n\t\treturn errors.New(\"missing UID in logging context\")\n\t}\n\tuid := *lc.UID\n\tif r.Header.Get(\"X-Domain\") == \"hwrd\" {\n\t\tdomain = \"hwrd\"\n\t}\n\tr.Header.Set(\"grpc-metadata-x-user-proxy-name\", uid)\n\tr.Header.Set(\"grpc-metadata-x-user-name\", uid)\n\tr.Header.Set(\"grpc-metadata-x-user-proxy-domain\", domain)\n\tr.Header.Set(\"grpc-metadata-x-user-domain\", domain)\n\tr.Header.Set(\"grpc-metadata-x-app-name\", proj)\n\tr.Header.Set(\"grpc-metadata-x-task-id\", tkid)\n\n\tif payload != nil {\n\t\tif v, ok := (*payload)[\"project\"]; ok {\n\t\t\tr.Header.Set(\"grpc-metadata-x-project-code\", v.(string))\n\t\t}\n\t}\n\tif code := r.Header.Get(\"X-Project-Code\"); code != \"\" {\n\t\tr.Header.Set(\"grpc-metadata-x-project-code\", code)\n\t}\n\treturn nil\n}\n\n//\t@title\t\t\t\t\t\tGAISF Gateway API\n//\t@version\t\t\t\t\t1.0\n//\t@description\t\t\t\tThis is the API documentation for the GAISF Gateway.\n//\t@BasePath\t\t\t\t\t/v1\n//\t@securityDefinitions.apikey\tBearerAuth\n//\t@in\t\t\t\t\t\t\theader\n//\t@name\t\t\t\t\t\tAuthorization\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tglobalDailyResetController.Start(ctx)\n\tvar envfile string\n\tflag.StringVar(&envfile, \"env-file\", \".env\", \"Read in a file of environment variables\")\n\tflag.Parse()\n\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\n\tif err := godotenv.Load(envfile); err == nil {\n\t\tlogger.Info(\"loading config file\", \"file\", envfile)\n\t}\n\n\tjwtKey := envmust(\"JWT_SECRET_KEY\")\n\tdomain := envstr(\"DOMAIN_CHECK\", \"oa\")\n\t// (permMgr initialization moved later where crowdapi is available)\n\n\tif !common.Domain(domain).IsValid() {\n\t\tpanic(\"DOMAIN_CHECK must be set to an airgapped domain\")\n\t}\n\n\tuserServiceURL := envstr(\"USER_SERVICE\", \"http://user-service:8080\")\n\n\tsmtpserver := \"smtp.mediatek.com:25\"\n\n\tif smtp := envstr(\"SMTP_SERVER\", \"\"); smtp != \"\" {\n\t\tsmtpserver = smtp\n\t}\n\n\tredisurl := envmust(\"REDIS_URL\")\n\n\tcapping := envstr(\"ENABLE_CAPPING\", \"true\")\n\n\tvar err error\n\tvar crowdapi crowdadapter.Adapter\n\n\trueidisopt := rueidis.ClientOption{InitAddress: []string{redisurl}}\n\tif strings.Contains(redisurl, \"://\") {\n\t\trueidisopt = rueidis.MustParseURL(redisurl)\n\t}\n\trueidisopt.CacheSizeEachConn = 64 * (1 << 20)\n\trac, err := rueidisaside.NewClient(rueidisaside.ClientOption{ClientOption: rueidisopt})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trc := rac.Client()\n\n\tswitch envstr(\"CROWD_IMPL_TYPE\", \"crowd\") {\n\tcase \"crowd\":\n\t\tcrowdapi, err = crowdadapter.NewCrowdAPI(envmust(\"CROWD_USERNAME\"), envmust(\"CROWD_PASSWORD\"), rac)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\tcase \"none\":\n\t\tcrowdapi = &crowdadapter.Empty{}\n\tdefault:\n\t\tpanic(\"unexpected CROWD_IMPL_TYPE\")\n\t}\n\n\tpermMgr := common.NewModelPermissionManager(jwtKey, crowdapi)\n\ttr := http.DefaultTransport.(*http.Transport).Clone()\n\ttr.MaxIdleConns = 10000\n\ttr.MaxIdleConnsPerHost = 1000\n\ttr.ResponseHeaderTimeout = 0\n\tif resolver := os.Getenv(\"RESOLVER_ADDR\"); resolver != \"\" {\n\t\tdialer := net.Dialer{\n\t\t\tResolver: &net.Resolver{\n\t\t\t\tPreferGo: true,\n\t\t\t\tDial: func(ctx context.Context, network, address string) (net.Conn, error) {\n\t\t\t\t\treturn (&net.Dialer{}).DialContext(ctx, \"tcp\", resolver)\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\ttr.DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\taddr = strings.Replace(addr, \"mtklm-core.mediatek.inc\", \"10.225.43.241\", 1)\n\t\t\treturn dialer.DialContext(ctx, network, addr)\n\t\t}\n\t}\n\tif strings.Contains(os.Getenv(\"CSES_LLM_API_URL\"), \"mtklm-hwrd.mediatek.inc\") {\n\t\tdialer := &tls.Dialer{\n\t\t\tConfig: &tls.Config{\n\t\t\t\tInsecureSkipVerify: true,\n\t\t\t},\n\t\t}\n\t\ttr.DialTLSContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\tif strings.Contains(addr, \"mtklm-hwrd.mediatek.inc\") {\n\t\t\t\treturn dialer.DialContext(ctx, network, \"10.10.46.14:443\")\n\t\t\t}\n\t\t\treturn dialer.DialContext(ctx, network, addr)\n\t\t}\n\t}\n\n\tqc := quota.NewRedisQuotaClient(rc, capping == \"true\")\n\n\ttiktoken.SetBpeLoader(tiktoken_loader.NewOfflineLoader())\n\tcl100k, err := tiktoken.GetEncoding(\"cl100k_base\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tp50k, err := tiktoken.GetEncoding(\"p50k_base\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar aoaidispatchers map[string]*dispatcher\n\tvar aoaifallback *endpoint\n\tbedrockendpoint := make(map[string]*endpoint)\n\n\t// AOAI pricing and endpoint configuration\n\t// Price: https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/\n\taoaidispatchers = map[string]*dispatcher{\n\t\t\"aide-gpt-4-turbo\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4-turbo\", true, crowdapi, qc, smtpserver, cl100k, 1000, 1500*2), []endpointconfig{\n\t\t\taoai(480, \"aideopenaicanadaeast\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaieastus2\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaifrancecentral\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(900, \"aideopenainorwayeast\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(900, \"aideopenaisouthindia\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaiwestus\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(900, \"aideopenaiswedencentral\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaiuksouth\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenainorthcentralus\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaisouthcentralus\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaieastus\", \"aide-gpt-4-turbo\"),\n\t\t}),\n\t\t// for AIDE internal use\n\t\t\"aide-gpt-4-turbo-1106\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4-turbo-1106\", true, crowdapi, qc, smtpserver, cl100k, 1000, 1500*2), []endpointconfig{\n\t\t\taoai(5000, \"aideopenaiaustraliaeast\", \"aide-gpt-4-turbo-1106\"),\n\t\t}),\n\t\t// for AIDE internal use\n\t\t\"aide-gpt-4o-0806\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4o-0806\", true, crowdapi, qc, smtpserver, cl100k, 500, 1500), []endpointconfig{\n\t\t\taoai(5000, \"aideopenaieastus\", \"aide-gpt-4o-0806\"),\n\t\t}),\n\t\t\"aide-gpt-4o\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4o\", true, crowdapi, qc, smtpserver, cl100k, 500, 1500), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaijapaneast\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaiwestus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenainorthcentralus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaisouthcentralus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaieastus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaiwestus3\", \"aide-gpt-4o\"),\n\t\t}),\n\t\t\"aide-gpt-4o-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4o-mini\", true, crowdapi, qc, smtpserver, cl100k, 15, 60), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus\", \"aide-gpt-4o-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4o-mini\"),\n\t\t\taoai(60000, \"aideopenaijapaneast\", \"aide-gpt-4o-mini\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4o-mini\"),\n\t\t}),\n\t\t\"aide-gpt-4.1\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4.1\", true, crowdapi, qc, smtpserver, cl100k, 200, 800), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4.1\"),\n\t\t\taoai(600000, \"aideopenaijapaneast\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaicanadaeast\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaiaustraliaeast\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenainorthcentralus\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaisouthcentralus\", \"aide-gpt-4.1\"),\n\t\t}),\n\t\t\"aide-gpt-4.1-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4.1-mini\", true, crowdapi, qc, smtpserver, cl100k, 40, 160), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4.1-mini\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4.1-mini\"),\n\t\t}),\n\t\t\"aide-gpt-4.1-nano\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4.1-nano\", true, crowdapi, qc, smtpserver, cl100k, 10, 40), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4.1-nano\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4.1-nano\"),\n\t\t}),\n\t\t\"aide-gpt-5\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5\", true, crowdapi, qc, smtpserver, cl100k, 125, 1000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5\"),\n\t\t}),\n\t\t\"aide-gpt-5-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5-mini\", true, crowdapi, qc, smtpserver, cl100k, 250, 200), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5-mini\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5-mini\"),\n\t\t}),\n\t\t\"aide-gpt-5-nano\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5-nano\", true, crowdapi, qc, smtpserver, cl100k, 5, 40), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5-nano\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5-nano\"),\n\t\t}),\n\t\t\"aide-gpt-5-chat\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5-chat\", true, crowdapi, qc, smtpserver, cl100k, 125, 1000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5-chat\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5-chat\"),\n\t\t}),\n\t\t\"aide-o1-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o1-mini\", true, crowdapi, qc, smtpserver, cl100k, 300, 1200), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o1-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o1-mini\"),\n\t\t}),\n\t\t\"aide-o1\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o1\", true, crowdapi, qc, smtpserver, cl100k, 1500, 6000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o1\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o1\"),\n\t\t}),\n\t\t// o1-preview will be deprecated if o1 is stable\n\t\t\"aide-o1-preview\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o1-preview\", true, crowdapi, qc, smtpserver, cl100k, 1500, 6000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o1-preview\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o1-preview\"),\n\t\t}),\n\t\t\"aide-o3-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o3-mini\", true, crowdapi, qc, smtpserver, cl100k, 110, 440), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o3-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o3-mini\"),\n\t\t}),\n\t\t\"aide-o3\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o3\", true, crowdapi, qc, smtpserver, cl100k, 200, 800), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o3\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o3\"),\n\t\t}),\n\t\t\"aide-o3-pro\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o3-pro\", true, crowdapi, qc, smtpserver, cl100k, 2000, 8000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o3-pro\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o3-pro\"),\n\t\t}),\n\t\t\"aide-o4-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o4-mini\", true, crowdapi, qc, smtpserver, cl100k, 110, 440), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o4-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o4-mini\"),\n\t\t}),\n\t\t\"aide-gpt-4-turbo-vision\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4-turbo-vision\", true, crowdapi, qc, smtpserver, cl100k, 1000, 1500*2), []endpointconfig{\n\t\t\taoai(10, \"aideopenaiaustraliaeast\", \"aide-gpt-4-turbo-vision\"),\n\t\t\taoai(10, \"aideopenaiwestus\", \"aide-gpt-4-turbo-vision\"),\n\t\t\taoai(10, \"aideopenaiswitzerlandnorth\", \"aide-gpt-4-turbo-vision\"),\n\t\t\taoai(10, \"aideopenaiswedencentral\", \"aide-gpt-4-turbo-vision\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo-16k-4k\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo-16k-4k\", true, crowdapi, qc, smtpserver, cl100k, 100, 200), []endpointconfig{\n\t\t\taoai(720, \"aideopenaiaustraliaeast\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(3720, \"aideopenaicanadaeast\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaifrancecentral\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaisouthindia\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaiwestus\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaiuksouth\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(1800, \"aideopenainorthcentralus\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaisouthcentralus\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo\", false, crowdapi, qc, smtpserver, cl100k, 150, 200), []endpointconfig{\n\t\t\taoai(1440, \"aideopenaifrancecentral\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(720, \"aideopenaisouthcentralus\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1440, \"aideopenaiuksouth\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(900, \"aideopenaicanadaeast\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaijapaneast\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(900, \"aideopenainorthcentralus\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaieastus2\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaiaustraliaeast\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(3000, \"aideopenaiswitzerlandnorth\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(3000, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaieastus\", \"aide-gpt-35-turbo\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo-instruct\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo-instruct\", false, crowdapi, qc, smtpserver, cl100k, 150, 200), []endpointconfig{\n\t\t\taoai(1440, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo-instruct\"),\n\t\t\taoai(1440, \"aideopenaieastus\", \"aide-gpt-35-turbo-instruct\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo-16k\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo-16k\", false, crowdapi, qc, smtpserver, cl100k, 300, 400), []endpointconfig{\n\t\t\taoai(1440, \"aideopenaifrancecentral\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(3000, \"aideopenaiuksouth\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(900, \"aideopenaicanadaeast\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaijapaneast\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(900, \"aideopenainorthcentralus\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(3000, \"aideopenaieastus2\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaiaustraliaeast\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaiswitzerlandnorth\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1440, \"aideopenaieastus\", \"aide-gpt-35-turbo-16k\"),\n\t\t}),\n\t\t\"aide-text-embedding-3-large\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-3-large\", false, crowdapi, qc, smtpserver, cl100k, 13, 13), []endpointconfig{\n\t\t\taoai(2100, \"aideopenaicanadaeast\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaieastus\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaieastus2\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaifrancecentral\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaijapaneast\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaisouthindia\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaiswedencentral\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaiuksouth\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaiwestus3\", \"aide-text-embedding-3-large\"),\n\t\t}),\n\t\t\"aide-text-embedding-3-small\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-3-small\", false, crowdapi, qc, smtpserver, cl100k, 2, 2), []endpointconfig{\n\t\t\taoai(2100, \"aideopenaicanadaeast\", \"aide-text-embedding-3-small\"),\n\t\t\taoai(2100, \"aideopenaieastus\", \"aide-text-embedding-3-small\"),\n\t\t\taoai(2100, \"aideopenaieastus2\", \"aide-text-embedding-3-small\"),\n\t\t}),\n\t\t\"aide-text-embedding-ada-002-v2\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-ada-002-v2\", false, crowdapi, qc, smtpserver, cl100k, 10, 10), []endpointconfig{\n\t\t\taoai(4200, \"aideopenaiwesteurope\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(4200, \"aideopenaieastus2\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(4200, \"aideopenaisouthcentralus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiaustraliaeast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaicanadaeast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaijapaneast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiswitzerlandnorth\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenainorthcentralus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiuksouth\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaifrancecentral\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiswedencentral\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(1380, \"aideopenaieastus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiwestus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenainorwayeast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaisouthindia\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaisouthafricanorth\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiwestus3\", \"aide-text-embedding-ada-002-v2\"),\n\t\t}),\n\t\t\"aide-text-embedding-ada-002\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-ada-002\", false, crowdapi, qc, smtpserver, cl100k, 10, 10), []endpointconfig{\n\t\t\taoai(20, \"aideopenaieastus\", \"aide-text-embedding-ada-002\"),\n\t\t}),\n\t\t\"aide-davinci-003\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-davinci-003\", false, crowdapi, qc, smtpserver, p50k, 2000, 2000), []endpointconfig{\n\t\t\taoai(600, \"aideopenaieastus\", \"aide-davinci-003\"),\n\t\t}),\n\t\t\"aide-code-davinci-002\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-code-davinci-002\", false, crowdapi, qc, smtpserver, p50k, 1000, 1000), []endpointconfig{\n\t\t\taoai(600, \"aideopenaieastus\", \"aide-code-davinci-002\"),\n\t\t}),\n\t\t\"aide-whisper\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\testimate = 6000000 // assume 10 minute\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoaiNoReqLog(3, \"aideopenaieastus2\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenainorthcentralus\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenainorwayeast\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenaisouthindia\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenaiswedencentral\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenaiwesteurope\", \"aide-whisper\"),\n\t\t}),\n\t\t\"aide-tts\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\testimate = 15000000 // assume 10000 characters\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(3, \"aideopenainorthcentralus\", \"aide-tts\"),\n\t\t\taoai(3, \"aideopenaiswedencentral\", \"aide-tts\"),\n\t\t}),\n\t\t\"aide-gpt-4o-realtime-preview\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\treturn\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(500, \"aideopenaieastus2\", \"aide-gpt-4o-realtime-preview\"),\n\t\t\taoai(500, \"aideopenaiswedencentral\", \"aide-gpt-4o-realtime-preview\"),\n\t\t}),\n\t\t\"aide-tts-hd\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\testimate = 30000000 // assume 10000 characters\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(3, \"aideopenainorthcentralus\", \"aide-tts-hd\"),\n\t\t\taoai(3, \"aideopenaiswedencentral\", \"aide-tts-hd\"),\n\t\t}),\n\t\t\"Dalle3\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\tvar dreq DalleReq\n\t\t\t\tif err := json.Unmarshal([]byte(body), &dreq); err == nil {\n\t\t\t\t\testimate = dreq.N * 4000000 // $4 for 100 images\n\t\t\t\t}\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(240, \"aideopenaiswedencentral\", \"dalle-3\"),\n\t\t\taoai(240, \"aideopenaiaustraliaeast\", \"dalle-3\"),\n\t\t\taoai(240, \"aideopenaieastus\", \"dalle-3\"),\n\t\t}),\n\t\t\"dalle\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\tvar dreq DalleReq\n\t\t\t\tif err := json.Unmarshal([]byte(body), &dreq); err == nil {\n\t\t\t\t\testimate = dreq.N * 2000000 // $2 for 100 images\n\t\t\t\t}\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(1380, \"aideopenaieastus\", \"dalle\"),\n\t\t}),\n\t\t\"dalleget\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\treturn 0, 1, nil\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(1380, \"aideopenaieastus\", \"dalleget\"),\n\t\t}),\n\t}\n\taoaifallback = NewEndpoint(context.Background(), true, aoai(0, \"aideopenaieastus\", \"other\"), tr, logger, aoaiSpend(\"\", true, crowdapi, qc, smtpserver, cl100k, 200, 150))\n\n\tassistantsAPIResource := envstr(\"ASSISTANTS_API_RESOURCE\", \"aideopenaiaustraliaeast\")\n\tassistantsAPI := NewEndpoint(context.Background(), false, endpointconfig{\n\t\turl:    fmt.Sprintf(\"https://%s.openai.azure.com\", assistantsAPIResource),\n\t\thdrs:   map[string]string{\"api-key\": envstr(\"AZURE_OPAI_KEY_\"+strings.ReplaceAll(assistantsAPIResource, \"-\", \"_\"), \"\")},\n\t\tlabels: []string{\"aoai\", \"assistants\", assistantsAPIResource},\n\t}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"/runs\") {\n\t\t\t\testimate = 1000000 // estimated assistants api costs $10 for 1000 runs\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tazurecognitive := NewEndpoint(context.Background(), true, endpointconfig{url: envstr(\"AZURE_COGNITIVE_HOST\", \"https://aide-cognitive-multi.cognitiveservices.azure.com\"), hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envmust(\"AZURE_COGNITIVE_KEY\"),\n\t}, noreqlog: true, labels: []string{\"cogn\", \"ocr\", \"azure-cognitive-multi\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"read/analyze\") {\n\t\t\t\testimate = 100000 // OCR api costs $1 for 1000 calls\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif strings.Contains(req.URL.Path, \":analyze\") {\n\t\t\t\testimate = 1000000 // document api costs $10 per 1,000 pages\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tsttxy := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://southeastasia.stt.speech.microsoft.com\", hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envstr(\"SPEECH_API_KEY\", envmust(\"AZURE_COGNITIVE_KEY\")),\n\t}, noreqlog: true, labels: []string{\"cogn\", \"stt\", \"southeastasia\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tcustomvoice := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://southeastasia.customvoice.api.speech.microsoft.com\", hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envmust(\"AZURE_COGNITIVE_KEY\"),\n\t}, labels: []string{\"cogn\", \"tts\", \"southeastasia\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"batchsynthesis\") {\n\t\t\t\testimate = 100000 // TTS api costs $1 for 1 hour\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tbing := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://api.bing.microsoft.com\", hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envstr(\"AZURE_BING_KEY\", \"\"),\n\t}, labels: []string{\"cogn\", \"bing\", \"southeastasia\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"batchsynthesis\") {\n\t\t\t\testimate = 300000 // search api costs $3 for 1000 calls\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tcsesLLMAPIURL := envstr(\"CSES_LLM_API_URL\", \"https://mtklm-core.mediatek.inc\")\n\n\tmtklmr := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://mtklm-mr.mediatek.inc\", labels: []string{\"mtkmr\", \"cses\", \"c\"}, hdrs: map[string]string{\n\t\t\"Authorization\": \"Bearer \" + envstr(\"CSES_LLM_MR_API_KEY\", \"\"),\n\t}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tmtkcreatetoken := os.Getenv(\"CREATE_MTK_RESEARCH_COM_LLM_API_TOKEN\")\n\n\tmtkcreate := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://create.mtkresearch.com\", labels: []string{\"mtkmr\", \"cses\", \"c\"}, hdrs: map[string]string{\n\t\t\"Authorization\": fmt.Sprintf(\"Bearer %s\", mtkcreatetoken),\n\t}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tmtklcore := NewEndpoint(context.Background(), false, endpointconfig{url: csesLLMAPIURL, labels: []string{\"mtkcore\", \"cses\", \"c\"}, hdrs: map[string]string{\n\t\t\"Authorization\": \"Bearer \" + envstr(\"CSES_LLM_API_KEY\", \"\"),\n\t}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tmodel := extractModel(req.URL.Path, body)\n\t\t\tif model != \"\" {\n\t\t\t\tif ok := permMgr.CheckServicePermission(req.Context(), req, model, domain, user, crowdapi); !ok {\n\t\t\t\t\treturn 0, 1, DomainNotAllowed\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tvar creds *google.Credentials\n\tvar gcpcredonce sync.Once\n\n\tgeminiRegions := gemini.GeminiRegions\n\tgeminis := make(map[string]*endpoint, len(geminiRegions))\n\tfor _, region := range geminiRegions {\n\t\t// Use smart SpendFn that can handle multiple Gemini models dynamically\n\t\tspendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)\n\t\tgeminis[region] = NewEndpoint(context.Background(), false, endpointconfig{\n\t\t\turl:    \"https://aiplatform.googleapis.com\",\n\t\t\tlabels: []string{\"gcp\", \"gemini\", region},\n\t\t}, tr, logger, spendFn)\n\t}\n\n\tdavinciShareProd := NewDaviciShareServerFunc(envstr(\"STORE_API_PROD_URL\", \"http://store-api-prod.default.svc.cluster.mke\"), envstr(\"DAVINCI_PROD_URL\", \"https://davinci.mediatek.inc/\"))\n\tdavinciShareStag := NewDaviciShareServerFunc(envstr(\"STORE_API_STAG_URL\", \"http://store-api-stag.default.svc.cluster.mke\"), envstr(\"DAVINCI_STAG_URL\", \"https://davinci-io.mediatek.inc/\"))\n\n\tawsKey := os.Getenv(\"AWS_ACCESS_KEY\")\n\tawsSecret := os.Getenv(\"AWS_SECRET_KEY\")\n\tawssigner := v4.NewSigner()\n\tsignAwsReq := awsclaude.SignAwsReq(awssigner, awsKey, awsSecret)\n\n\tawsdispatchers := make(map[string]*dispatcher)\n\tawsModelEndpointConfigs := make(map[string][]endpointconfig)\n\tmodelIDSpendFnKey := make(map[string]string)\n\tfor modelKey, arn := range awsclaude.ModelARNs {\n\t\tregion := awsclaude.GetRegionFromArn(arn)\n\t\tmodelWithVersion := awsclaude.GetModelWithVersionFromArn(arn)\n\t\tmodelId := awsclaude.GetModelIDFromModelWithVersion(modelWithVersion)\n\n\t\tendpointUrl := awsclaude.GetEndpointFromRegion(region)\n\t\tspendFnKey := awsclaude.ModelKeyToSpendFnKey(modelKey) // 例如 \"claude-v3-5-haiku\"\n\t\tmodelIDSpendFnKey[modelId] = spendFnKey\n\n\t\tspendFnFactory, ok := awsclaude.SpendFnMap[spendFnKey]\n\t\tif !ok {\n\t\t\tpanic(\"no spendFn for model: \" + modelKey)\n\t\t}\n\n\t\tfn := spendFnFactory(signAwsReq, crowdapi, qc, smtpserver, cl100k)\n\t\tepcForArn := endpointconfig{\n\t\t\tweight: 1,\n\t\t\turl:    endpointUrl,\n\t\t\tlabels: []string{\"awsbedrock\", modelKey, region},\n\t\t}\n\t\tbedrockendpoint[modelKey] = NewEndpoint(\n\t\t\tcontext.Background(), false, epcForArn, tr, logger, fn,\n\t\t)\n\n\t\tepcForModelId := endpointconfig{\n\t\t\tweight: 1,\n\t\t\turl:    endpointUrl + \"/model/\" + modelWithVersion,\n\t\t\tlabels: []string{\"awsbedrock\", modelKey, region},\n\t\t}\n\n\t\tawsModelEndpointConfigs[modelId] = append(awsModelEndpointConfigs[modelId], epcForModelId)\n\t}\n\n\tfor modelId, epcs := range awsModelEndpointConfigs {\n\t\tspendFnKey := modelIDSpendFnKey[modelId]\n\t\tspendFn := awsclaude.SpendFnMap[spendFnKey](signAwsReq, crowdapi, qc, smtpserver, cl100k)\n\t\tawsdispatchers[modelId] = NewDispatcher(tr, logger, false, spendFn, epcs)\n\t}\n\n\t// update modelMapGroupSVC\n\t// Initialize ModelPermissionManager before usage below\n\t// permMgr already initialized above using jwtKey and crowdapi\n\tmodelGroupSvc := NewModelGroupService(domain, logger)\n\tinitParams := ModelGroupInitParams{\n\t\tDomain:         domain,\n\t\tAOAIDispatcher: aoaidispatchers,\n\t\tAWSDispatcher:  awsdispatchers,\n\t\t// Use the injected model permission manager's map\n\t\tModelPermissionMap: permMgr.Map,\n\t\tClaudeGroups:       map[string]map[string]string{}, // ClaudeGroups temporarily disabled, replaced with an empty map. TODO: Restore when fixed.\n\t}\n\tmodelGroupSvc.InitAllModelGroups(initParams)\n\tenableModelCheck := envBool(\"ENABLE_MODEL_CHECK\", false)\n\n\tallowedLogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\n\tuserService := user.NewEngine(userServiceURL, jwtKey, crowdapi)\n\tjwtVeriHandler := APIV1.JWTVerifyHandler(userService)\n\tgin.SetMode(gin.ReleaseMode)\n\tapp := gin.New()\n\tapp.Use(gin.Recovery())\n\tapp.Use(header.Options)\n\tapp.Use(header.Secure)\n\tapp.Use(requestid.New())\n\tapp.GET(\"/\", func(c *gin.Context) {\n\t\tc.AbortWithStatus(http.StatusOK)\n\t})\n\t// Add auth routers\n\tauth.RegisterRoutes(app, domain, jwtKey, userService)\n\tapp.GET(\"/metrics\", gin.WrapH(promhttp.Handler()))\n\tapp.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\t{\n\t\tv1 := app.Group(\"/v1\")\n\t\tv1.GET(\"/version\", APIV1.GetVersion)\n\t\tv1.POST(\"/token\",\n\t\t\tjwtVeriHandler,\n\t\t\tmiddleware.VerifyAdmin(crowdapi, \"gaisf_admins\"),\n\t\t\tAPIV1.JWTSignHandler(\n\t\t\t\tcrowdapi,\n\t\t\t\tuserService,\n\t\t\t),\n\t\t)\n\t\tv1.POST(\"/services/:uid/token\",\n\t\t\tjwtVeriHandler,\n\t\t\tmiddleware.VerifyAdmin(crowdapi, \"gaisf_admins\"),\n\t\t\tAPIV1.ServiceJWTSignHandler(\n\t\t\t\tcrowdapi,\n\t\t\t\tuserService,\n\t\t\t),\n\t\t)\n\t\tv1.GET(\"/models\", jwtVeriHandler, APIV1.UserModelsHandler(domain, crowdapi, modelGroupSvc, false))\n\t\tv1.GET(\"/admin/models\", jwtVeriHandler, APIV1.UserModelsHandler(domain, crowdapi, modelGroupSvc, true))\n\n\t\tawsClaudeModels := make(map[string]interface{})\n\t\tfor k := range awsdispatchers {\n\t\t\tawsClaudeModels[k] = struct{}{}\n\t\t}\n\t\tdeps := &ChatHandlerDeps{\n\t\t\tAoaidDispatchers: aoaidispatchers,\n\t\t\tDomain:           domain,\n\t\t\tMtklcore:         mtklcore,\n\t\t\tGeminis:          geminis,\n\t\t\tCrowdapi:         crowdapi,\n\t\t\tBuffers:          &buffers,\n\t\t\tAwsClaudesModels: awsClaudeModels,\n\t\t}\n\t\tif enableModelCheck {\n\t\t\tv1.POST(\"/chat/completions\", jwtVeriHandler, modelGroupSvc.CompletionsMiddleware(domain), deps.ChatCompletionsHandler)\n\t\t} else {\n\t\t\tv1.POST(\"/chat/completions\", jwtVeriHandler, deps.ChatCompletionsHandler)\n\t\t}\n\t\tv1.GET(\"/users/:uid/cap\", jwtVeriHandler, APIV1.UserCapHandler(qc))\n\t\tv1.POST(\"/users/:uid/token\", jwtVeriHandler, APIV1.UserTokenHandler(userService))\n\t\tv1.POST(\"/token/check\", jwtVeriHandler, APIV1.TokenCheckHandler)\n\t\tv1.POST(\"/login\", jwtVeriHandler, APIV1.LoginHandler(userService))\n\t}\n\tapp.POST(\"/verify\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"project\": lc.Project, \"tokenId\": lc.TokenID, \"account\": lc.Account, \"domain\": lc.Domain})\n\t})\n\tapp.GET(\"/in\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tlogger := allowedLogger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", ctx.Request.Header.Get(\"X-Request-ID\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"req\", InListReq{Uid: ctx.Query(\"uid\"), List: ctx.Query(\"list\")}.ToString(), \"hdrs\", ToHeaderLogs(ctx.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\n\t\tstatus, resp := checkInCrowdGroup(crowdapi, ctx.Query(\"list\"), ctx.Query(\"uid\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"resp\", resp.ToString())\n\t\tctx.AbortWithStatusJSON(status, resp)\n\t})\n\n\t// POST /bing-search endpoint\n\t// --- credential init, only once ---\n\tazureBingCfg, _ := azurebingsearch.GetConfig()\n\tazureBingCred, _ := azidentity.NewClientSecretCredential(\n\t\tazureBingCfg.TenantID,\n\t\tazureBingCfg.ClientID,\n\t\tazureBingCfg.ClientSecret,\n\t\tnil,\n\t)\n\n\tapp.POST(\"/bing-search\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tvar req struct {\n\t\t\tQ string `json:\"q\"`\n\t\t}\n\t\tif err := ctx.ShouldBindJSON(&req); err != nil || req.Q == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"missing q\"})\n\t\t\treturn\n\t\t}\n\t\tresult, err := azurebingsearch.BingSearch(context.Background(), req.Q, azureBingCred)\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\n\t\t\t\"project\": lc.Project,\n\t\t\t\"tokenId\": lc.TokenID,\n\t\t\t\"account\": lc.Account,\n\t\t\t\"domain\":  lc.Domain,\n\t\t\t\"result\":  result,\n\t\t})\n\t})\n\n\tapp.GET(\"/searchusers\", func(ctx *gin.Context) {\n\t\tcql := ctx.Query(\"cql\")\n\t\tlimit, ok := getLimit(ctx)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tusers, err := crowdapi.SearchUsers(context.Background(), cql, limit)\n\t\tif err == crowd.ErrNoPerms {\n\t\t\tctx.AbortWithError(http.StatusForbidden, err)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, users)\n\t})\n\n\tapp.GET(\"/searchgroups\", func(ctx *gin.Context) {\n\t\tcql := ctx.Query(\"cql\")\n\t\tlimit, ok := getLimit(ctx)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tgroups, err := crowdapi.SearchGroups(context.Background(), cql, limit)\n\t\tif err == crowd.ErrNoPerms {\n\t\t\tctx.AbortWithError(http.StatusForbidden, err)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, groups)\n\t})\n\n\tapp.GET(\"/groupmembers\", func(ctx *gin.Context) {\n\t\tgroup := ctx.Query(\"group\")\n\t\tlimit, ok := getLimit(ctx)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tusers, err := crowdapi.GetGroupNestedUsers(context.Background(), group, limit)\n\t\tif err == crowd.ErrNoPerms {\n\t\t\tctx.AbortWithError(http.StatusForbidden, err)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tif strings.Contains(err.Error(), \"status code 404\") {\n\t\t\t\tctx.AbortWithError(http.StatusNotFound, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, users)\n\t})\n\tapp.GET(\"/allowed\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tlogger := allowedLogger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", ctx.Request.Header.Get(\"X-Request-ID\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"req\", common.AllowedReq{Uid: ctx.Query(\"uid\"), Domain: ctx.Query(\"domain\")}.ToString(), \"hdrs\", ToHeaderLogs(ctx.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\n\t\tstatus, resp := common.CheckPIM(crowdapi, ctx.Query(\"domain\"), ctx.Query(\"uid\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"resp\", resp.ToString())\n\t\tctx.AbortWithStatusJSON(status, resp)\n\t})\n\tapp.GET(\"/getcap\", func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tusage, cap, err := qc.GetCap(ctx.Request.Context(), uid)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"usage\": usage, \"cap\": cap, \"uid\": uid})\n\t})\n\tapp.POST(\"/charge\", func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tcost, err := strconv.Atoi(ctx.Query(\"cost\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tif cost < 0 {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, errors.New(\"the cost should be >= 0\"))\n\t\t\treturn\n\t\t}\n\t\tremain, err := qc.Spend(ctx, uid, cost)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"remain\": remain, \"uid\": uid})\n\t})\n\tapp.POST(\"/setcap\", func(ctx *gin.Context) {\n\t\tif ctx.Request.Header.Get(\"jwt-enc\") != jwtKey {\n\t\t\tctx.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"invalid jwt-enc header\"})\n\t\t\treturn\n\t\t}\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"uid is required\"})\n\t\t\treturn\n\t\t}\n\t\tcap, err := strconv.Atoi(ctx.Query(\"cap\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid cap value\"})\n\t\t\treturn\n\t\t}\n\t\tend, err := time.Parse(\"2006-01-02\", ctx.Query(\"end\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid end format\"})\n\t\t\treturn\n\t\t}\n\t\tif err = qc.SetCap(ctx.Request.Context(), uid, cap, end.Unix()); err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to set cap\"})\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{})\n\t})\n\t// Set a session cookie in Redis with a custom TTL\n\tapp.POST(\"/setSessionCookie\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tuserName := ctx.PostForm(\"user_name\")\n\t\tcookie := ctx.PostForm(\"cookie\")\n\t\tttlSecondsStr := ctx.PostForm(\"ttlSeconds\")\n\t\tttlSeconds, err := strconv.Atoi(ttlSecondsStr)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tif err := qc.SetSessionCookie(ctx, userName, cookie, ttlSeconds); err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.Status(http.StatusOK)\n\t})\n\t// Get a session cookie from Redis\n\tapp.GET(\"/getSessionCookie\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tuserName := ctx.Query(\"user_name\")\n\t\tcookie, err := qc.GetSessionCookie(ctx, userName)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tif cookie == \"\" {\n\t\t\tctx.AbortWithStatus(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, gin.H{\"cookie\": cookie})\n\t})\n\tapp.POST(\"/checkrate\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc, ok := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tif !ok || lc == nil || lc.UID == nil || *lc.UID == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"user not found in context\"})\n\t\t\treturn\n\t\t}\n\t\tuid := *lc.UID\n\t\tok, req, cap, gap, err := qc.Limit(ctx.Request.Context(), strings.ToUpper(uid))\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"ok\": ok, \"req\": req, \"cap\": cap, \"gap\": gap})\n\t})\n\tapp.POST(\"/setreq\", jwtVeriHandler, middleware.VerifyAdmin(crowdapi, \"gaisf_admins\"), func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"uid is required\"})\n\t\t\treturn\n\t\t}\n\t\treq, err := strconv.Atoi(ctx.Query(\"req\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid req\"})\n\t\t\treturn\n\t\t}\n\t\tgap, err := strconv.Atoi(ctx.Query(\"gap\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid gap\"})\n\t\t\treturn\n\t\t}\n\t\tif err = qc.SetLimit(ctx.Request.Context(), uid, int64(req), int64(gap)); err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to set limit\"})\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{})\n\t})\n\tapp.GET(\"/getreq\", func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, errors.New(\"uid is required\"))\n\t\t\treturn\n\t\t}\n\t\tret, err := qc.GetLimit(ctx.Request.Context(), uid)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"req\": ret[0], \"gap\": ret[1]})\n\t})\n\tapp.GET(\"/time\", func(ctx *gin.Context) {\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"ts\": time.Now()})\n\t})\n\tapp.POST(\"/spend\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc, ok := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tif !ok || lc == nil || lc.UID == nil || *lc.UID == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"user not found in context\"})\n\t\t\treturn\n\t\t}\n\t\tuid := *lc.UID\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, errors.New(\"uid is required\"))\n\t\t\treturn\n\t\t}\n\t\tspend, err := strconv.Atoi(ctx.Query(\"spend\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tremain, err := qc.Spend(ctx.Request.Context(), uid, spend)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"remain\": remain})\n\t})\n\n\t// davinciProcxyRouter is a Gin middleware function that handles routing and authentication for various API endpoints.\n\t// It performs the following main functions:\n\t//   - Validates domain access and user authentication\n\t//   - Enforces X-User-Id header requirement for cost allocation\n\t//   - Routes requests to appropriate services based on URL path:\n\t//     * LLM models (v3)\n\t//     * OpenAI services (including DALL-E)\n\t//     * Anthropic Claude models\n\t//     * Bing search\n\t//     * Azure Cognitive Services (vision, form recognition)\n\t//     * Speech services (text-to-speech, speech-to-text)\n\t//     * Gemini API endpoints\n\t//     * Davinci chat sharing\n\t//   - Performs PIM checks for certain endpoints\n\t//   - Enriches headers with required information\n\t//   - Handles timeout simulation for testing\n\t// Parameters:\n\t//   - c: Gin context containing the HTTP request and response information\n\tdavinciProcxyRouter := func(c *gin.Context) {\n\t\tlc := c.MustGet(\"lc\").(*common.LoggingContext)\n\t\tif lc.UID == nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": gin.H{\n\t\t\t\t\"code\":    strconv.Itoa(http.StatusForbidden),\n\t\t\t\t\"message\": \"missing UID in logging context\",\n\t\t\t}})\n\t\t\treturn\n\t\t}\n\t\tif lc.Domain == \"\" {\n\t\t\tlc.Domain = \"oa\"\n\t\t}\n\t\tif (domain == \"oa\" && lc.Domain != domain) || ((common.IsAirgappedDomain(domain) || common.IsAirgappedDomain(c.Request.Header.Get(\"X-Domain\"))) && !common.IsAirgappedDomain(lc.Domain)) {\n\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": gin.H{\n\t\t\t\t\"code\":    strconv.Itoa(http.StatusForbidden),\n\t\t\t\t\"message\": fmt.Sprintf(\"token for domain %q is prohibited here\", lc.Domain),\n\t\t\t}})\n\t\t\treturn\n\t\t}\n\t\tendUser := *lc.UID\n\t\tif endUser == \"\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": gin.H{\n\t\t\t\t\"code\":    strconv.Itoa(http.StatusForbidden),\n\t\t\t\t\"message\": \"The X-User-Id request header is now mandatory for cost allocation. Please set the parameter with \\\"mtkxxxxx\\\" for allocating to the end user's department or \\\"srv_xxxx\\\" for background jobs.\",\n\t\t\t}})\n\t\t\treturn\n\t\t}\n\n\t\t// Check if the request is for a specific endpoint that requires PIM check\n\t\t// and if the request method is POST, PUT, or GET with specific path prefix\n\t\t// If so, perform the PIM check and update the X-User-Id header if necessary\n\t\t// If the PIM check fails, abort the request with the appropriate status and response\n\t\t// If the PIM check passes, update the LoggingContext with the response data (Banwords)\n\t\tif !strings.HasPrefix(c.Request.URL.Path, \"/llm/v3\") &&\n\t\t\t(c.Request.Method == http.MethodPost ||\n\t\t\t\tc.Request.Method == http.MethodPut ||\n\t\t\t\t(c.Request.Method == http.MethodGet && strings.HasPrefix(c.Request.URL.Path, \"/v7.0\"))) {\n\t\t\tstatus, resp := common.CheckPIM(crowdapi, lc.Domain, endUser)\n\t\t\tif status != http.StatusOK {\n\t\t\t\tlogger := allowedLogger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", c.Request.Header.Get(\"X-Request-ID\"))\n\t\t\t\tlogger.Info(c.Request.URL.Path, \"req\", \"checkpim\", \"hdrs\", ToHeaderLogs(c.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\t\t\t\tlogger.Info(c.Request.URL.Path, \"resp\", resp.ToString(), \"hdrs\", ToHeaderLogs(c.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\t\t\t\tc.AbortWithStatusJSON(status, resp)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif resp.UID != \"\" && resp.UID != endUser {\n\t\t\t\tc.Request.Header.Set(\"X-User-Id\", resp.UID)\n\t\t\t}\n\t\t\tlc.Banwords = resp.Banwords\n\t\t}\n\n\t\tif strings.HasPrefix(c.Request.URL.Path, \"/timeout\") {\n\t\t\tduration, _ := time.ParseDuration(c.Query(\"dur\"))\n\t\t\ttime.Sleep(duration)\n\t\t\tc.JSON(http.StatusOK, gin.H{\"duration\": duration})\n\t\t\treturn\n\t\t}\n\n\t\tif c.Request.Method != http.MethodDelete {\n\n\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/model/anthropic\") {\n\t\t\t\tmodelId := strings.Split(c.Request.URL.Path, \"/\")[2]\n\t\t\t\tdispatcher, ok := awsdispatchers[modelId]\n\t\t\t\tif !ok {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusNotFound, gin.H{\"error\": \"model not found\"})\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tparts := strings.Split(c.Request.URL.Path, \"/\")\n\t\t\t\tc.Request.URL.Path = \"/\"\n\t\t\t\tif len(parts) > 3 {\n\t\t\t\t\tc.Request.URL.Path = \"/\" + strings.Join(parts[3:], \"/\")\n\t\t\t\t}\n\n\t\t\t\tdispatcher.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// route aws bedrock with bedrock arn\n\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/model/\") {\n\t\t\t\tmodelKey := awsclaude.ParseBedrockModelKeyFromPath(c.Request.URL.Path)\n\t\t\t\tif ep, ok := bedrockendpoint[modelKey]; ok && ep != nil {\n\t\t\t\t\tep.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/llm/v3/models/mtkresearch\") {\n\t\t\t\tif err := enrichCSESHeaders(c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)), domain, lc.Project, lc.TokenID, lc.Payload); err != nil {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif mtkcreatetoken != \"\" {\n\t\t\t\t\tmtkcreate.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t} else {\n\t\t\t\t\tmtklmr.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/llm/v3/info\") {\n\t\t\t\tif err := enrichCSESHeaders(c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)), domain, lc.Project, lc.TokenID, lc.Payload); err != nil {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmtklcore.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/llm/v3/models\") {\n\t\t\t\tif err := enrichCSESHeaders(c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)), domain, lc.Project, lc.TokenID, lc.Payload); err != nil {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmtklcore.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/openai/\") {\n\t\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/openai/assistants\") {\n\t\t\t\t\tassistantsAPI.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/openai/threads\") {\n\t\t\t\t\tassistantsAPI.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/openai/files\") {\n\t\t\t\t\tassistantsAPI.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tdeployment := extractURLSlug(c.Request.URL.Path, 3)\n\t\t\t\tswitch deployment {\n\t\t\t\tcase \"generations:submit\": // DALL·E submit\n\t\t\t\t\tdeployment = \"dalle\"\n\t\t\t\tcase \"images\": // DALL·E get\n\t\t\t\t\tdeployment = \"dalleget\"\n\t\t\t\t}\n\t\t\t\tif d, ok := aoaidispatchers[deployment]; ok {\n\t\t\t\t\t// Check and set default api-version only if needed\n\t\t\t\t\t// See the reference: https://learn.microsoft.com/en-us/azure/ai-services/openai/reference\n\t\t\t\t\tq := c.Request.URL.Query()\n\t\t\t\t\tif q.Get(\"api-version\") == \"\" {\n\t\t\t\t\t\tq.Set(\"api-version\", azure.OpenAIAPIVersion)\n\t\t\t\t\t\tc.Request.URL.RawQuery = q.Encode()\n\t\t\t\t\t}\n\t\t\t\t\td.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t} else {\n\t\t\t\t\tif aoaifallback == nil || aoaifallback.proxy == nil {\n\t\t\t\t\t\tc.AbortWithStatus(http.StatusNotFound)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\taoaifallback.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/v7.0/search\") {\n\t\t\t\tbing.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/vision\") {\n\t\t\t\tif c.Request.ContentLength > 1024*1024*10 {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": gin.H{\n\t\t\t\t\t\t\"code\": strconv.Itoa(http.StatusBadRequest),\n\t\t\t\t\t}})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tazurecognitive.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/formrecognizer\") {\n\t\t\t\tazurecognitive.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/api/texttospeech\") {\n\t\t\t\tcustomvoice.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/speech/recognition/conversation/cognitiveservices\") {\n\t\t\t\tsttxy.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/v1/projects/mtk-aide-gemini-poc/locations\") {\n\t\t\t\tfor region, endpoint := range geminis {\n\t\t\t\t\tif strings.HasPrefix(c.Request.URL.Path[len(\"/v1/projects/mtk-aide-gemini-poc/locations/\"):], region) {\n\t\t\t\t\t\tendpoint.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.AbortWithStatus(http.StatusNotFound)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tdeployment := extractURLSlug(c.Request.URL.Path, 1)\n\n\t\t\t\tif d, ok := aoaidispatchers[deployment]; ok {\n\t\t\t\t\tc.Request.URL.Path = strings.TrimPrefix(c.Request.URL.Path, \"/\"+deployment)\n\t\t\t\t\td.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif strings.HasPrefix(c.Request.URL.Path, \"/davinci/share-chat\") {\n\t\t\tdavinciShareProd(c)\n\t\t\treturn\n\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/davinci-io/share-chat\") {\n\t\t\tdavinciShareStag(c)\n\t\t\treturn\n\t\t}\n\t\tc.AbortWithStatus(http.StatusNotFound)\n\t}\n\n\tenableLLMOverride := envBool(\"ENABLE_OVERRIDE_LLM\", false)\n\tif enableLLMOverride {\n\t\tinitOverriddenMiddleware()\n\t\tapp.NoRoute(header.Options, jwtVeriHandler, overrideMiddleware, davinciProcxyRouter)\n\t} else {\n\t\tapp.NoRoute(header.Options, jwtVeriHandler, davinciProcxyRouter)\n\t}\n\n\tgo func() {\n\t\tsrv := &http.Server{\n\t\t\tAddr:              \":\" + envstr(\"SERVER_PORT\", \"8080\"),\n\t\t\tHandler:           app.Handler(),\n\t\t\tReadHeaderTimeout: time.Minute,\n\t\t\tReadTimeout:       0, // intentionally 0\n\t\t\tWriteTimeout:      0, // intentionally 0\n\t\t\tMaxHeaderBytes:    http.DefaultMaxHeaderBytes,\n\t\t}\n\t\tif err := srv.ListenAndServe(); err != http.ErrServerClosed {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tpoker := poker.DavinciPoker{\n\t\tUsername:    envstr(\"IA_USERNAME\", \"\"),\n\t\tPassword:    envstr(\"IA_PASSWORD\", \"\"),\n\t\tBotTenantID: envstr(\"BOT_TENANT_ID\", \"\"),\n\t\tBotID:       envstr(\"BOT_ID\", \"\"),\n\t\tBotPassword: envstr(\"BOT_PASSWORD\", \"\"),\n\t}\n\tgo poker.RunLoop(30 * time.Minute)\n\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\t<-sigs\n\tcancel()\n\ttime.Sleep(5 * time.Second)\n}\n","structuredPatch":[{"oldStart":1917,"oldLines":7,"newStart":1917,"newLines":7,"lines":["   var creds *google.Credentials","   var gcpcredonce sync.Once"," ","-  geminiRegions := gemini.GeminiRegions","+  geminiRegions := gcp.GeminiRegions","   geminis := make(map[string]*endpoint, len(geminiRegions))","   for _, region := range geminiRegions {","     // Use smart SpendFn that can handle multiple Gemini models dynamically"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"aa4bc4cb-7f2c-4035-b56e-75ca595e43c2","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01GhGhHzMrPXbnYq3aRfHKto","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_014kWUE18vcFqK4ZAFbvnjjd","name":"Edit","input":{"file_path":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","old_string":"\t\tspendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)","new_string":"\t\tspendFn := gcp.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":32546,"cache_read_input_tokens":0,"output_tokens":202}},"type":"assistant","uuid":"fd371be0-7240-4303-b043-3a5d439d574b","timestamp":"2025-08-18T03:19:17.931Z"}
{"parentUuid":"fd371be0-7240-4303-b043-3a5d439d574b","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_014kWUE18vcFqK4ZAFbvnjjd","type":"tool_result","content":"The file /Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1920→\tgeminiRegions := gcp.GeminiRegions\n  1921→\tgeminis := make(map[string]*endpoint, len(geminiRegions))\n  1922→\tfor _, region := range geminiRegions {\n  1923→\t\t// Use smart SpendFn that can handle multiple Gemini models dynamically\n  1924→\t\tspendFn := gcp.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)\n  1925→\t\tgeminis[region] = NewEndpoint(context.Background(), false, endpointconfig{\n  1926→\t\t\turl:    \"https://aiplatform.googleapis.com\",\n  1927→\t\t\tlabels: []string{\"gcp\", \"gemini\", region},\n  1928→\t\t}, tr, logger, spendFn)"}]},"uuid":"43e0e97f-f931-4286-b54c-4443f5d8c9d8","timestamp":"2025-08-18T03:19:18.048Z","toolUseResult":{"filePath":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","oldString":"\t\tspendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)","newString":"\t\tspendFn := gcp.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)","originalFile":"package main\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"gitea.mediatek.inc/davinci/azure-gateway/awsclaude\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/azure\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/gcp\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/common\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/crowdadapter\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/dailyreset\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/header\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/pkg/middleware\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/poker\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/quota\"\n\trq \"gitea.mediatek.inc/davinci/azure-gateway/request_queue\"\n\tAPIV1 \"gitea.mediatek.inc/davinci/azure-gateway/router/api/v1\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/router/auth\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/service/azurebingsearch\"\n\t\"gitea.mediatek.inc/davinci/azure-gateway/service/user\"\n\n\t_ \"gitea.mediatek.inc/davinci/azure-gateway/docs\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n\tv4 \"github.com/aws/aws-sdk-go-v2/aws/signer/v4\"\n\t\"github.com/essentialkaos/go-crowd/v3\"\n\t\"github.com/gin-contrib/requestid\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/uuid\"\n\t\"github.com/joho/godotenv\"\n\t\"github.com/pkoukk/tiktoken-go\"\n\ttiktoken_loader \"github.com/pkoukk/tiktoken-go-loader\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\t\"github.com/redis/rueidis\"\n\t\"github.com/redis/rueidis/rueidisaside\"\n\tswaggerFiles \"github.com/swaggo/files\"\n\tginSwagger \"github.com/swaggo/gin-swagger\"\n\t\"golang.org/x/exp/slog\"\n\t\"golang.org/x/oauth2/google\"\n)\n\n// UserTokenRequest represents a request to generate a user token with a specified expiration time.\n// ExpirationHours specifies the number of hours the token will be valid for and is a required field.\ntype UserTokenRequest struct {\n\tExpirationHours int             `json:\"expirationHours\" binding:\"required\"`\n\tPayload         *map[string]any `json:\"payload\"`\n}\n\ntype UserLoginRequest struct {\n\tUserTokenRequest\n\tUsername string `json:\"username\" binding:\"required\"`\n\tPassword string `json:\"password\" binding:\"required\"`\n}\n\n// AoaiResp represents the response structure from the API.\n// It contains usage information about the tokens consumed during the request.\ntype AoaiResp struct {\n\tUsage struct {\n\t\t// PromptTokens represents the number of tokens used in the prompt.\n\t\t// This field is used in the original response format.\n\t\tPromptTokens int `json:\"prompt_tokens\"`\n\n\t\t// CompletionTokens represents the number of tokens used in the completion.\n\t\t// This field is used in the original response format.\n\t\tCompletionTokens int `json:\"completion_tokens\"`\n\n\t\t// InputTokens represents the number of tokens used in the input.\n\t\t// This field is used in the new response format.\n\t\tInputTokens int `json:\"input_tokens\"`\n\n\t\t// OutputTokens represents the number of tokens used in the output.\n\t\t// This field is used in the new response format.\n\t\tOutputTokens int `json:\"output_tokens\"`\n\t} `json:\"usage\"`\n}\n\ntype DalleReq struct {\n\tN int `json:\"n\"`\n}\n\ntype ResourceConfig struct {\n\tURL    string `json:\"url\"`\n\tKey    string `json:\"key\"`\n\tSecret string `json:\"secret\"`\n\tRegion string `json:\"region\"`\n\tWeight int    `json:\"weight\"`\n}\n\ntype Provider string\n\nvar (\n\tClaudeV3Provider = Provider(\"anthropic.claude-v3\")\n\tOpenAIProvider   = Provider(\"openai\")\n)\n\ntype DispatchConfig struct {\n\tProvider Provider `json:\"provider\"`\n\tModel    string   `json:\"model\"`\n\tPrice    struct {\n\t\tPrompt     int `json:\"prompt\"`\n\t\tCompletion int `json:\"completion\"`\n\t\tDalleN     int `json:\"dalleN\"`\n\t} `json:\"price\"`\n\tResources map[string]ResourceConfig `json:\"resources\"`\n}\n\nfunc checkInCrowdGroup(crowdapi crowdadapter.Adapter, list, uid string) (int, InListResp) {\n\tif _, ok := crowdapi.(*crowdadapter.Empty); ok {\n\t\treturn http.StatusOK, InListResp{In: true}\n\t}\n\tif uid == \"\" || list == \"\" {\n\t\treturn http.StatusBadRequest, InListResp{Reason: \"uid and list should not be empty\"}\n\t}\n\tif strings.Contains(uid, \"@\") {\n\t\tusers, err := crowdapi.SearchUsers(context.Background(), \"email=\"+uid, crowdadapter.DefaultLimit)\n\t\tif err != nil {\n\t\t\treturn http.StatusInternalServerError, InListResp{Reason: err.Error()}\n\t\t}\n\t\tif len(users) == 0 {\n\t\t\treturn http.StatusNotFound, InListResp{Reason: fmt.Sprintf(\"user not found: %q\", uid)}\n\t\t}\n\t\tuid = users[0].Name\n\t}\n\tgroups, err := crowdapi.GetUserNestedGroups(context.Background(), uid, crowdadapter.DefaultLimit)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, InListResp{Reason: err.Error()}\n\t}\n\tfor _, group := range groups {\n\t\tif group.Name == list {\n\t\t\treturn http.StatusOK, InListResp{In: true}\n\t\t}\n\t}\n\treturn http.StatusOK, InListResp{In: false}\n}\n\nfunc URL(target string) *url.URL {\n\tpurl, err := url.Parse(target)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn purl\n}\n\nvar buffers sync.Pool\n\nfunc NewTeeBufReader(r io.ReadCloser, done func(string)) *TeeBufReader {\n\treturn &TeeBufReader{r: r, w: buffers.Get().(*bytes.Buffer), done: done}\n}\n\ntype TeeBufReader struct {\n\tr    io.ReadCloser\n\tw    *bytes.Buffer\n\tdone func(buf string)\n}\n\nfunc (t *TeeBufReader) Read(p []byte) (n int, err error) {\n\tif t.r == nil {\n\t\treturn 0, io.EOF\n\t}\n\tn, err = t.r.Read(p)\n\tif n > 0 {\n\t\tif n, err := t.w.Write(p[:n]); err != nil {\n\t\t\treturn n, err\n\t\t}\n\t}\n\treturn\n}\n\nfunc (t *TeeBufReader) Close() (err error) {\n\tbs := t.w.Bytes()\n\tt.done(*(*string)(unsafe.Pointer(&bs)))\n\tt.w.Reset()\n\tbuffers.Put(t.w)\n\tif t.r != nil {\n\t\treturn t.r.Close()\n\t}\n\treturn nil\n}\n\ntype LoggingTransport struct {\n\tTransport http.RoundTripper\n\tlogger    *slog.Logger\n\tqueue     *rq.RequestQueue\n\tendpoint  *endpoint\n\tspendFn   common.SpendFn\n\trewrite   func(pr *http.Request) (toproxy bool)\n\treqCount  atomic.Int64\n\trespCount atomic.Int64\n\tlastReset atomic.Int64\n}\n\n// ResetCounters resets reqCount, respCount, and lastReset for daily reset.\nfunc (t *LoggingTransport) ResetCounters() {\n\tt.reqCount.Store(0)\n\tt.respCount.Store(0)\n\tt.lastReset.Store(time.Now().Unix())\n}\n\ntype HeaderLog struct {\n\tKey string `json:\"key\"`\n\tVal string `json:\"val\"`\n}\n\nfunc ToHeaderLogs(hdrs http.Header, apiVersion, dst string, code, chunk, priority, estCost int, ttfb, latency time.Duration) (hl []HeaderLog) {\n\tif code > 0 {\n\t\thl = make([]HeaderLog, 0, len(hdrs)+8)\n\t\thl = append(hl, HeaderLog{Key: \"Status\", Val: strconv.Itoa(code)})\n\t} else {\n\t\thl = make([]HeaderLog, 0, len(hdrs)+7)\n\t}\n\tif dst != \"\" {\n\t\thl = append(hl, HeaderLog{Key: \"Dst\", Val: dst})\n\t}\n\tif apiVersion != \"\" {\n\t\thl = append(hl, HeaderLog{Key: \"ApiVer\", Val: apiVersion})\n\t}\n\thl = append(hl, HeaderLog{Key: \"Cost\", Val: strconv.Itoa(estCost)})\n\thl = append(hl, HeaderLog{Key: \"Chunk\", Val: strconv.Itoa(chunk)})\n\thl = append(hl, HeaderLog{Key: \"Priority\", Val: strconv.Itoa(priority)})\n\thl = append(hl, HeaderLog{Key: \"TTFB\", Val: strconv.Itoa(int(ttfb.Milliseconds()))})\n\thl = append(hl, HeaderLog{Key: \"LAT\", Val: strconv.Itoa(int(latency.Milliseconds()))})\n\n\tfor k, vs := range hdrs {\n\t\tif lh := strings.ToLower(k); lh == \"authorization\" || lh == \"api-key\" || lh == \"x-forward-key\" {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, v := range vs {\n\t\t\thl = append(hl, HeaderLog{Key: k, Val: v})\n\t\t}\n\t}\n\treturn hl\n}\n\nfunc LogCheckBanword(body string, banwords []*regexp.Regexp) error {\n\tfor _, ban := range banwords {\n\t\tif i := ban.FindStringIndex(body); i != nil {\n\t\t\treturn fmt.Errorf(\"forbidden word %q at index %d\", ban, i[0])\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc chunks(in string, n int) (out []string) {\n\tfor len(in) > n {\n\t\tout = append(out, in[:n])\n\t\tin = in[n:]\n\t}\n\tout = append(out, in)\n\treturn\n}\n\nvar (\n\tttfbHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"ttfb_seconds\",\n\t\tHelp:    \"Time to first byte of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tttfbHistogramProxy = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"proxy_ttfb_seconds\",\n\t\tHelp:    \"Time to first byte of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tlatencyHistogram = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"duration_seconds\",\n\t\tHelp:    \"Latency of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tlatencyHistogramProxy = promauto.NewHistogramVec(prometheus.HistogramOpts{\n\t\tName:    \"proxy_duration_seconds\",\n\t\tHelp:    \"Latency of azure\",\n\t\tBuckets: prometheus.ExponentialBuckets(0.8, 1.3, 30),\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tcostGuage = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"est_costs\",\n\t\tHelp: \"Estimated costs of azure. 100,000,000 is $1\",\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tsuccessRateGauge = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"success_rates\",\n\t\tHelp: \"Rate of successful requests\",\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tendpointStatusGauge = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"endpoint_status\",\n\t\tHelp: \"endpoint status\",\n\t}, []string{\"svc\", \"name\", \"dst\"})\n\tendpointThresholdGauge = promauto.NewGaugeVec(prometheus.GaugeOpts{\n\t\tName: \"endpoint_threshold\",\n\t\tHelp: \"endpoint threshold\",\n\t}, []string{\"svc\", \"name\"})\n)\n\nfunc (t *LoggingTransport) RoundTrip(req *http.Request) (resp *http.Response, err error) {\n\tif req.ContentLength > 67108864 { // 64MB\n\t\treq.Body.Close()\n\t\tmsg := \"request body too large\"\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\treturn &http.Response{\n\t\t\tStatusCode:    http.StatusBadRequest,\n\t\t\tBody:          io.NopCloser(strings.NewReader(msg)),\n\t\t\tContentLength: int64(len(msg)),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}, nil\n\t}\n\n\tapiVersion := req.URL.Query().Get(\"api-version\")\n\n\ttoproxy := t.rewrite(req)\n\n\tvar priority int\n\tvar logger *slog.Logger\n\tvar banwords []*regexp.Regexp\n\tvar domain string\n\tif cv := req.Context().Value(\"lc\"); cv != nil {\n\t\tlc := cv.(*common.LoggingContext)\n\t\tpriority = lc.Priority\n\t\tbanwords = lc.Banwords\n\t\tdomain = lc.Domain\n\t\tlogger = t.logger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", req.Header.Get(\"X-Request-ID\"))\n\t} else {\n\t\tlogger = slog.New(slog.NewJSONHandler(io.Discard, nil))\n\t}\n\n\treqbuf := buffers.Get().(*bytes.Buffer)\n\tdefer func() {\n\t\treqbuf.Reset()\n\t\tbuffers.Put(reqbuf)\n\t}()\n\n\tif req.Body != nil && !t.endpoint.config.noreqlog {\n\t\t_, err = io.Copy(reqbuf, req.Body)\n\t\treq.Body.Close()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treqbytes := reqbuf.Bytes()\n\treqcontent := *(*string)(unsafe.Pointer(&reqbytes))\n\treqchunks := chunks(reqcontent, 4000000)\n\n\tdst := t.endpoint.config.labels[len(t.endpoint.config.labels)-1]\n\n\tif err = LogCheckBanword(reqcontent, banwords); err != nil {\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\tif !common.IsAirgappedDomain(domain) {\n\t\t\tfor c, chunk := range reqchunks {\n\t\t\t\tlogger.Info(req.URL.Path, \"req\", chunk, \"hdrs\", ToHeaderLogs(req.Header, apiVersion, dst, 0, c, priority, 0, 0, 0), \"ia\", err.Error())\n\t\t\t}\n\t\t\tlogger.Info(req.URL.Path, \"resp\", err.Error(), \"hdrs\", ToHeaderLogs(header, apiVersion, dst, http.StatusForbidden, 0, priority, 0, 0, 0))\n\t\t}\n\t\treturn &http.Response{\n\t\t\tStatusCode:    http.StatusForbidden,\n\t\t\tBody:          io.NopCloser(strings.NewReader(err.Error())),\n\t\t\tContentLength: int64(len(err.Error())),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}, nil\n\t}\n\tlc, ok := req.Context().Value(\"lc\").(*common.LoggingContext)\n\tif !ok || lc == nil {\n\t\treturn nil, errors.New(\"invalid logging context: not *common.LoggingContext\")\n\t}\n\tif lc.UID == nil {\n\t\treturn nil, errors.New(\"missing UID in logging context\")\n\t}\n\tuser := *lc.UID\n\testimate, remain, err := t.spendFn.Pre(user, domain, req, reqcontent)\n\n\treqSeq := t.reqCount.Add(1)\n\tfor c, chunk := range reqchunks {\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"req\", chunk,\n\t\t\t\"hdrs\", ToHeaderLogs(req.Header, apiVersion, dst, 0, c, priority, estimate, 0, 0),\n\t\t\t\"req_seq\", reqSeq,\n\t\t)\n\t}\n\n\tif err != nil {\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\trespSeq := t.respCount.Add(1)\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"resp\", err.Error(),\n\t\t\t\"hdrs\", ToHeaderLogs(header, apiVersion, dst, http.StatusInternalServerError, 0, priority, -1*estimate, 0, 0),\n\t\t\t\"resp_seq\", respSeq,\n\t\t\t\"rel_req_seq\", reqSeq,\n\t\t)\n\t\tif err == ErrTokenLimit {\n\t\t\treturn &http.Response{\n\t\t\t\tStatusCode:    http.StatusBadRequest,\n\t\t\t\tBody:          io.NopCloser(strings.NewReader(err.Error())),\n\t\t\t\tContentLength: int64(len(err.Error())),\n\t\t\t\tHeader:        header,\n\t\t\t\tRequest:       req,\n\t\t\t\tProto:         req.Proto,\n\t\t\t}, nil\n\t\t}\n\t\treturn &http.Response{\n\t\t\tStatusCode:    http.StatusInternalServerError,\n\t\t\tBody:          io.NopCloser(strings.NewReader(err.Error())),\n\t\t\tContentLength: int64(len(err.Error())),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}, nil\n\t}\n\n\tif remain < 0 {\n\t\tmsg := \"your daily quota is exhausted, please contact your admin if you want more quota\"\n\t\tif se := os.Getenv(\"SUPPORT_EMAIL\"); len(se) > 0 {\n\t\t\tmsg = fmt.Sprintf(\"your daily quota is exhausted, please contact %s if you want more quota\", se)\n\t\t}\n\n\t\theader := http.Header{}\n\t\theader.Set(\"Content-Type\", \"text/plain\")\n\t\trespSeq := t.respCount.Add(1)\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"resp\", msg,\n\t\t\t\"hdrs\", ToHeaderLogs(header, apiVersion, dst, http.StatusForbidden, 0, priority, -1*estimate, 0, 0),\n\t\t\t\"resp_seq\", respSeq,\n\t\t\t\"rel_req_seq\", reqSeq,\n\t\t)\n\t\tresp := &http.Response{\n\t\t\tStatusCode:    http.StatusForbidden,\n\t\t\tBody:          io.NopCloser(strings.NewReader(msg)),\n\t\t\tContentLength: int64(len(msg)),\n\t\t\tHeader:        header,\n\t\t\tRequest:       req,\n\t\t\tProto:         req.Proto,\n\t\t}\n\t\tt.spendFn.Post(user, resp, \"\", estimate)\n\n\t\tif t.spendFn.Alert != nil {\n\t\t\tgo t.spendFn.Alert(user, logger)\n\t\t}\n\t\treturn resp, nil\n\t}\n\n\tif !t.endpoint.config.noreqlog {\n\t\treq.Body = io.NopCloser(bytes.NewReader(reqbytes))\n\t}\n\n\tt1 := time.Now()\n\tcostGuage.WithLabelValues(t.endpoint.config.labels...).Add(float64(estimate))\n\n\t// avoid azure returning HTTP 413 header too large\n\treq.Header.Del(\"X-Asst-Desc\")\n\treq.Header.Del(\"X-Asst-Id\")\n\treq.Header.Del(\"X-Asst-Name\")\n\treq.Header.Del(\"X-Thread-Id\")\n\treq.Header.Del(\"X-Stainless-Package-Version\")\n\treq.Header.Del(\"X-Stainless-Lang\")\n\treq.Header.Del(\"X-Stainless-Os\")\n\treq.Header.Del(\"X-Stainless-Runtime\")\n\treq.Header.Del(\"X-Stainless-Arch\")\n\n\tif resp, err = t.Transport.RoundTrip(req); err == nil {\n\t\tttfb := time.Since(t1)\n\t\tif toproxy {\n\t\t\tttfbHistogramProxy.WithLabelValues(t.endpoint.config.labels...).Observe(float64(ttfb.Microseconds() / 1e6))\n\t\t} else {\n\t\t\tttfbHistogram.WithLabelValues(t.endpoint.config.labels...).Observe(float64(ttfb.Microseconds() / 1e6))\n\t\t}\n\n\t\tt.endpoint.recordStatus(resp, ttfb, logger)\n\n\t\treqPath := req.URL.Path\n\t\tresp.Body = NewTeeBufReader(resp.Body, func(b string) {\n\t\t\tfullLatency := time.Since(t1)\n\t\t\tif toproxy {\n\t\t\t\tlatencyHistogramProxy.WithLabelValues(t.endpoint.config.labels...).Observe(float64(fullLatency.Microseconds() / 1e6))\n\t\t\t} else {\n\t\t\t\tlatencyHistogram.WithLabelValues(t.endpoint.config.labels...).Observe(float64(fullLatency.Microseconds() / 1e6))\n\t\t\t}\n\n\t\t\t// Check if the response data is in gzip format\n\t\t\tisGzip := false\n\t\t\tif len(b) > 2 && b[0] == 0x1f && b[1] == 0x8b {\n\t\t\t\tisGzip = true\n\t\t\t}\n\n\t\t\tif isGzip {\n\t\t\t\t// Attempt to decode gzip data\n\t\t\t\treader := bytes.NewReader([]byte(b))\n\t\t\t\tgzipReader, err := gzip.NewReader(reader)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Error(\"Failed to create gzip reader:\", err)\n\t\t\t\t} else {\n\t\t\t\t\tdecompressedData, err := io.ReadAll(gzipReader)\n\t\t\t\t\tgzipReader.Close()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogger.Error(\"Failed to decompress gzip data:\", err)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = string(decompressedData)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trespchunks := chunks(b, 4000000)\n\t\t\testimate = t.spendFn.Post(user, resp, b, estimate)\n\t\t\tcostGuage.WithLabelValues(t.endpoint.config.labels...).Add(float64(estimate))\n\n\t\t\trespSeq := t.respCount.Add(1)\n\t\t\tfor c, chunk := range respchunks {\n\t\t\t\tlogger.Info(reqPath,\n\t\t\t\t\t\"resp\", chunk,\n\t\t\t\t\t\"hdrs\", ToHeaderLogs(resp.Header, apiVersion, dst, resp.StatusCode, c, priority, estimate, ttfb, fullLatency),\n\t\t\t\t\t\"resp_seq\", respSeq,\n\t\t\t\t\t\"rel_req_seq\", reqSeq,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\tif op := resp.Header.Get(\"Operation-Location\"); op != \"\" {\n\t\t\tif purl, err := url.Parse(op); err == nil {\n\t\t\t\tif envstr(\"DOMAIN_CHECK\", \"oa\") == \"oa\" {\n\t\t\t\t\tpurl.Host = \"gitea.mediatek.inc/davinci/azure-gateway.mediatek.inc\"\n\t\t\t\t} else {\n\t\t\t\t\tpurl.Host = \"mlop-azure-rddmz.mediatek.inc\"\n\t\t\t\t}\n\t\t\t\tresp.Header.Set(\"Operation-Location\", purl.String())\n\t\t\t}\n\t\t}\n\t} else {\n\t\tt.endpoint.recordStatus(nil, 0, logger)\n\t\tttfb := time.Since(t1)\n\t\theader := http.Header{}\n\t\trespSeq := t.respCount.Add(1)\n\t\tlogger.Info(req.URL.Path,\n\t\t\t\"resp\", err.Error(),\n\t\t\t\"hdrs\", ToHeaderLogs(header, apiVersion, dst, 500, 0, priority, -1*estimate, ttfb, ttfb),\n\t\t\t\"resp_seq\", respSeq,\n\t\t\t\"rel_req_seq\", reqSeq,\n\t\t)\n\t\tt.spendFn.Post(user, resp, \"\", estimate)\n\t}\n\n\tif t.endpoint.config.ptu && resp != nil && (resp.StatusCode == 429 || resp.StatusCode == 500 || resp.StatusCode == 502) {\n\t\tvar condidate *endpoint\n\t\tretry, _ := strconv.ParseInt(req.Header.Get(\"X-PTU-RETRY\"), 10, 64)\n\t\tretry++\n\t\treq.Header.Set(\"X-PTU-RETRY\", strconv.FormatInt(retry, 10))\n\t\tif retry <= 2 {\n\t\t\tif after, _ := strconv.ParseInt(resp.Header.Get(\"Retry-After-Ms\"), 10, 64); after <= 1500 {\n\t\t\t\tif after == 0 {\n\t\t\t\t\tafter = 500\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * time.Duration(after))\n\t\t\t\tcondidate = t.endpoint\n\t\t\t\tgoto RETRY\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tallOthers := t.endpoint.othersFn()\n\t\t\tcondidates := make([]*endpoint, 0, len(allOthers))\n\t\t\tfor _, e := range allOthers {\n\t\t\t\tif e == t.endpoint {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif e.isOnline() {\n\t\t\t\t\tcondidates = append(condidates, e)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(condidates) > 0 {\n\t\t\t\tcondidate = condidates[rand.Intn(len(condidates))]\n\t\t\t}\n\t\t}\n\tRETRY:\n\t\tif condidate != nil && condidate.proxy.Transport != nil {\n\t\t\tio.ReadAll(resp.Body)\n\t\t\tresp.Body.Close()\n\t\t\treq.Body = io.NopCloser(bytes.NewReader(reqbytes))\n\t\t\tresp, err = condidate.proxy.Transport.RoundTrip(req)\n\t\t}\n\t}\n\n\treturn resp, err\n}\n\ntype InListResp struct {\n\tIn     bool   `json:\"in\"`\n\tReason string `json:\"reason\"`\n}\n\nfunc (p InListResp) ToString() string {\n\tbs, _ := json.Marshal(p)\n\treturn *(*string)(unsafe.Pointer(&bs))\n}\n\ntype InListReq struct {\n\tUid  string `json:\"uid\"`\n\tList string `json:\"list\"`\n}\n\nfunc (p InListReq) ToString() string {\n\tbs, _ := json.Marshal(p)\n\treturn *(*string)(unsafe.Pointer(&bs))\n}\n\ntype endpoint struct {\n\tconfig   endpointconfig\n\tproxy    *httputil.ReverseProxy\n\tothersFn func() []*endpoint\n\tsuccess  uint64\n\ttotal    uint64\n\tdisable  int32\n}\n\nfunc (e *endpoint) isOnline() bool {\n\treturn atomic.LoadInt32(&e.disable) == 0\n}\n\nfunc (e *endpoint) online() {\n\tatomic.CompareAndSwapInt32(&e.disable, 1, 0)\n}\n\nfunc (e *endpoint) offline() bool {\n\tt := atomic.CompareAndSwapInt32(&e.disable, 0, 1)\n\tif t {\n\t\te.reset()\n\t}\n\treturn t\n}\n\nfunc (e *endpoint) reset() {\n\tatomic.StoreUint64(&e.success, 1)\n\tatomic.StoreUint64(&e.total, 1)\n}\n\nfunc (e *endpoint) recordStatus(resp *http.Response, ttfb time.Duration, logger *slog.Logger) (rate float64) {\n\tif logger != nil {\n\t\tlogger = logger.With(\"rqid\", uuid.New().String())\n\t}\n\tif e.othersFn == nil {\n\t\treturn\n\t}\n\tif e.config.judgeFn == nil || (resp != nil && e.config.judgeFn(resp, ttfb)) {\n\t\tatomic.AddUint64(&e.success, 1)\n\t\tif atomic.AddUint64(&e.total, 1) == 61 {\n\t\t\te.reset()\n\t\t}\n\t} else {\n\t\tatomic.AddUint64(&e.total, 1)\n\t}\n\n\ttotal := uint64(0)\n\tsuccess := uint64(0)\n\tendpoints := e.othersFn()\n\trates := make([]float64, 0, len(endpoints))\n\n\tj := 0\n\tfor _, oe := range endpoints {\n\t\tif !oe.isOnline() && oe != e {\n\t\t\tcontinue\n\t\t}\n\t\tptotal := atomic.LoadUint64(&oe.total)\n\t\tpsuccess := atomic.LoadUint64(&oe.success)\n\t\tif ptotal < psuccess {\n\t\t\tptotal = psuccess\n\t\t}\n\t\ttotal += ptotal\n\t\tsuccess += psuccess\n\t\trates = append(rates, float64(psuccess)/float64(ptotal))\n\t\tif oe == e {\n\t\t\tj = len(rates) - 1\n\t\t}\n\t}\n\tif total == 0 {\n\t\treturn\n\t}\n\n\tmean := float64(success) / float64(total)\n\tstdv := float64(0)\n\tfor _, r := range rates {\n\t\tstdv += math.Pow((r - mean), 2)\n\t}\n\tstdv = math.Sqrt(stdv / float64(len(rates)))\n\tthreshold := mean - 1.9*stdv\n\tif threshold > 0.9 {\n\t\tthreshold = 0.9\n\t}\n\tendpointThresholdGauge.WithLabelValues(e.config.labels[:2]...).Set(threshold)\n\n\tif (!e.config.ptu && rates[j] < threshold) && e.config.testReqFn != nil && e.offline() {\n\t\tvar header http.Header\n\t\tvar statusCode int\n\t\tif resp != nil {\n\t\t\theader = resp.Header\n\t\t\tstatusCode = resp.StatusCode\n\t\t}\n\t\tlogger.Info(\"endpoint_off\", \"req\", e.config.labels, \"hdrs\", ToHeaderLogs(header, \"\", \"\", statusCode, 0, 0, 0, 0, 0))\n\t\tgo func(threshold float64, testReqFn func() *http.Request) {\n\t\t\tfor i := 0; ; i++ {\n\t\t\t\tres := httptest.NewRecorder()\n\t\t\t\te.proxy.ServeHTTP(res, testReqFn())\n\t\t\t\tresp := res.Result()\n\t\t\t\tio.ReadAll(resp.Body)\n\t\t\t\tresp.Body.Close()\n\t\t\t\tptotal := atomic.LoadUint64(&e.total)\n\t\t\t\tpsuccess := atomic.LoadUint64(&e.success)\n\t\t\t\tif ptotal < psuccess {\n\t\t\t\t\tptotal = psuccess\n\t\t\t\t}\n\t\t\t\trate := float64(psuccess) / float64(ptotal)\n\t\t\t\tif rate > threshold {\n\t\t\t\t\te.online()\n\t\t\t\t\tlogger.Info(\"endpoint_on\", \"req\", e.config.labels, \"hdrs\", ToHeaderLogs(resp.Header, \"\", \"\", resp.StatusCode, i, 0, 0, 0, 0))\n\t\t\t\t\tsuccessRateGauge.WithLabelValues(e.config.labels...).Set(rate)\n\t\t\t\t\tendpointStatusGauge.WithLabelValues(e.config.labels...).Set(1)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t}\n\t\t}(threshold, e.config.testReqFn)\n\t}\n\n\tif e.config.judgeFn != nil {\n\t\tsuccessRateGauge.WithLabelValues(e.config.labels...).Set(rates[j])\n\t\tif e.isOnline() {\n\t\t\tendpointStatusGauge.WithLabelValues(e.config.labels...).Set(1)\n\t\t} else {\n\t\t\tendpointStatusGauge.WithLabelValues(e.config.labels...).Set(0)\n\t\t}\n\t}\n\treturn rate\n}\n\ntype dispatcher struct {\n\tonline   []*endpoint\n\tfallback *endpoint\n\tweight   int\n}\n\nfunc (d *dispatcher) pick(req *http.Request) *endpoint {\n\tif len(d.online) == 0 {\n\t\treturn d.fallback\n\t}\n\n\tlc, ok := req.Context().Value(\"lc\").(*common.LoggingContext)\n\tvar user string\n\tif !ok || lc == nil {\n\t\tpanic(\"invalid logging context: not *common.LoggingContext\")\n\t}\n\tif lc.UID != nil {\n\t\tuser = *lc.UID\n\t}\n\n\tif dst := req.Header.Get(\"X-DST\"); dst != \"\" {\n\t\tfor _, e := range d.online {\n\t\t\tif strings.Contains(e.config.url, dst) {\n\t\t\t\treturn e\n\t\t\t}\n\t\t}\n\t}\n\n\tc := 0\n\tw := rand.Intn(d.weight)\n\n\tfor _, e := range d.online {\n\t\tif e.config.ptu {\n\t\t\tif len(ptuVIPs) == 0 || ptuVIPs[user] {\n\t\t\t\treturn e\n\t\t\t}\n\t\t\tif e.isOnline() {\n\t\t\t\treturn e\n\t\t\t}\n\t\t}\n\t\tif c += e.config.weight; w < c {\n\t\t\tif !e.isOnline() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn e\n\t\t}\n\t}\n\n\treturn d.fallback\n}\n\nfunc (d *dispatcher) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\t// Check if request context is cancelled before proceeding\n\tselect {\n\tcase <-req.Context().Done():\n\t\t// Context cancelled - likely client disconnection\n\t\tlogger.Warn(\"Request context cancelled in dispatcher\",\n\t\t\t\"path\", req.URL.Path,\n\t\t\t\"error\", req.Context().Err(),\n\t\t\t\"method\", req.Method)\n\t\treturn\n\tdefault:\n\t\t// Context is still active, proceed\n\t}\n\n\tendpoint := d.pick(req)\n\tif endpoint == nil || endpoint.proxy == nil {\n\t\thttp.Error(rw, \"Service temporarily unavailable\", http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\n\t// Log the proxy handoff for debugging\n\tlogger.Debug(\"Dispatcher forwarding to endpoint\",\n\t\t\"path\", req.URL.Path,\n\t\t\"endpoint\", endpoint.config.labels)\n\n\t// Check once more before calling the reverse proxy\n\tselect {\n\tcase <-req.Context().Done():\n\t\tlogger.Warn(\"Request context cancelled just before proxy\",\n\t\t\t\"path\", req.URL.Path,\n\t\t\t\"error\", req.Context().Err())\n\t\treturn\n\tdefault:\n\t\tendpoint.proxy.ServeHTTP(rw, req)\n\t}\n}\n\nvar (\n\tproxyUsers map[string]bool\n\tptuVIPs    map[string]bool\n)\n\nfunc init() {\n\tbuffers = sync.Pool{New: func() any { return bytes.NewBuffer(make([]byte, 0, 4096)) }}\n\tproxyUsers = make(map[string]bool, 20)\n\tfor _, u := range strings.Split(os.Getenv(\"PROXY_USERS\"), \",\") {\n\t\tif u = strings.TrimSpace(u); u != \"\" {\n\t\t\tproxyUsers[strings.ToLower(u)] = true\n\t\t\tproxyUsers[strings.ToUpper(u)] = true\n\t\t}\n\t}\n\tptuVIPs = make(map[string]bool, 20)\n\tfor _, u := range strings.Split(os.Getenv(\"PTU_VIPS\"), \",\") {\n\t\tif u = strings.TrimSpace(u); u != \"\" {\n\t\t\tptuVIPs[strings.ToLower(u)] = true\n\t\t\tptuVIPs[strings.ToUpper(u)] = true\n\t\t}\n\t}\n}\n\nvar globalDailyResetController = dailyreset.New()\n\nfunc NewEndpoint(ctx context.Context, useproxy bool, config endpointconfig, tr http.RoundTripper, logger *slog.Logger, spendfn common.SpendFn) *endpoint {\n\tvar proxy, proxyKey string\n\tif useproxy {\n\t\tproxy = envstr(\"AZURE_PROXY_IP\", \"\")\n\t\tproxyKey = envstr(\"AZURE_PROXY_KEY\", envmust(\"JWT_SECRET_KEY\"))\n\t}\n\n\tdst := URL(config.url)\n\te := &endpoint{config: config, total: 1, success: 1}\n\te.proxy = httputil.NewSingleHostReverseProxy(dst)\n\ttransport := &LoggingTransport{\n\t\tTransport: tr,\n\t\tlogger:    logger,\n\t\tqueue:     rq.NewRequestQueue(),\n\t\tspendFn:   spendfn,\n\t\tendpoint:  e,\n\t\trewrite: func(pr *http.Request) (toproxy bool) {\n\t\t\tif proxy != \"\" {\n\t\t\t\tpr.Header.Set(\"X-Forward-To\", fmt.Sprintf(\"%s://%s\", dst.Scheme, dst.Host))\n\t\t\t\tpr.Header.Set(\"X-Forward-Key\", proxyKey)\n\t\t\t\tpr.URL.Scheme = \"http\"\n\t\t\t\tpr.URL.Host = proxy\n\t\t\t\tpr.Host = proxy\n\t\t\t\ttoproxy = true\n\t\t\t} else {\n\t\t\t\tpr.Header.Del(\"X-Forward-To\")\n\t\t\t\tpr.Header.Del(\"X-Forward-Key\")\n\t\t\t\tpr.URL.Scheme = dst.Scheme\n\t\t\t\tpr.URL.Host = dst.Host\n\t\t\t\tpr.Host = dst.Host\n\t\t\t\ttoproxy = false\n\t\t\t}\n\t\t\tpr.Header.Del(\"Authorization\")\n\t\t\tpr.Header.Del(\"api-key\")\n\t\t\tfor k, v := range config.hdrs {\n\t\t\t\tpr.Header.Set(k, v)\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t}\n\n\t// Initialize lastReset with current time\n\ttransport.lastReset.Store(time.Now().Unix())\n\tglobalDailyResetController.Register(transport)\n\n\te.proxy.Transport = transport\n\treturn e\n}\n\nfunc NewDaviciShareServerFunc(storeApiUrl, davinciUrl string) func(*gin.Context) {\n\tp := httputil.NewSingleHostReverseProxy(URL(storeApiUrl))\n\treturn func(c *gin.Context) {\n\t\tc.Request.Header.Set(\"X-Mail-Url\", davinciUrl)\n\t\tc.Request.URL.Path = \"/api/share/shareChat\"\n\t\tp.ServeHTTP(c.Writer, c.Request)\n\t}\n}\n\ntype endpointconfig struct {\n\tweight   int\n\turl      string\n\thdrs     map[string]string\n\tnoreqlog bool\n\tptu      bool\n\tlabels   []string\n\n\tjudgeFn   func(resp *http.Response, ttfb time.Duration) bool\n\ttestReqFn func() *http.Request\n}\n\nfunc NewDispatcher(tr http.RoundTripper, logger *slog.Logger, useproxy bool, spendfn common.SpendFn, configs []endpointconfig) *dispatcher {\n\td := &dispatcher{\n\t\tonline: make([]*endpoint, 0, len(configs)),\n\t}\n\tif len(configs) == 0 {\n\t\treturn d\n\t}\n\tfor _, c := range configs {\n\t\td.online = append(d.online, NewEndpoint(context.Background(), useproxy, c, tr, logger, spendfn))\n\t\td.weight += c.weight\n\t}\n\tfor _, e := range d.online {\n\t\te.othersFn = func() []*endpoint {\n\t\t\treturn d.online\n\t\t}\n\t}\n\td.fallback = d.online[len(d.online)-1]\n\treturn d\n}\n\n// aoaiWithKey initializes an endpoint configuration for Azure OpenAI API calls.\n// It constructs the configuration based on the provided parameters and the model type.\n//\n// If the url parameter is non-empty, the function uses it directly with an \"Authorization\" header.\n// Otherwise, it builds a base URL from the name and configures headers with the provided API key.\n//\n// For models containing \"dalle\" (case-insensitive), it returns a configuration with an \"api-key\" header\n// without setting any deadline or special performance testing behavior.\n//\n// For other models, it sets a default deadline of 60 seconds, but extends it to 150 seconds for models\n// ending with \"32k\", \"16k\", or containing \"gpt-4\". It also determines if the special \"ptu\" mode should\n// be enabled when name equals \"aideopenaijapaneast\" and model equals \"aide-gpt-4o\".\n//\n// In ptu mode, the function sets a judge function that always returns true and defines\n// a specific test request targeting the chat completions endpoint.\n// For general cases, a judge function is defined to check that the response status is neither 429 nor\n// in the 500 range, and that the time-to-first-byte (ttfb) is below the set deadline.\n// The test request function is adjusted based on the model (e.g., using \"completions\" for some models,\n// \"embeddings\" for others, or \"chat/completions\" by default).\n//\n// Parameters:\n//\n//\tweight int:\n//\t  The traffic weight assigned to this endpoint.\n//\tname string:\n//\t  The identifier used to construct the base URL if no override URL is provided.\n//\tmodel string:\n//\t  The model variant which affects headers, deadline configuration, and endpoint path.\n//\tkey string:\n//\t  The API key used either as an \"api-key\" or \"Authorization\" header depending on the scenario.\n//\turl string:\n//\t  An optional URL override; if provided, it bypasses the base URL construction.\n//\n// Returns:\n//\n//\tendpointconfig:\n//\t  A structure encompassing the endpoint URL, HTTP headers, associated labels, and the functions\n//\t  (judgeFn and testReqFn) used for response validation and test request generation.\nfunc aoaiWithKey(weight int, name, model, key, url string) endpointconfig {\n\tif url != \"\" {\n\t\treturn endpointconfig{\n\t\t\tweight: weight,\n\t\t\turl:    url,\n\t\t\thdrs:   map[string]string{\"Authorization\": key},\n\t\t\tlabels: []string{\"azure\", model, name},\n\t\t}\n\t}\n\n\tbaseURL := fmt.Sprintf(\"https://%s.openai.azure.com\", name)\n\n\t// If the model contains \"dalle\", no additional deadline or ptu configuration is needed\n\tif strings.Contains(strings.ToLower(model), \"dalle\") {\n\t\treturn endpointconfig{\n\t\t\tweight: weight,\n\t\t\turl:    baseURL,\n\t\t\thdrs:   map[string]string{\"api-key\": key},\n\t\t\tlabels: []string{\"aoai\", model, name},\n\t\t}\n\t}\n\n\t// Set deadline\n\tdeadline := time.Second * 60\n\tif strings.HasSuffix(model, \"32k\") || strings.HasSuffix(model, \"16k\") || strings.Contains(model, \"gpt-4\") {\n\t\tdeadline = time.Second * 150\n\t}\n\n\tptu := name == \"aideopenaijapaneast\" && (model == \"aide-gpt-4.1\")\n\n\t// Create a common configuration\n\tcfg := endpointconfig{\n\t\tptu:    ptu,\n\t\tweight: weight,\n\t\turl:    baseURL,\n\t\thdrs:   map[string]string{\"api-key\": key},\n\t\tlabels: []string{\"aoai\", model, name},\n\t}\n\n\t// If ptu is true, set judgeFn to always return true\n\tif ptu {\n\t\tcfg.judgeFn = func(resp *http.Response, ttfb time.Duration) bool {\n\t\t\treturn true\n\t\t}\n\t\tcfg.testReqFn = func() *http.Request {\n\t\t\tpayload := strings.NewReader(`{\"messages\":[{\"role\": \"user\",\"content\": \"Hi\"}]}`)\n\t\t\treq, err := http.NewRequest(http.MethodPost, fmt.Sprintf(\"%s/openai/deployments/%s/chat/completions?api-version=2024-02-01\", baseURL, model), payload)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\treq.Header.Set(\"api-key\", key)\n\t\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\t\treturn req\n\t\t}\n\t\treturn cfg\n\t}\n\n\t// Define default judgeFn and testReqFn for normal cases\n\tcfg.judgeFn = func(resp *http.Response, ttfb time.Duration) bool {\n\t\treturn resp.StatusCode != 429 && resp.StatusCode < 500 && ttfb < deadline\n\t}\n\tcfg.testReqFn = func() *http.Request {\n\t\tendpoint := \"chat/completions\"\n\t\tpayload := strings.NewReader(`{\"messages\":[{\"role\": \"user\",\"content\": \"Hi\"}]}`)\n\t\tif model == \"aide-davinci-003\" || model == \"aide-code-davinci-002\" {\n\t\t\tendpoint = \"completions\"\n\t\t\tpayload = strings.NewReader(`{\"prompt\": \"Hi\"}`)\n\t\t} else if strings.Contains(model, \"embedding\") {\n\t\t\tendpoint = \"embeddings\"\n\t\t\tpayload = strings.NewReader(`{\"input\": [\"Hi\"]}`)\n\t\t}\n\t\treq, err := http.NewRequest(http.MethodPost, fmt.Sprintf(\"%s/openai/deployments/%s/%s?api-version=2024-02-01\", baseURL, model, endpoint), payload)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treq.Header.Set(\"api-key\", key)\n\t\treq.Header.Set(\"content-type\", \"application/json\")\n\t\treturn req\n\t}\n\n\treturn cfg\n}\n\nfunc aoai(weight int, name, model string) endpointconfig {\n\treturn aoaiWithKey(weight, name, model, envmust(\"AZURE_OPAI_KEY_\"+name), \"\")\n}\n\nfunc aoaiNoReqLog(weight int, name, model string) endpointconfig {\n\tconfig := aoaiWithKey(weight, name, model, envmust(\"AZURE_OPAI_KEY_\"+name), \"\")\n\tconfig.noreqlog = true\n\treturn config\n}\n\nvar (\n\tErrTokenLimit        = errors.New(\"your input exceeds the token limit\")\n\tVisionStreamDisabled = errors.New(\"streaming gpt-4-turbo-vision responses is disabled\")\n\tVisionNotAllowed     = errors.New(\"you are not allowed to use gpt-4-turbo-vision\")\n\tGPT4NotAllowed       = errors.New(\"you are not allowed to use gpt-4\")\n\tDomainNotAllowed     = errors.New(\"you are not allowed to use the model in this domain\")\n)\n\ntype Message struct {\n\tRole    string          `json:\"role\"`\n\tContent json.RawMessage `json:\"content\"`\n}\n\ntype MessageContent struct {\n\tType string `json:\"type\"`\n\tText string `json:\"text\"`\n}\n\nfunc (m Message) HasImages() bool {\n\tvar content []MessageContent\n\tif json.Unmarshal(m.Content, &content) == nil {\n\t\tfor _, c := range content {\n\t\t\tif c.Type == \"image_url\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (m Message) SplitImageMessages() (Message, int) {\n\tif !m.HasImages() {\n\t\treturn m, 0\n\t}\n\tvar oldContents, newContents []MessageContent\n\timageCount := 0\n\tif json.Unmarshal(m.Content, &oldContents) == nil {\n\t\tfor _, c := range oldContents {\n\t\t\tif c.Type == \"image_url\" {\n\t\t\t\timageCount++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewContents = append(newContents, c)\n\t\t}\n\t}\n\tvar newMessage Message\n\tnewMessage.Role = m.Role\n\tnewMessage.Content, _ = json.Marshal(newContents)\n\n\treturn newMessage, imageCount\n}\n\ntype streambody struct {\n\tStream   bool      `json:\"stream\"`\n\tMessages []Message `json:\"messages\"`\n}\n\nfunc (sb streambody) CountToken(encoder *tiktoken.Tiktoken, fallbackTokens int) int {\n\thasImages := false\n\tfor _, m := range sb.Messages {\n\t\tif m.HasImages() {\n\t\t\thasImages = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !hasImages {\n\t\tbody, err := json.Marshal(sb)\n\t\tif err != nil {\n\t\t\treturn fallbackTokens\n\t\t}\n\t\treturn len(encoder.Encode(string(body), nil, nil))\n\t}\n\n\ttotalImageCount := 0\n\tvar textContents []Message\n\tfor _, m := range sb.Messages {\n\t\tif m.HasImages() {\n\t\t\ttextContent, imageCount := m.SplitImageMessages()\n\t\t\ttextContents = append(textContents, textContent)\n\t\t\ttotalImageCount += imageCount\n\t\t} else {\n\t\t\ttextContents = append(textContents, m)\n\t\t}\n\t}\n\n\ttextBody, err := json.Marshal(textContents)\n\tif err != nil {\n\t\treturn fallbackTokens\n\t}\n\ttextToken := len(encoder.Encode(string(textBody), nil, nil))\n\t// https://learn.microsoft.com/en-us/azure/ai-services/openai/overview#image-tokens-gpt-4-turbo-with-vision\n\t// max image token = 170 * 8 + 85 = 1445\n\timageToken := 1445 * totalImageCount\n\n\treturn textToken + imageToken\n}\n\nfunc aoaiSpend(model string, capgpt4 bool, crowdapi crowdadapter.Adapter, qc quota.QuotaClient, smtpserver string, encoder *tiktoken.Tiktoken, promptrate, completionrate int) common.SpendFn {\n\treturn common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tvar checkCrowd bool\n\t\t\tvar groups []crowdadapter.CrowdGroup\n\t\t\tif _, ok := crowdapi.(*crowdadapter.CrowdAPI); ok {\n\t\t\t\tcheckCrowd = true\n\t\t\t}\n\t\t\tif checkCrowd && (common.IsAirgappedDomain(domain) || common.IsAirgappedDomain(req.Header.Get(\"X-Domain\"))) {\n\t\t\t\tgroups, err = crowdapi.GetUserNestedGroups(req.Context(), user, crowdadapter.DefaultLimit)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, 0, err\n\t\t\t\t}\n\t\t\t\tpermit := false\n\t\t\t\tgroup := \"gaisf_\" + domain + \"_\" + strings.ReplaceAll(model, \"-\", \"_\")\n\t\t\t\tfor _, g := range groups {\n\t\t\t\t\tif g.Name == group {\n\t\t\t\t\t\tpermit = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !permit {\n\t\t\t\t\treturn 0, 0, fmt.Errorf(\"%w: %s\", DomainNotAllowed, group)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar tokens int\n\t\t\tif strings.Contains(model, \"gpt-4o\") || strings.Contains(model, \"gpt-4.1\") || strings.Contains(model, \"vision\") {\n\t\t\t\ttokens = 2000\n\t\t\t\tvar sb streambody\n\t\t\t\tif err := json.Unmarshal([]byte(body), &sb); err != nil {\n\t\t\t\t\treturn 0, 0, err\n\t\t\t\t}\n\t\t\t\ttokens = sb.CountToken(encoder, tokens)\n\t\t\t} else {\n\t\t\t\ttokens = len(encoder.Encode(body, nil, nil))\n\t\t\t}\n\n\t\t\tif checkCrowd && capgpt4 && strings.Contains(model, \"aide-gpt-4\") {\n\t\t\t\tif groups == nil {\n\t\t\t\t\tgroups, err = crowdapi.GetUserNestedGroups(req.Context(), user, crowdadapter.DefaultLimit)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, 0, err\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif model == \"aide-gpt-4-turbo-vision\" {\n\t\t\t\t\tpermit := false\n\t\t\t\t\tif domain == \"oa\" {\n\t\t\t\t\tL3:\n\t\t\t\t\t\tfor _, g := range groups {\n\t\t\t\t\t\t\tswitch g.Name {\n\t\t\t\t\t\t\tcase \"gaisf_io_gpt4_vision\", \"gaisf_oa_gpt4_vision\", \"gaisf_oa_gpt4_turbo_vision\":\n\t\t\t\t\t\t\t\tpermit = true\n\t\t\t\t\t\t\t\tbreak L3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if domain == \"swrd\" {\n\t\t\t\t\tL4:\n\t\t\t\t\t\tfor _, g := range groups {\n\t\t\t\t\t\t\tswitch g.Name {\n\t\t\t\t\t\t\tcase \"gaisf_swrd_gpt4_vision\", \"gaisf_swrd_gpt4_turbo_vision\":\n\t\t\t\t\t\t\t\tpermit = true\n\t\t\t\t\t\t\t\tbreak L4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !permit {\n\t\t\t\t\t\treturn 0, 0, VisionNotAllowed\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens > int(8000*1.1) && (model == \"aide-gpt-4-turbo\")) ||\n\t\t\t\t\t(tokens > int(16000*1.1) && (model == \"aide-gpt-4o\")) ||\n\t\t\t\t\t(tokens > int(16000*1.1) && (model == \"aide-gpt-4o-mini\")) {\n\t\t\t\t\tif !common.CheckTokenLimitPermision(domain, tokens, groups) {\n\t\t\t\t\t\treturn 0, 0, ErrTokenLimit\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\testimate = tokens * promptrate\n\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\treturn\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif resp == nil {\n\t\t\t\testimate = preestimate * -1\n\t\t\t} else if preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\testimate = preestimate * -1\n\t\t\t} else if strings.Contains(resp.Header.Get(\"content-type\"), \"text/event-stream\") {\n\t\t\t\testimate = strings.Count(body, \"\\ndata: {\") * completionrate\n\t\t\t} else {\n\t\t\t\tvar resp AoaiResp\n\t\t\t\tif err := json.Unmarshal([]byte(body), &resp); err == nil {\n\t\t\t\t\tif resp.Usage.PromptTokens > 0 && resp.Usage.CompletionTokens > 0 {\n\t\t\t\t\t\testimate = completionrate*resp.Usage.CompletionTokens + promptrate*resp.Usage.PromptTokens - preestimate\n\t\t\t\t\t} else if resp.Usage.InputTokens > 0 && resp.Usage.OutputTokens > 0 {\n\t\t\t\t\t\testimate = completionrate*resp.Usage.OutputTokens + promptrate*resp.Usage.InputTokens - preestimate\n\t\t\t\t\t} else {\n\t\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif estimate != 0 {\n\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t}\n}\n\n\nfunc enrichCSESHeaders(r *http.Request, domain, proj, tkid string, payload *map[string]any) error {\n\tlc, ok := r.Context().Value(\"lc\").(*common.LoggingContext)\n\tif !ok || lc == nil {\n\t\treturn errors.New(\"invalid logging context: not *common.LoggingContext\")\n\t}\n\tif lc.UID == nil {\n\t\treturn errors.New(\"missing UID in logging context\")\n\t}\n\tuid := *lc.UID\n\tif r.Header.Get(\"X-Domain\") == \"hwrd\" {\n\t\tdomain = \"hwrd\"\n\t}\n\tr.Header.Set(\"grpc-metadata-x-user-proxy-name\", uid)\n\tr.Header.Set(\"grpc-metadata-x-user-name\", uid)\n\tr.Header.Set(\"grpc-metadata-x-user-proxy-domain\", domain)\n\tr.Header.Set(\"grpc-metadata-x-user-domain\", domain)\n\tr.Header.Set(\"grpc-metadata-x-app-name\", proj)\n\tr.Header.Set(\"grpc-metadata-x-task-id\", tkid)\n\n\tif payload != nil {\n\t\tif v, ok := (*payload)[\"project\"]; ok {\n\t\t\tr.Header.Set(\"grpc-metadata-x-project-code\", v.(string))\n\t\t}\n\t}\n\tif code := r.Header.Get(\"X-Project-Code\"); code != \"\" {\n\t\tr.Header.Set(\"grpc-metadata-x-project-code\", code)\n\t}\n\treturn nil\n}\n\n//\t@title\t\t\t\t\t\tGAISF Gateway API\n//\t@version\t\t\t\t\t1.0\n//\t@description\t\t\t\tThis is the API documentation for the GAISF Gateway.\n//\t@BasePath\t\t\t\t\t/v1\n//\t@securityDefinitions.apikey\tBearerAuth\n//\t@in\t\t\t\t\t\t\theader\n//\t@name\t\t\t\t\t\tAuthorization\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tglobalDailyResetController.Start(ctx)\n\tvar envfile string\n\tflag.StringVar(&envfile, \"env-file\", \".env\", \"Read in a file of environment variables\")\n\tflag.Parse()\n\n\tlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\n\tif err := godotenv.Load(envfile); err == nil {\n\t\tlogger.Info(\"loading config file\", \"file\", envfile)\n\t}\n\n\tjwtKey := envmust(\"JWT_SECRET_KEY\")\n\tdomain := envstr(\"DOMAIN_CHECK\", \"oa\")\n\t// (permMgr initialization moved later where crowdapi is available)\n\n\tif !common.Domain(domain).IsValid() {\n\t\tpanic(\"DOMAIN_CHECK must be set to an airgapped domain\")\n\t}\n\n\tuserServiceURL := envstr(\"USER_SERVICE\", \"http://user-service:8080\")\n\n\tsmtpserver := \"smtp.mediatek.com:25\"\n\n\tif smtp := envstr(\"SMTP_SERVER\", \"\"); smtp != \"\" {\n\t\tsmtpserver = smtp\n\t}\n\n\tredisurl := envmust(\"REDIS_URL\")\n\n\tcapping := envstr(\"ENABLE_CAPPING\", \"true\")\n\n\tvar err error\n\tvar crowdapi crowdadapter.Adapter\n\n\trueidisopt := rueidis.ClientOption{InitAddress: []string{redisurl}}\n\tif strings.Contains(redisurl, \"://\") {\n\t\trueidisopt = rueidis.MustParseURL(redisurl)\n\t}\n\trueidisopt.CacheSizeEachConn = 64 * (1 << 20)\n\trac, err := rueidisaside.NewClient(rueidisaside.ClientOption{ClientOption: rueidisopt})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trc := rac.Client()\n\n\tswitch envstr(\"CROWD_IMPL_TYPE\", \"crowd\") {\n\tcase \"crowd\":\n\t\tcrowdapi, err = crowdadapter.NewCrowdAPI(envmust(\"CROWD_USERNAME\"), envmust(\"CROWD_PASSWORD\"), rac)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\tcase \"none\":\n\t\tcrowdapi = &crowdadapter.Empty{}\n\tdefault:\n\t\tpanic(\"unexpected CROWD_IMPL_TYPE\")\n\t}\n\n\tpermMgr := common.NewModelPermissionManager(jwtKey, crowdapi)\n\ttr := http.DefaultTransport.(*http.Transport).Clone()\n\ttr.MaxIdleConns = 10000\n\ttr.MaxIdleConnsPerHost = 1000\n\ttr.ResponseHeaderTimeout = 0\n\tif resolver := os.Getenv(\"RESOLVER_ADDR\"); resolver != \"\" {\n\t\tdialer := net.Dialer{\n\t\t\tResolver: &net.Resolver{\n\t\t\t\tPreferGo: true,\n\t\t\t\tDial: func(ctx context.Context, network, address string) (net.Conn, error) {\n\t\t\t\t\treturn (&net.Dialer{}).DialContext(ctx, \"tcp\", resolver)\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\ttr.DialContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\taddr = strings.Replace(addr, \"mtklm-core.mediatek.inc\", \"10.225.43.241\", 1)\n\t\t\treturn dialer.DialContext(ctx, network, addr)\n\t\t}\n\t}\n\tif strings.Contains(os.Getenv(\"CSES_LLM_API_URL\"), \"mtklm-hwrd.mediatek.inc\") {\n\t\tdialer := &tls.Dialer{\n\t\t\tConfig: &tls.Config{\n\t\t\t\tInsecureSkipVerify: true,\n\t\t\t},\n\t\t}\n\t\ttr.DialTLSContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\tif strings.Contains(addr, \"mtklm-hwrd.mediatek.inc\") {\n\t\t\t\treturn dialer.DialContext(ctx, network, \"10.10.46.14:443\")\n\t\t\t}\n\t\t\treturn dialer.DialContext(ctx, network, addr)\n\t\t}\n\t}\n\n\tqc := quota.NewRedisQuotaClient(rc, capping == \"true\")\n\n\ttiktoken.SetBpeLoader(tiktoken_loader.NewOfflineLoader())\n\tcl100k, err := tiktoken.GetEncoding(\"cl100k_base\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tp50k, err := tiktoken.GetEncoding(\"p50k_base\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar aoaidispatchers map[string]*dispatcher\n\tvar aoaifallback *endpoint\n\tbedrockendpoint := make(map[string]*endpoint)\n\n\t// AOAI pricing and endpoint configuration\n\t// Price: https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/\n\taoaidispatchers = map[string]*dispatcher{\n\t\t\"aide-gpt-4-turbo\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4-turbo\", true, crowdapi, qc, smtpserver, cl100k, 1000, 1500*2), []endpointconfig{\n\t\t\taoai(480, \"aideopenaicanadaeast\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaieastus2\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaifrancecentral\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(900, \"aideopenainorwayeast\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(900, \"aideopenaisouthindia\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaiwestus\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(900, \"aideopenaiswedencentral\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaiuksouth\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenainorthcentralus\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaisouthcentralus\", \"aide-gpt-4-turbo\"),\n\t\t\taoai(480, \"aideopenaieastus\", \"aide-gpt-4-turbo\"),\n\t\t}),\n\t\t// for AIDE internal use\n\t\t\"aide-gpt-4-turbo-1106\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4-turbo-1106\", true, crowdapi, qc, smtpserver, cl100k, 1000, 1500*2), []endpointconfig{\n\t\t\taoai(5000, \"aideopenaiaustraliaeast\", \"aide-gpt-4-turbo-1106\"),\n\t\t}),\n\t\t// for AIDE internal use\n\t\t\"aide-gpt-4o-0806\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4o-0806\", true, crowdapi, qc, smtpserver, cl100k, 500, 1500), []endpointconfig{\n\t\t\taoai(5000, \"aideopenaieastus\", \"aide-gpt-4o-0806\"),\n\t\t}),\n\t\t\"aide-gpt-4o\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4o\", true, crowdapi, qc, smtpserver, cl100k, 500, 1500), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaijapaneast\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaiwestus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenainorthcentralus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaisouthcentralus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaieastus\", \"aide-gpt-4o\"),\n\t\t\taoai(60000, \"aideopenaiwestus3\", \"aide-gpt-4o\"),\n\t\t}),\n\t\t\"aide-gpt-4o-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4o-mini\", true, crowdapi, qc, smtpserver, cl100k, 15, 60), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus\", \"aide-gpt-4o-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4o-mini\"),\n\t\t\taoai(60000, \"aideopenaijapaneast\", \"aide-gpt-4o-mini\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4o-mini\"),\n\t\t}),\n\t\t\"aide-gpt-4.1\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4.1\", true, crowdapi, qc, smtpserver, cl100k, 200, 800), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4.1\"),\n\t\t\taoai(600000, \"aideopenaijapaneast\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaicanadaeast\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaiaustraliaeast\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenainorthcentralus\", \"aide-gpt-4.1\"),\n\t\t\taoai(60000, \"aideopenaisouthcentralus\", \"aide-gpt-4.1\"),\n\t\t}),\n\t\t\"aide-gpt-4.1-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4.1-mini\", true, crowdapi, qc, smtpserver, cl100k, 40, 160), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4.1-mini\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4.1-mini\"),\n\t\t}),\n\t\t\"aide-gpt-4.1-nano\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4.1-nano\", true, crowdapi, qc, smtpserver, cl100k, 10, 40), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-4.1-nano\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-4.1-nano\"),\n\t\t}),\n\t\t\"aide-gpt-5\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5\", true, crowdapi, qc, smtpserver, cl100k, 125, 1000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5\"),\n\t\t}),\n\t\t\"aide-gpt-5-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5-mini\", true, crowdapi, qc, smtpserver, cl100k, 250, 200), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5-mini\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5-mini\"),\n\t\t}),\n\t\t\"aide-gpt-5-nano\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5-nano\", true, crowdapi, qc, smtpserver, cl100k, 5, 40), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5-nano\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5-nano\"),\n\t\t}),\n\t\t\"aide-gpt-5-chat\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-5-chat\", true, crowdapi, qc, smtpserver, cl100k, 125, 1000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-gpt-5-chat\"),\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-gpt-5-chat\"),\n\t\t}),\n\t\t\"aide-o1-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o1-mini\", true, crowdapi, qc, smtpserver, cl100k, 300, 1200), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o1-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o1-mini\"),\n\t\t}),\n\t\t\"aide-o1\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o1\", true, crowdapi, qc, smtpserver, cl100k, 1500, 6000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o1\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o1\"),\n\t\t}),\n\t\t// o1-preview will be deprecated if o1 is stable\n\t\t\"aide-o1-preview\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o1-preview\", true, crowdapi, qc, smtpserver, cl100k, 1500, 6000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o1-preview\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o1-preview\"),\n\t\t}),\n\t\t\"aide-o3-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o3-mini\", true, crowdapi, qc, smtpserver, cl100k, 110, 440), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o3-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o3-mini\"),\n\t\t}),\n\t\t\"aide-o3\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o3\", true, crowdapi, qc, smtpserver, cl100k, 200, 800), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o3\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o3\"),\n\t\t}),\n\t\t\"aide-o3-pro\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o3-pro\", true, crowdapi, qc, smtpserver, cl100k, 2000, 8000), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o3-pro\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o3-pro\"),\n\t\t}),\n\t\t\"aide-o4-mini\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-o4-mini\", true, crowdapi, qc, smtpserver, cl100k, 110, 440), []endpointconfig{\n\t\t\taoai(60000, \"aideopenaieastus2\", \"aide-o4-mini\"),\n\t\t\taoai(60000, \"aideopenaiswedencentral\", \"aide-o4-mini\"),\n\t\t}),\n\t\t\"aide-gpt-4-turbo-vision\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-4-turbo-vision\", true, crowdapi, qc, smtpserver, cl100k, 1000, 1500*2), []endpointconfig{\n\t\t\taoai(10, \"aideopenaiaustraliaeast\", \"aide-gpt-4-turbo-vision\"),\n\t\t\taoai(10, \"aideopenaiwestus\", \"aide-gpt-4-turbo-vision\"),\n\t\t\taoai(10, \"aideopenaiswitzerlandnorth\", \"aide-gpt-4-turbo-vision\"),\n\t\t\taoai(10, \"aideopenaiswedencentral\", \"aide-gpt-4-turbo-vision\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo-16k-4k\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo-16k-4k\", true, crowdapi, qc, smtpserver, cl100k, 100, 200), []endpointconfig{\n\t\t\taoai(720, \"aideopenaiaustraliaeast\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(3720, \"aideopenaicanadaeast\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaifrancecentral\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaisouthindia\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaiwestus\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaiuksouth\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(1800, \"aideopenainorthcentralus\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t\taoai(720, \"aideopenaisouthcentralus\", \"aide-gpt-35-turbo-16k-4k\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo\", false, crowdapi, qc, smtpserver, cl100k, 150, 200), []endpointconfig{\n\t\t\taoai(1440, \"aideopenaifrancecentral\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(720, \"aideopenaisouthcentralus\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1440, \"aideopenaiuksouth\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(900, \"aideopenaicanadaeast\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaijapaneast\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(900, \"aideopenainorthcentralus\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaieastus2\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaiaustraliaeast\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(3000, \"aideopenaiswitzerlandnorth\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(3000, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo\"),\n\t\t\taoai(1800, \"aideopenaieastus\", \"aide-gpt-35-turbo\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo-instruct\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo-instruct\", false, crowdapi, qc, smtpserver, cl100k, 150, 200), []endpointconfig{\n\t\t\taoai(1440, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo-instruct\"),\n\t\t\taoai(1440, \"aideopenaieastus\", \"aide-gpt-35-turbo-instruct\"),\n\t\t}),\n\t\t\"aide-gpt-35-turbo-16k\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-gpt-35-turbo-16k\", false, crowdapi, qc, smtpserver, cl100k, 300, 400), []endpointconfig{\n\t\t\taoai(1440, \"aideopenaifrancecentral\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(3000, \"aideopenaiuksouth\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(900, \"aideopenaicanadaeast\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaijapaneast\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(900, \"aideopenainorthcentralus\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(3000, \"aideopenaieastus2\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaiaustraliaeast\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaiswitzerlandnorth\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1800, \"aideopenaiswedencentral\", \"aide-gpt-35-turbo-16k\"),\n\t\t\taoai(1440, \"aideopenaieastus\", \"aide-gpt-35-turbo-16k\"),\n\t\t}),\n\t\t\"aide-text-embedding-3-large\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-3-large\", false, crowdapi, qc, smtpserver, cl100k, 13, 13), []endpointconfig{\n\t\t\taoai(2100, \"aideopenaicanadaeast\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaieastus\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaieastus2\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaifrancecentral\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaijapaneast\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaisouthindia\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaiswedencentral\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaiuksouth\", \"aide-text-embedding-3-large\"),\n\t\t\taoai(2100, \"aideopenaiwestus3\", \"aide-text-embedding-3-large\"),\n\t\t}),\n\t\t\"aide-text-embedding-3-small\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-3-small\", false, crowdapi, qc, smtpserver, cl100k, 2, 2), []endpointconfig{\n\t\t\taoai(2100, \"aideopenaicanadaeast\", \"aide-text-embedding-3-small\"),\n\t\t\taoai(2100, \"aideopenaieastus\", \"aide-text-embedding-3-small\"),\n\t\t\taoai(2100, \"aideopenaieastus2\", \"aide-text-embedding-3-small\"),\n\t\t}),\n\t\t\"aide-text-embedding-ada-002-v2\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-ada-002-v2\", false, crowdapi, qc, smtpserver, cl100k, 10, 10), []endpointconfig{\n\t\t\taoai(4200, \"aideopenaiwesteurope\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(4200, \"aideopenaieastus2\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(4200, \"aideopenaisouthcentralus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiaustraliaeast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaicanadaeast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaijapaneast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiswitzerlandnorth\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenainorthcentralus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiuksouth\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaifrancecentral\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiswedencentral\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(1380, \"aideopenaieastus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiwestus\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenainorwayeast\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaisouthindia\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaisouthafricanorth\", \"aide-text-embedding-ada-002-v2\"),\n\t\t\taoai(2100, \"aideopenaiwestus3\", \"aide-text-embedding-ada-002-v2\"),\n\t\t}),\n\t\t\"aide-text-embedding-ada-002\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-text-embedding-ada-002\", false, crowdapi, qc, smtpserver, cl100k, 10, 10), []endpointconfig{\n\t\t\taoai(20, \"aideopenaieastus\", \"aide-text-embedding-ada-002\"),\n\t\t}),\n\t\t\"aide-davinci-003\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-davinci-003\", false, crowdapi, qc, smtpserver, p50k, 2000, 2000), []endpointconfig{\n\t\t\taoai(600, \"aideopenaieastus\", \"aide-davinci-003\"),\n\t\t}),\n\t\t\"aide-code-davinci-002\": NewDispatcher(tr, logger, true, aoaiSpend(\"aide-code-davinci-002\", false, crowdapi, qc, smtpserver, p50k, 1000, 1000), []endpointconfig{\n\t\t\taoai(600, \"aideopenaieastus\", \"aide-code-davinci-002\"),\n\t\t}),\n\t\t\"aide-whisper\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\testimate = 6000000 // assume 10 minute\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoaiNoReqLog(3, \"aideopenaieastus2\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenainorthcentralus\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenainorwayeast\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenaisouthindia\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenaiswedencentral\", \"aide-whisper\"),\n\t\t\taoaiNoReqLog(3, \"aideopenaiwesteurope\", \"aide-whisper\"),\n\t\t}),\n\t\t\"aide-tts\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\testimate = 15000000 // assume 10000 characters\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(3, \"aideopenainorthcentralus\", \"aide-tts\"),\n\t\t\taoai(3, \"aideopenaiswedencentral\", \"aide-tts\"),\n\t\t}),\n\t\t\"aide-gpt-4o-realtime-preview\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\treturn\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(500, \"aideopenaieastus2\", \"aide-gpt-4o-realtime-preview\"),\n\t\t\taoai(500, \"aideopenaiswedencentral\", \"aide-gpt-4o-realtime-preview\"),\n\t\t}),\n\t\t\"aide-tts-hd\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\testimate = 30000000 // assume 10000 characters\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(3, \"aideopenainorthcentralus\", \"aide-tts-hd\"),\n\t\t\taoai(3, \"aideopenaiswedencentral\", \"aide-tts-hd\"),\n\t\t}),\n\t\t\"Dalle3\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\tvar dreq DalleReq\n\t\t\t\tif err := json.Unmarshal([]byte(body), &dreq); err == nil {\n\t\t\t\t\testimate = dreq.N * 4000000 // $4 for 100 images\n\t\t\t\t}\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(240, \"aideopenaiswedencentral\", \"dalle-3\"),\n\t\t\taoai(240, \"aideopenaiaustraliaeast\", \"dalle-3\"),\n\t\t\taoai(240, \"aideopenaieastus\", \"dalle-3\"),\n\t\t}),\n\t\t\"dalle\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\tvar dreq DalleReq\n\t\t\t\tif err := json.Unmarshal([]byte(body), &dreq); err == nil {\n\t\t\t\t\testimate = dreq.N * 2000000 // $2 for 100 images\n\t\t\t\t}\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\t\testimate = preestimate * -1\n\t\t\t\t\tqc.Spend(context.Background(), user, estimate)\n\t\t\t\t}\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(1380, \"aideopenaieastus\", \"dalle\"),\n\t\t}),\n\t\t\"dalleget\": NewDispatcher(tr, logger, true, common.SpendFn{\n\t\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\t\treturn 0, 1, nil\n\t\t\t},\n\t\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\t\treturn 0\n\t\t\t},\n\t\t\tAlert: func(user string, logger *slog.Logger) {},\n\t\t}, []endpointconfig{\n\t\t\taoai(1380, \"aideopenaieastus\", \"dalleget\"),\n\t\t}),\n\t}\n\taoaifallback = NewEndpoint(context.Background(), true, aoai(0, \"aideopenaieastus\", \"other\"), tr, logger, aoaiSpend(\"\", true, crowdapi, qc, smtpserver, cl100k, 200, 150))\n\n\tassistantsAPIResource := envstr(\"ASSISTANTS_API_RESOURCE\", \"aideopenaiaustraliaeast\")\n\tassistantsAPI := NewEndpoint(context.Background(), false, endpointconfig{\n\t\turl:    fmt.Sprintf(\"https://%s.openai.azure.com\", assistantsAPIResource),\n\t\thdrs:   map[string]string{\"api-key\": envstr(\"AZURE_OPAI_KEY_\"+strings.ReplaceAll(assistantsAPIResource, \"-\", \"_\"), \"\")},\n\t\tlabels: []string{\"aoai\", \"assistants\", assistantsAPIResource},\n\t}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"/runs\") {\n\t\t\t\testimate = 1000000 // estimated assistants api costs $10 for 1000 runs\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tazurecognitive := NewEndpoint(context.Background(), true, endpointconfig{url: envstr(\"AZURE_COGNITIVE_HOST\", \"https://aide-cognitive-multi.cognitiveservices.azure.com\"), hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envmust(\"AZURE_COGNITIVE_KEY\"),\n\t}, noreqlog: true, labels: []string{\"cogn\", \"ocr\", \"azure-cognitive-multi\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"read/analyze\") {\n\t\t\t\testimate = 100000 // OCR api costs $1 for 1000 calls\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif strings.Contains(req.URL.Path, \":analyze\") {\n\t\t\t\testimate = 1000000 // document api costs $10 per 1,000 pages\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif resp != nil && preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tsttxy := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://southeastasia.stt.speech.microsoft.com\", hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envstr(\"SPEECH_API_KEY\", envmust(\"AZURE_COGNITIVE_KEY\")),\n\t}, noreqlog: true, labels: []string{\"cogn\", \"stt\", \"southeastasia\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tcustomvoice := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://southeastasia.customvoice.api.speech.microsoft.com\", hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envmust(\"AZURE_COGNITIVE_KEY\"),\n\t}, labels: []string{\"cogn\", \"tts\", \"southeastasia\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"batchsynthesis\") {\n\t\t\t\testimate = 100000 // TTS api costs $1 for 1 hour\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tbing := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://api.bing.microsoft.com\", hdrs: map[string]string{\n\t\t\"Ocp-Apim-Subscription-Key\": envstr(\"AZURE_BING_KEY\", \"\"),\n\t}, labels: []string{\"cogn\", \"bing\", \"southeastasia\"}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tif req.Method == http.MethodPost && strings.Contains(req.URL.Path, \"batchsynthesis\") {\n\t\t\t\testimate = 300000 // search api costs $3 for 1000 calls\n\t\t\t\tremain, err = qc.Spend(context.Background(), user, estimate)\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\tif preestimate > 0 && resp.StatusCode >= 300 {\n\t\t\t\tqc.Spend(context.Background(), user, preestimate*-1)\n\t\t\t\treturn preestimate * -1\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tcsesLLMAPIURL := envstr(\"CSES_LLM_API_URL\", \"https://mtklm-core.mediatek.inc\")\n\n\tmtklmr := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://mtklm-mr.mediatek.inc\", labels: []string{\"mtkmr\", \"cses\", \"c\"}, hdrs: map[string]string{\n\t\t\"Authorization\": \"Bearer \" + envstr(\"CSES_LLM_MR_API_KEY\", \"\"),\n\t}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tmtkcreatetoken := os.Getenv(\"CREATE_MTK_RESEARCH_COM_LLM_API_TOKEN\")\n\n\tmtkcreate := NewEndpoint(context.Background(), false, endpointconfig{url: \"https://create.mtkresearch.com\", labels: []string{\"mtkmr\", \"cses\", \"c\"}, hdrs: map[string]string{\n\t\t\"Authorization\": fmt.Sprintf(\"Bearer %s\", mtkcreatetoken),\n\t}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tmtklcore := NewEndpoint(context.Background(), false, endpointconfig{url: csesLLMAPIURL, labels: []string{\"mtkcore\", \"cses\", \"c\"}, hdrs: map[string]string{\n\t\t\"Authorization\": \"Bearer \" + envstr(\"CSES_LLM_API_KEY\", \"\"),\n\t}}, tr, logger, common.SpendFn{\n\t\tPre: func(user, domain string, req *http.Request, body string) (estimate int, remain int, err error) {\n\t\t\tmodel := extractModel(req.URL.Path, body)\n\t\t\tif model != \"\" {\n\t\t\t\tif ok := permMgr.CheckServicePermission(req.Context(), req, model, domain, user, crowdapi); !ok {\n\t\t\t\t\treturn 0, 1, DomainNotAllowed\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0, 1, nil // TODO\n\t\t},\n\t\tPost: func(user string, resp *http.Response, body string, preestimate int) (estimate int) {\n\t\t\treturn 0\n\t\t},\n\t\tAlert: common.AlertFn(smtpserver, qc),\n\t})\n\n\tvar creds *google.Credentials\n\tvar gcpcredonce sync.Once\n\n\tgeminiRegions := gcp.GeminiRegions\n\tgeminis := make(map[string]*endpoint, len(geminiRegions))\n\tfor _, region := range geminiRegions {\n\t\t// Use smart SpendFn that can handle multiple Gemini models dynamically\n\t\tspendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)\n\t\tgeminis[region] = NewEndpoint(context.Background(), false, endpointconfig{\n\t\t\turl:    \"https://aiplatform.googleapis.com\",\n\t\t\tlabels: []string{\"gcp\", \"gemini\", region},\n\t\t}, tr, logger, spendFn)\n\t}\n\n\tdavinciShareProd := NewDaviciShareServerFunc(envstr(\"STORE_API_PROD_URL\", \"http://store-api-prod.default.svc.cluster.mke\"), envstr(\"DAVINCI_PROD_URL\", \"https://davinci.mediatek.inc/\"))\n\tdavinciShareStag := NewDaviciShareServerFunc(envstr(\"STORE_API_STAG_URL\", \"http://store-api-stag.default.svc.cluster.mke\"), envstr(\"DAVINCI_STAG_URL\", \"https://davinci-io.mediatek.inc/\"))\n\n\tawsKey := os.Getenv(\"AWS_ACCESS_KEY\")\n\tawsSecret := os.Getenv(\"AWS_SECRET_KEY\")\n\tawssigner := v4.NewSigner()\n\tsignAwsReq := awsclaude.SignAwsReq(awssigner, awsKey, awsSecret)\n\n\tawsdispatchers := make(map[string]*dispatcher)\n\tawsModelEndpointConfigs := make(map[string][]endpointconfig)\n\tmodelIDSpendFnKey := make(map[string]string)\n\tfor modelKey, arn := range awsclaude.ModelARNs {\n\t\tregion := awsclaude.GetRegionFromArn(arn)\n\t\tmodelWithVersion := awsclaude.GetModelWithVersionFromArn(arn)\n\t\tmodelId := awsclaude.GetModelIDFromModelWithVersion(modelWithVersion)\n\n\t\tendpointUrl := awsclaude.GetEndpointFromRegion(region)\n\t\tspendFnKey := awsclaude.ModelKeyToSpendFnKey(modelKey) // 例如 \"claude-v3-5-haiku\"\n\t\tmodelIDSpendFnKey[modelId] = spendFnKey\n\n\t\tspendFnFactory, ok := awsclaude.SpendFnMap[spendFnKey]\n\t\tif !ok {\n\t\t\tpanic(\"no spendFn for model: \" + modelKey)\n\t\t}\n\n\t\tfn := spendFnFactory(signAwsReq, crowdapi, qc, smtpserver, cl100k)\n\t\tepcForArn := endpointconfig{\n\t\t\tweight: 1,\n\t\t\turl:    endpointUrl,\n\t\t\tlabels: []string{\"awsbedrock\", modelKey, region},\n\t\t}\n\t\tbedrockendpoint[modelKey] = NewEndpoint(\n\t\t\tcontext.Background(), false, epcForArn, tr, logger, fn,\n\t\t)\n\n\t\tepcForModelId := endpointconfig{\n\t\t\tweight: 1,\n\t\t\turl:    endpointUrl + \"/model/\" + modelWithVersion,\n\t\t\tlabels: []string{\"awsbedrock\", modelKey, region},\n\t\t}\n\n\t\tawsModelEndpointConfigs[modelId] = append(awsModelEndpointConfigs[modelId], epcForModelId)\n\t}\n\n\tfor modelId, epcs := range awsModelEndpointConfigs {\n\t\tspendFnKey := modelIDSpendFnKey[modelId]\n\t\tspendFn := awsclaude.SpendFnMap[spendFnKey](signAwsReq, crowdapi, qc, smtpserver, cl100k)\n\t\tawsdispatchers[modelId] = NewDispatcher(tr, logger, false, spendFn, epcs)\n\t}\n\n\t// update modelMapGroupSVC\n\t// Initialize ModelPermissionManager before usage below\n\t// permMgr already initialized above using jwtKey and crowdapi\n\tmodelGroupSvc := NewModelGroupService(domain, logger)\n\tinitParams := ModelGroupInitParams{\n\t\tDomain:         domain,\n\t\tAOAIDispatcher: aoaidispatchers,\n\t\tAWSDispatcher:  awsdispatchers,\n\t\t// Use the injected model permission manager's map\n\t\tModelPermissionMap: permMgr.Map,\n\t\tClaudeGroups:       map[string]map[string]string{}, // ClaudeGroups temporarily disabled, replaced with an empty map. TODO: Restore when fixed.\n\t}\n\tmodelGroupSvc.InitAllModelGroups(initParams)\n\tenableModelCheck := envBool(\"ENABLE_MODEL_CHECK\", false)\n\n\tallowedLogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n\n\tuserService := user.NewEngine(userServiceURL, jwtKey, crowdapi)\n\tjwtVeriHandler := APIV1.JWTVerifyHandler(userService)\n\tgin.SetMode(gin.ReleaseMode)\n\tapp := gin.New()\n\tapp.Use(gin.Recovery())\n\tapp.Use(header.Options)\n\tapp.Use(header.Secure)\n\tapp.Use(requestid.New())\n\tapp.GET(\"/\", func(c *gin.Context) {\n\t\tc.AbortWithStatus(http.StatusOK)\n\t})\n\t// Add auth routers\n\tauth.RegisterRoutes(app, domain, jwtKey, userService)\n\tapp.GET(\"/metrics\", gin.WrapH(promhttp.Handler()))\n\tapp.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\t{\n\t\tv1 := app.Group(\"/v1\")\n\t\tv1.GET(\"/version\", APIV1.GetVersion)\n\t\tv1.POST(\"/token\",\n\t\t\tjwtVeriHandler,\n\t\t\tmiddleware.VerifyAdmin(crowdapi, \"gaisf_admins\"),\n\t\t\tAPIV1.JWTSignHandler(\n\t\t\t\tcrowdapi,\n\t\t\t\tuserService,\n\t\t\t),\n\t\t)\n\t\tv1.POST(\"/services/:uid/token\",\n\t\t\tjwtVeriHandler,\n\t\t\tmiddleware.VerifyAdmin(crowdapi, \"gaisf_admins\"),\n\t\t\tAPIV1.ServiceJWTSignHandler(\n\t\t\t\tcrowdapi,\n\t\t\t\tuserService,\n\t\t\t),\n\t\t)\n\t\tv1.GET(\"/models\", jwtVeriHandler, APIV1.UserModelsHandler(domain, crowdapi, modelGroupSvc, false))\n\t\tv1.GET(\"/admin/models\", jwtVeriHandler, APIV1.UserModelsHandler(domain, crowdapi, modelGroupSvc, true))\n\n\t\tawsClaudeModels := make(map[string]interface{})\n\t\tfor k := range awsdispatchers {\n\t\t\tawsClaudeModels[k] = struct{}{}\n\t\t}\n\t\tdeps := &ChatHandlerDeps{\n\t\t\tAoaidDispatchers: aoaidispatchers,\n\t\t\tDomain:           domain,\n\t\t\tMtklcore:         mtklcore,\n\t\t\tGeminis:          geminis,\n\t\t\tCrowdapi:         crowdapi,\n\t\t\tBuffers:          &buffers,\n\t\t\tAwsClaudesModels: awsClaudeModels,\n\t\t}\n\t\tif enableModelCheck {\n\t\t\tv1.POST(\"/chat/completions\", jwtVeriHandler, modelGroupSvc.CompletionsMiddleware(domain), deps.ChatCompletionsHandler)\n\t\t} else {\n\t\t\tv1.POST(\"/chat/completions\", jwtVeriHandler, deps.ChatCompletionsHandler)\n\t\t}\n\t\tv1.GET(\"/users/:uid/cap\", jwtVeriHandler, APIV1.UserCapHandler(qc))\n\t\tv1.POST(\"/users/:uid/token\", jwtVeriHandler, APIV1.UserTokenHandler(userService))\n\t\tv1.POST(\"/token/check\", jwtVeriHandler, APIV1.TokenCheckHandler)\n\t\tv1.POST(\"/login\", jwtVeriHandler, APIV1.LoginHandler(userService))\n\t}\n\tapp.POST(\"/verify\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"project\": lc.Project, \"tokenId\": lc.TokenID, \"account\": lc.Account, \"domain\": lc.Domain})\n\t})\n\tapp.GET(\"/in\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tlogger := allowedLogger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", ctx.Request.Header.Get(\"X-Request-ID\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"req\", InListReq{Uid: ctx.Query(\"uid\"), List: ctx.Query(\"list\")}.ToString(), \"hdrs\", ToHeaderLogs(ctx.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\n\t\tstatus, resp := checkInCrowdGroup(crowdapi, ctx.Query(\"list\"), ctx.Query(\"uid\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"resp\", resp.ToString())\n\t\tctx.AbortWithStatusJSON(status, resp)\n\t})\n\n\t// POST /bing-search endpoint\n\t// --- credential init, only once ---\n\tazureBingCfg, _ := azurebingsearch.GetConfig()\n\tazureBingCred, _ := azidentity.NewClientSecretCredential(\n\t\tazureBingCfg.TenantID,\n\t\tazureBingCfg.ClientID,\n\t\tazureBingCfg.ClientSecret,\n\t\tnil,\n\t)\n\n\tapp.POST(\"/bing-search\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tvar req struct {\n\t\t\tQ string `json:\"q\"`\n\t\t}\n\t\tif err := ctx.ShouldBindJSON(&req); err != nil || req.Q == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"missing q\"})\n\t\t\treturn\n\t\t}\n\t\tresult, err := azurebingsearch.BingSearch(context.Background(), req.Q, azureBingCred)\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\n\t\t\t\"project\": lc.Project,\n\t\t\t\"tokenId\": lc.TokenID,\n\t\t\t\"account\": lc.Account,\n\t\t\t\"domain\":  lc.Domain,\n\t\t\t\"result\":  result,\n\t\t})\n\t})\n\n\tapp.GET(\"/searchusers\", func(ctx *gin.Context) {\n\t\tcql := ctx.Query(\"cql\")\n\t\tlimit, ok := getLimit(ctx)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tusers, err := crowdapi.SearchUsers(context.Background(), cql, limit)\n\t\tif err == crowd.ErrNoPerms {\n\t\t\tctx.AbortWithError(http.StatusForbidden, err)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, users)\n\t})\n\n\tapp.GET(\"/searchgroups\", func(ctx *gin.Context) {\n\t\tcql := ctx.Query(\"cql\")\n\t\tlimit, ok := getLimit(ctx)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tgroups, err := crowdapi.SearchGroups(context.Background(), cql, limit)\n\t\tif err == crowd.ErrNoPerms {\n\t\t\tctx.AbortWithError(http.StatusForbidden, err)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, groups)\n\t})\n\n\tapp.GET(\"/groupmembers\", func(ctx *gin.Context) {\n\t\tgroup := ctx.Query(\"group\")\n\t\tlimit, ok := getLimit(ctx)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tusers, err := crowdapi.GetGroupNestedUsers(context.Background(), group, limit)\n\t\tif err == crowd.ErrNoPerms {\n\t\t\tctx.AbortWithError(http.StatusForbidden, err)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tif strings.Contains(err.Error(), \"status code 404\") {\n\t\t\t\tctx.AbortWithError(http.StatusNotFound, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, users)\n\t})\n\tapp.GET(\"/allowed\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tlogger := allowedLogger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", ctx.Request.Header.Get(\"X-Request-ID\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"req\", common.AllowedReq{Uid: ctx.Query(\"uid\"), Domain: ctx.Query(\"domain\")}.ToString(), \"hdrs\", ToHeaderLogs(ctx.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\n\t\tstatus, resp := common.CheckPIM(crowdapi, ctx.Query(\"domain\"), ctx.Query(\"uid\"))\n\t\tlogger.Info(ctx.Request.URL.Path, \"resp\", resp.ToString())\n\t\tctx.AbortWithStatusJSON(status, resp)\n\t})\n\tapp.GET(\"/getcap\", func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tusage, cap, err := qc.GetCap(ctx.Request.Context(), uid)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"usage\": usage, \"cap\": cap, \"uid\": uid})\n\t})\n\tapp.POST(\"/charge\", func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tcost, err := strconv.Atoi(ctx.Query(\"cost\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tif cost < 0 {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, errors.New(\"the cost should be >= 0\"))\n\t\t\treturn\n\t\t}\n\t\tremain, err := qc.Spend(ctx, uid, cost)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"remain\": remain, \"uid\": uid})\n\t})\n\tapp.POST(\"/setcap\", func(ctx *gin.Context) {\n\t\tif ctx.Request.Header.Get(\"jwt-enc\") != jwtKey {\n\t\t\tctx.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"invalid jwt-enc header\"})\n\t\t\treturn\n\t\t}\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"uid is required\"})\n\t\t\treturn\n\t\t}\n\t\tcap, err := strconv.Atoi(ctx.Query(\"cap\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid cap value\"})\n\t\t\treturn\n\t\t}\n\t\tend, err := time.Parse(\"2006-01-02\", ctx.Query(\"end\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid end format\"})\n\t\t\treturn\n\t\t}\n\t\tif err = qc.SetCap(ctx.Request.Context(), uid, cap, end.Unix()); err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to set cap\"})\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{})\n\t})\n\t// Set a session cookie in Redis with a custom TTL\n\tapp.POST(\"/setSessionCookie\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tuserName := ctx.PostForm(\"user_name\")\n\t\tcookie := ctx.PostForm(\"cookie\")\n\t\tttlSecondsStr := ctx.PostForm(\"ttlSeconds\")\n\t\tttlSeconds, err := strconv.Atoi(ttlSecondsStr)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tif err := qc.SetSessionCookie(ctx, userName, cookie, ttlSeconds); err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.Status(http.StatusOK)\n\t})\n\t// Get a session cookie from Redis\n\tapp.GET(\"/getSessionCookie\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tuserName := ctx.Query(\"user_name\")\n\t\tcookie, err := qc.GetSessionCookie(ctx, userName)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tif cookie == \"\" {\n\t\t\tctx.AbortWithStatus(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tctx.JSON(http.StatusOK, gin.H{\"cookie\": cookie})\n\t})\n\tapp.POST(\"/checkrate\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc, ok := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tif !ok || lc == nil || lc.UID == nil || *lc.UID == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"user not found in context\"})\n\t\t\treturn\n\t\t}\n\t\tuid := *lc.UID\n\t\tok, req, cap, gap, err := qc.Limit(ctx.Request.Context(), strings.ToUpper(uid))\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"ok\": ok, \"req\": req, \"cap\": cap, \"gap\": gap})\n\t})\n\tapp.POST(\"/setreq\", jwtVeriHandler, middleware.VerifyAdmin(crowdapi, \"gaisf_admins\"), func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"uid is required\"})\n\t\t\treturn\n\t\t}\n\t\treq, err := strconv.Atoi(ctx.Query(\"req\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid req\"})\n\t\t\treturn\n\t\t}\n\t\tgap, err := strconv.Atoi(ctx.Query(\"gap\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"invalid gap\"})\n\t\t\treturn\n\t\t}\n\t\tif err = qc.SetLimit(ctx.Request.Context(), uid, int64(req), int64(gap)); err != nil {\n\t\t\tctx.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": \"failed to set limit\"})\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{})\n\t})\n\tapp.GET(\"/getreq\", func(ctx *gin.Context) {\n\t\tuid := strings.ToUpper(ctx.Query(\"uid\"))\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, errors.New(\"uid is required\"))\n\t\t\treturn\n\t\t}\n\t\tret, err := qc.GetLimit(ctx.Request.Context(), uid)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"req\": ret[0], \"gap\": ret[1]})\n\t})\n\tapp.GET(\"/time\", func(ctx *gin.Context) {\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"ts\": time.Now()})\n\t})\n\tapp.POST(\"/spend\", jwtVeriHandler, func(ctx *gin.Context) {\n\t\tlc, ok := ctx.MustGet(\"lc\").(*common.LoggingContext)\n\t\tif !ok || lc == nil || lc.UID == nil || *lc.UID == \"\" {\n\t\t\tctx.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": \"user not found in context\"})\n\t\t\treturn\n\t\t}\n\t\tuid := *lc.UID\n\t\tif uid == \"\" {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, errors.New(\"uid is required\"))\n\t\t\treturn\n\t\t}\n\t\tspend, err := strconv.Atoi(ctx.Query(\"spend\"))\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusBadRequest, err)\n\t\t\treturn\n\t\t}\n\t\tremain, err := qc.Spend(ctx.Request.Context(), uid, spend)\n\t\tif err != nil {\n\t\t\tctx.AbortWithError(http.StatusInternalServerError, err)\n\t\t\treturn\n\t\t}\n\t\tctx.AbortWithStatusJSON(http.StatusOK, gin.H{\"remain\": remain})\n\t})\n\n\t// davinciProcxyRouter is a Gin middleware function that handles routing and authentication for various API endpoints.\n\t// It performs the following main functions:\n\t//   - Validates domain access and user authentication\n\t//   - Enforces X-User-Id header requirement for cost allocation\n\t//   - Routes requests to appropriate services based on URL path:\n\t//     * LLM models (v3)\n\t//     * OpenAI services (including DALL-E)\n\t//     * Anthropic Claude models\n\t//     * Bing search\n\t//     * Azure Cognitive Services (vision, form recognition)\n\t//     * Speech services (text-to-speech, speech-to-text)\n\t//     * Gemini API endpoints\n\t//     * Davinci chat sharing\n\t//   - Performs PIM checks for certain endpoints\n\t//   - Enriches headers with required information\n\t//   - Handles timeout simulation for testing\n\t// Parameters:\n\t//   - c: Gin context containing the HTTP request and response information\n\tdavinciProcxyRouter := func(c *gin.Context) {\n\t\tlc := c.MustGet(\"lc\").(*common.LoggingContext)\n\t\tif lc.UID == nil {\n\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": gin.H{\n\t\t\t\t\"code\":    strconv.Itoa(http.StatusForbidden),\n\t\t\t\t\"message\": \"missing UID in logging context\",\n\t\t\t}})\n\t\t\treturn\n\t\t}\n\t\tif lc.Domain == \"\" {\n\t\t\tlc.Domain = \"oa\"\n\t\t}\n\t\tif (domain == \"oa\" && lc.Domain != domain) || ((common.IsAirgappedDomain(domain) || common.IsAirgappedDomain(c.Request.Header.Get(\"X-Domain\"))) && !common.IsAirgappedDomain(lc.Domain)) {\n\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": gin.H{\n\t\t\t\t\"code\":    strconv.Itoa(http.StatusForbidden),\n\t\t\t\t\"message\": fmt.Sprintf(\"token for domain %q is prohibited here\", lc.Domain),\n\t\t\t}})\n\t\t\treturn\n\t\t}\n\t\tendUser := *lc.UID\n\t\tif endUser == \"\" {\n\t\t\tc.AbortWithStatusJSON(http.StatusForbidden, gin.H{\"error\": gin.H{\n\t\t\t\t\"code\":    strconv.Itoa(http.StatusForbidden),\n\t\t\t\t\"message\": \"The X-User-Id request header is now mandatory for cost allocation. Please set the parameter with \\\"mtkxxxxx\\\" for allocating to the end user's department or \\\"srv_xxxx\\\" for background jobs.\",\n\t\t\t}})\n\t\t\treturn\n\t\t}\n\n\t\t// Check if the request is for a specific endpoint that requires PIM check\n\t\t// and if the request method is POST, PUT, or GET with specific path prefix\n\t\t// If so, perform the PIM check and update the X-User-Id header if necessary\n\t\t// If the PIM check fails, abort the request with the appropriate status and response\n\t\t// If the PIM check passes, update the LoggingContext with the response data (Banwords)\n\t\tif !strings.HasPrefix(c.Request.URL.Path, \"/llm/v3\") &&\n\t\t\t(c.Request.Method == http.MethodPost ||\n\t\t\t\tc.Request.Method == http.MethodPut ||\n\t\t\t\t(c.Request.Method == http.MethodGet && strings.HasPrefix(c.Request.URL.Path, \"/v7.0\"))) {\n\t\t\tstatus, resp := common.CheckPIM(crowdapi, lc.Domain, endUser)\n\t\t\tif status != http.StatusOK {\n\t\t\t\tlogger := allowedLogger.With(\"proj\", lc.Project, \"tkid\", lc.TokenID, \"acco\", lc.Account, \"rqid\", c.Request.Header.Get(\"X-Request-ID\"))\n\t\t\t\tlogger.Info(c.Request.URL.Path, \"req\", \"checkpim\", \"hdrs\", ToHeaderLogs(c.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\t\t\t\tlogger.Info(c.Request.URL.Path, \"resp\", resp.ToString(), \"hdrs\", ToHeaderLogs(c.Request.Header, \"\", \"\", 0, 0, lc.Priority, 0, 0, 0))\n\t\t\t\tc.AbortWithStatusJSON(status, resp)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif resp.UID != \"\" && resp.UID != endUser {\n\t\t\t\tc.Request.Header.Set(\"X-User-Id\", resp.UID)\n\t\t\t}\n\t\t\tlc.Banwords = resp.Banwords\n\t\t}\n\n\t\tif strings.HasPrefix(c.Request.URL.Path, \"/timeout\") {\n\t\t\tduration, _ := time.ParseDuration(c.Query(\"dur\"))\n\t\t\ttime.Sleep(duration)\n\t\t\tc.JSON(http.StatusOK, gin.H{\"duration\": duration})\n\t\t\treturn\n\t\t}\n\n\t\tif c.Request.Method != http.MethodDelete {\n\n\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/model/anthropic\") {\n\t\t\t\tmodelId := strings.Split(c.Request.URL.Path, \"/\")[2]\n\t\t\t\tdispatcher, ok := awsdispatchers[modelId]\n\t\t\t\tif !ok {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusNotFound, gin.H{\"error\": \"model not found\"})\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tparts := strings.Split(c.Request.URL.Path, \"/\")\n\t\t\t\tc.Request.URL.Path = \"/\"\n\t\t\t\tif len(parts) > 3 {\n\t\t\t\t\tc.Request.URL.Path = \"/\" + strings.Join(parts[3:], \"/\")\n\t\t\t\t}\n\n\t\t\t\tdispatcher.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// route aws bedrock with bedrock arn\n\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/model/\") {\n\t\t\t\tmodelKey := awsclaude.ParseBedrockModelKeyFromPath(c.Request.URL.Path)\n\t\t\t\tif ep, ok := bedrockendpoint[modelKey]; ok && ep != nil {\n\t\t\t\t\tep.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/llm/v3/models/mtkresearch\") {\n\t\t\t\tif err := enrichCSESHeaders(c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)), domain, lc.Project, lc.TokenID, lc.Payload); err != nil {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif mtkcreatetoken != \"\" {\n\t\t\t\t\tmtkcreate.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t} else {\n\t\t\t\t\tmtklmr.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/llm/v3/info\") {\n\t\t\t\tif err := enrichCSESHeaders(c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)), domain, lc.Project, lc.TokenID, lc.Payload); err != nil {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmtklcore.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/llm/v3/models\") {\n\t\t\t\tif err := enrichCSESHeaders(c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)), domain, lc.Project, lc.TokenID, lc.Payload); err != nil {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmtklcore.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/openai/\") {\n\t\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/openai/assistants\") {\n\t\t\t\t\tassistantsAPI.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/openai/threads\") {\n\t\t\t\t\tassistantsAPI.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(c.Request.URL.Path, \"/openai/files\") {\n\t\t\t\t\tassistantsAPI.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tdeployment := extractURLSlug(c.Request.URL.Path, 3)\n\t\t\t\tswitch deployment {\n\t\t\t\tcase \"generations:submit\": // DALL·E submit\n\t\t\t\t\tdeployment = \"dalle\"\n\t\t\t\tcase \"images\": // DALL·E get\n\t\t\t\t\tdeployment = \"dalleget\"\n\t\t\t\t}\n\t\t\t\tif d, ok := aoaidispatchers[deployment]; ok {\n\t\t\t\t\t// Check and set default api-version only if needed\n\t\t\t\t\t// See the reference: https://learn.microsoft.com/en-us/azure/ai-services/openai/reference\n\t\t\t\t\tq := c.Request.URL.Query()\n\t\t\t\t\tif q.Get(\"api-version\") == \"\" {\n\t\t\t\t\t\tq.Set(\"api-version\", azure.OpenAIAPIVersion)\n\t\t\t\t\t\tc.Request.URL.RawQuery = q.Encode()\n\t\t\t\t\t}\n\t\t\t\t\td.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t} else {\n\t\t\t\t\tif aoaifallback == nil || aoaifallback.proxy == nil {\n\t\t\t\t\t\tc.AbortWithStatus(http.StatusNotFound)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\taoaifallback.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/v7.0/search\") {\n\t\t\t\tbing.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/vision\") {\n\t\t\t\tif c.Request.ContentLength > 1024*1024*10 {\n\t\t\t\t\tc.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": gin.H{\n\t\t\t\t\t\t\"code\": strconv.Itoa(http.StatusBadRequest),\n\t\t\t\t\t}})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tazurecognitive.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/formrecognizer\") {\n\t\t\t\tazurecognitive.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/api/texttospeech\") {\n\t\t\t\tcustomvoice.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/speech/recognition/conversation/cognitiveservices\") {\n\t\t\t\tsttxy.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\treturn\n\t\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/v1/projects/mtk-aide-gemini-poc/locations\") {\n\t\t\t\tfor region, endpoint := range geminis {\n\t\t\t\t\tif strings.HasPrefix(c.Request.URL.Path[len(\"/v1/projects/mtk-aide-gemini-poc/locations/\"):], region) {\n\t\t\t\t\t\tendpoint.proxy.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.AbortWithStatus(http.StatusNotFound)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tdeployment := extractURLSlug(c.Request.URL.Path, 1)\n\n\t\t\t\tif d, ok := aoaidispatchers[deployment]; ok {\n\t\t\t\t\tc.Request.URL.Path = strings.TrimPrefix(c.Request.URL.Path, \"/\"+deployment)\n\t\t\t\t\td.ServeHTTP(c.Writer, c.Request.WithContext(context.WithValue(c.Request.Context(), \"lc\", lc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif strings.HasPrefix(c.Request.URL.Path, \"/davinci/share-chat\") {\n\t\t\tdavinciShareProd(c)\n\t\t\treturn\n\t\t} else if strings.HasPrefix(c.Request.URL.Path, \"/davinci-io/share-chat\") {\n\t\t\tdavinciShareStag(c)\n\t\t\treturn\n\t\t}\n\t\tc.AbortWithStatus(http.StatusNotFound)\n\t}\n\n\tenableLLMOverride := envBool(\"ENABLE_OVERRIDE_LLM\", false)\n\tif enableLLMOverride {\n\t\tinitOverriddenMiddleware()\n\t\tapp.NoRoute(header.Options, jwtVeriHandler, overrideMiddleware, davinciProcxyRouter)\n\t} else {\n\t\tapp.NoRoute(header.Options, jwtVeriHandler, davinciProcxyRouter)\n\t}\n\n\tgo func() {\n\t\tsrv := &http.Server{\n\t\t\tAddr:              \":\" + envstr(\"SERVER_PORT\", \"8080\"),\n\t\t\tHandler:           app.Handler(),\n\t\t\tReadHeaderTimeout: time.Minute,\n\t\t\tReadTimeout:       0, // intentionally 0\n\t\t\tWriteTimeout:      0, // intentionally 0\n\t\t\tMaxHeaderBytes:    http.DefaultMaxHeaderBytes,\n\t\t}\n\t\tif err := srv.ListenAndServe(); err != http.ErrServerClosed {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tpoker := poker.DavinciPoker{\n\t\tUsername:    envstr(\"IA_USERNAME\", \"\"),\n\t\tPassword:    envstr(\"IA_PASSWORD\", \"\"),\n\t\tBotTenantID: envstr(\"BOT_TENANT_ID\", \"\"),\n\t\tBotID:       envstr(\"BOT_ID\", \"\"),\n\t\tBotPassword: envstr(\"BOT_PASSWORD\", \"\"),\n\t}\n\tgo poker.RunLoop(30 * time.Minute)\n\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\t<-sigs\n\tcancel()\n\ttime.Sleep(5 * time.Second)\n}\n","structuredPatch":[{"oldStart":1921,"oldLines":7,"newStart":1921,"newLines":7,"lines":["   geminis := make(map[string]*endpoint, len(geminiRegions))","   for _, region := range geminiRegions {","     // Use smart SpendFn that can handle multiple Gemini models dynamically","-    spendFn := gemini.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)","+    spendFn := gcp.SpendFnGeminiSmart(crowdapi, qc, smtpserver, cl100k, &creds, &gcpcredonce)","     geminis[region] = NewEndpoint(context.Background(), false, endpointconfig{","       url:    \"https://aiplatform.googleapis.com\",","       labels: []string{\"gcp\", \"gemini\", region},"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"43e0e97f-f931-4286-b54c-4443f5d8c9d8","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01GMEW7S9CNDSMGt7jdFFNtt","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Let me check if there are any other references to gemini package calls:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1214,"cache_read_input_tokens":31814,"output_tokens":1}},"type":"assistant","uuid":"eb2ae42f-622d-41d6-be77-35e4bcb33b01","timestamp":"2025-08-18T03:19:20.900Z"}
{"parentUuid":"eb2ae42f-622d-41d6-be77-35e4bcb33b01","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01GMEW7S9CNDSMGt7jdFFNtt","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_017H9no4fa58J7oo5TYBTAs9","name":"Grep","input":{"pattern":"gemini\\.","path":"/Users/mtk19651/project/azure-gateway/cmd/mlop-azure-gateway/main.go","output_mode":"content","-n":true}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1214,"cache_read_input_tokens":31814,"output_tokens":149}},"type":"assistant","uuid":"c5f765b0-6d64-4d98-bb74-594f3b0888ad","timestamp":"2025-08-18T03:19:21.427Z"}
{"parentUuid":"c5f765b0-6d64-4d98-bb74-594f3b0888ad","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_017H9no4fa58J7oo5TYBTAs9","type":"tool_result","content":"No matches found"}]},"uuid":"b7af40e4-08ca-43ca-8af2-44017dc01141","timestamp":"2025-08-18T03:19:21.452Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"b7af40e4-08ca-43ca-8af2-44017dc01141","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_012kbX5Fvp2qA2AaZpgYydqA","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Good! Now let me also check for any gemini folder references in the run_tests.sh script:"},{"type":"tool_use","id":"toolu_bdrk_01Cz7S2h1uVNWVjwWd38tmq8","name":"Edit","input":{"file_path":"/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh","old_string":"PACKAGE_PATH=\"./gemini\"","new_string":"PACKAGE_PATH=\"./gcp\""}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":164,"cache_read_input_tokens":33028,"output_tokens":151}},"type":"assistant","uuid":"08b34083-46d3-4787-8fbc-d726acf905f5","timestamp":"2025-08-18T03:19:25.519Z"}
{"parentUuid":"08b34083-46d3-4787-8fbc-d726acf905f5","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has not been read yet. Read it first before writing to it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_bdrk_01Cz7S2h1uVNWVjwWd38tmq8"}]},"uuid":"f4de8269-a083-42ef-9c5a-5c79340bcd17","timestamp":"2025-08-18T03:19:25.538Z","toolUseResult":"Error: File has not been read yet. Read it first before writing to it."}
{"parentUuid":"f4de8269-a083-42ef-9c5a-5c79340bcd17","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_019yRZiekvvQtyrgPRmRWvoi","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01FzZ5SdEecF6dd3awJaCd5Y","name":"Read","input":{"file_path":"/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":196,"cache_read_input_tokens":33192,"output_tokens":74}},"type":"assistant","uuid":"4a946a09-1e47-486d-a26a-44fbeeb8a404","timestamp":"2025-08-18T03:19:28.109Z"}
{"parentUuid":"4a946a09-1e47-486d-a26a-44fbeeb8a404","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01FzZ5SdEecF6dd3awJaCd5Y","type":"tool_result","content":"     1→#!/bin/bash\n     2→\n     3→# Gemini Package Test Runner\n     4→# This script runs all tests for the gemini package with various configurations\n     5→\n     6→set -e\n     7→\n     8→echo \"🧪 Running Gemini Package Tests\"\n     9→echo \"================================\"\n    10→\n    11→# Colors for output\n    12→RED='\\033[0;31m'\n    13→GREEN='\\033[0;32m' \n    14→YELLOW='\\033[1;33m'\n    15→BLUE='\\033[0;34m'\n    16→NC='\\033[0m' # No Color\n    17→\n    18→# Test configuration\n    19→PACKAGE_PATH=\"./gemini\"\n    20→COVERAGE_FILE=\"coverage.out\"\n    21→COVERAGE_HTML=\"coverage.html\"\n    22→\n    23→# Function to print colored output  \n    24→print_status() {\n    25→    echo -e \"${BLUE}[INFO]${NC} $1\"\n    26→}\n    27→\n    28→print_success() {\n    29→    echo -e \"${GREEN}[SUCCESS]${NC} $1\"\n    30→}\n    31→\n    32→print_warning() {\n    33→    echo -e \"${YELLOW}[WARNING]${NC} $1\"\n    34→}\n    35→\n    36→print_error() {\n    37→    echo -e \"${RED}[ERROR]${NC} $1\"\n    38→}\n    39→\n    40→# Check if we're in the right directory\n    41→if [[ ! -d \"gemini\" ]]; then\n    42→    print_error \"Please run this script from the azure-gateway root directory\"\n    43→    exit 1\n    44→fi\n    45→\n    46→print_status \"Starting test suite for gemini package...\"\n    47→\n    48→# 1. Run unit tests\n    49→print_status \"Running unit tests...\"\n    50→if go test -v $PACKAGE_PATH -run \"Test.*\" -short; then\n    51→    print_success \"Unit tests passed\"\n    52→else\n    53→    print_error \"Unit tests failed\"\n    54→    exit 1\n    55→fi\n    56→\n    57→echo \"\"\n    58→\n    59→# 2. Run integration tests  \n    60→print_status \"Running integration tests...\"\n    61→if go test -v $PACKAGE_PATH -run \"TestIntegration.*|TestConcurrent.*|TestPerformance.*\" -timeout 30s; then\n    62→    print_success \"Integration tests passed\"\n    63→else\n    64→    print_warning \"Integration tests had issues (this may be expected without GCP credentials)\"\n    65→fi\n    66→\n    67→echo \"\"\n    68→\n    69→# 3. Run tests with race detection\n    70→print_status \"Running tests with race detection...\"\n    71→if go test -race $PACKAGE_PATH -short; then\n    72→    print_success \"Race detection tests passed\"\n    73→else\n    74→    print_error \"Race detection found issues\"\n    75→    exit 1\n    76→fi\n    77→\n    78→echo \"\"\n    79→\n    80→# 4. Generate coverage report\n    81→print_status \"Generating coverage report...\"\n    82→if go test -coverprofile=$COVERAGE_FILE $PACKAGE_PATH; then\n    83→    COVERAGE=$(go tool cover -func=$COVERAGE_FILE | grep total | awk '{print $3}')\n    84→    print_success \"Coverage report generated: $COVERAGE\"\n    85→    \n    86→    # Generate HTML coverage report\n    87→    go tool cover -html=$COVERAGE_FILE -o $COVERAGE_HTML\n    88→    print_status \"HTML coverage report saved to $COVERAGE_HTML\"\n    89→    \n    90→    # Check coverage threshold\n    91→    COVERAGE_NUM=$(echo $COVERAGE | sed 's/%//')\n    92→    if (( $(echo \"$COVERAGE_NUM >= 80\" | bc -l) )); then\n    93→        print_success \"Coverage meets threshold (≥80%): $COVERAGE\"\n    94→    else\n    95→        print_warning \"Coverage below threshold (<80%): $COVERAGE\"\n    96→    fi\n    97→else\n    98→    print_error \"Failed to generate coverage report\"\n    99→fi\n   100→\n   101→echo \"\"\n   102→\n   103→# 5. Run benchmarks\n   104→print_status \"Running benchmarks...\"\n   105→if go test -bench=. -benchmem $PACKAGE_PATH -run=^# > benchmark_results.txt; then\n   106→    print_success \"Benchmarks completed (results saved to benchmark_results.txt)\"\n   107→    echo \"Top benchmark results:\"\n   108→    head -20 benchmark_results.txt\n   109→else\n   110→    print_warning \"Benchmarks had issues\"\n   111→fi\n   112→\n   113→echo \"\"\n   114→\n   115→# 6. Run specific test scenarios\n   116→print_status \"Running comprehensive test scenarios...\"\n   117→if go test -v $PACKAGE_PATH -run \"TestComprehensiveTestSuite\"; then\n   118→    print_success \"Comprehensive test scenarios passed\"\n   119→else\n   120→    print_warning \"Some comprehensive test scenarios failed\"\n   121→fi\n   122→\n   123→echo \"\"\n   124→\n   125→# 7. Lint and static analysis (if tools are available)\n   126→print_status \"Running static analysis...\"\n   127→\n   128→if command -v golint &> /dev/null; then\n   129→    print_status \"Running golint...\"\n   130→    golint $PACKAGE_PATH\n   131→else\n   132→    print_warning \"golint not available, skipping\"\n   133→fi\n   134→\n   135→if command -v go &> /dev/null; then\n   136→    print_status \"Running go vet...\"\n   137→    if go vet $PACKAGE_PATH; then\n   138→        print_success \"go vet passed\"\n   139→    else\n   140→        print_warning \"go vet found issues\"\n   141→    fi\n   142→fi\n   143→\n   144→if command -v staticcheck &> /dev/null; then\n   145→    print_status \"Running staticcheck...\"\n   146→    if staticcheck $PACKAGE_PATH; then\n   147→        print_success \"staticcheck passed\"\n   148→    else\n   149→        print_warning \"staticcheck found issues\"\n   150→    fi\n   151→else\n   152→    print_warning \"staticcheck not available, skipping\"\n   153→fi\n   154→\n   155→echo \"\"\n   156→\n   157→# 8. Summary\n   158→print_status \"Test Summary\"\n   159→print_status \"============\"\n   160→echo \"✅ Unit tests\"\n   161→echo \"⚠️  Integration tests (may require GCP credentials)\"\n   162→echo \"✅ Race detection\"\n   163→echo \"📊 Coverage report: $COVERAGE\"\n   164→echo \"🏃 Benchmarks\"\n   165→echo \"🧪 Comprehensive scenarios\"\n   166→echo \"🔍 Static analysis\"\n   167→\n   168→print_success \"Gemini package test suite completed!\"\n   169→\n   170→# Cleanup\n   171→rm -f $COVERAGE_FILE\n   172→\n   173→echo \"\"\n   174→print_status \"To view the HTML coverage report, open: $COVERAGE_HTML\"\n   175→print_status \"To view benchmark results, check: benchmark_results.txt\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"08f4ec0b-173f-4795-90a2-e71e353629b3","timestamp":"2025-08-18T03:19:28.120Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh","content":"#!/bin/bash\n\n# Gemini Package Test Runner\n# This script runs all tests for the gemini package with various configurations\n\nset -e\n\necho \"🧪 Running Gemini Package Tests\"\necho \"================================\"\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m' \nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\n# Test configuration\nPACKAGE_PATH=\"./gemini\"\nCOVERAGE_FILE=\"coverage.out\"\nCOVERAGE_HTML=\"coverage.html\"\n\n# Function to print colored output  \nprint_status() {\n    echo -e \"${BLUE}[INFO]${NC} $1\"\n}\n\nprint_success() {\n    echo -e \"${GREEN}[SUCCESS]${NC} $1\"\n}\n\nprint_warning() {\n    echo -e \"${YELLOW}[WARNING]${NC} $1\"\n}\n\nprint_error() {\n    echo -e \"${RED}[ERROR]${NC} $1\"\n}\n\n# Check if we're in the right directory\nif [[ ! -d \"gemini\" ]]; then\n    print_error \"Please run this script from the azure-gateway root directory\"\n    exit 1\nfi\n\nprint_status \"Starting test suite for gemini package...\"\n\n# 1. Run unit tests\nprint_status \"Running unit tests...\"\nif go test -v $PACKAGE_PATH -run \"Test.*\" -short; then\n    print_success \"Unit tests passed\"\nelse\n    print_error \"Unit tests failed\"\n    exit 1\nfi\n\necho \"\"\n\n# 2. Run integration tests  \nprint_status \"Running integration tests...\"\nif go test -v $PACKAGE_PATH -run \"TestIntegration.*|TestConcurrent.*|TestPerformance.*\" -timeout 30s; then\n    print_success \"Integration tests passed\"\nelse\n    print_warning \"Integration tests had issues (this may be expected without GCP credentials)\"\nfi\n\necho \"\"\n\n# 3. Run tests with race detection\nprint_status \"Running tests with race detection...\"\nif go test -race $PACKAGE_PATH -short; then\n    print_success \"Race detection tests passed\"\nelse\n    print_error \"Race detection found issues\"\n    exit 1\nfi\n\necho \"\"\n\n# 4. Generate coverage report\nprint_status \"Generating coverage report...\"\nif go test -coverprofile=$COVERAGE_FILE $PACKAGE_PATH; then\n    COVERAGE=$(go tool cover -func=$COVERAGE_FILE | grep total | awk '{print $3}')\n    print_success \"Coverage report generated: $COVERAGE\"\n    \n    # Generate HTML coverage report\n    go tool cover -html=$COVERAGE_FILE -o $COVERAGE_HTML\n    print_status \"HTML coverage report saved to $COVERAGE_HTML\"\n    \n    # Check coverage threshold\n    COVERAGE_NUM=$(echo $COVERAGE | sed 's/%//')\n    if (( $(echo \"$COVERAGE_NUM >= 80\" | bc -l) )); then\n        print_success \"Coverage meets threshold (≥80%): $COVERAGE\"\n    else\n        print_warning \"Coverage below threshold (<80%): $COVERAGE\"\n    fi\nelse\n    print_error \"Failed to generate coverage report\"\nfi\n\necho \"\"\n\n# 5. Run benchmarks\nprint_status \"Running benchmarks...\"\nif go test -bench=. -benchmem $PACKAGE_PATH -run=^# > benchmark_results.txt; then\n    print_success \"Benchmarks completed (results saved to benchmark_results.txt)\"\n    echo \"Top benchmark results:\"\n    head -20 benchmark_results.txt\nelse\n    print_warning \"Benchmarks had issues\"\nfi\n\necho \"\"\n\n# 6. Run specific test scenarios\nprint_status \"Running comprehensive test scenarios...\"\nif go test -v $PACKAGE_PATH -run \"TestComprehensiveTestSuite\"; then\n    print_success \"Comprehensive test scenarios passed\"\nelse\n    print_warning \"Some comprehensive test scenarios failed\"\nfi\n\necho \"\"\n\n# 7. Lint and static analysis (if tools are available)\nprint_status \"Running static analysis...\"\n\nif command -v golint &> /dev/null; then\n    print_status \"Running golint...\"\n    golint $PACKAGE_PATH\nelse\n    print_warning \"golint not available, skipping\"\nfi\n\nif command -v go &> /dev/null; then\n    print_status \"Running go vet...\"\n    if go vet $PACKAGE_PATH; then\n        print_success \"go vet passed\"\n    else\n        print_warning \"go vet found issues\"\n    fi\nfi\n\nif command -v staticcheck &> /dev/null; then\n    print_status \"Running staticcheck...\"\n    if staticcheck $PACKAGE_PATH; then\n        print_success \"staticcheck passed\"\n    else\n        print_warning \"staticcheck found issues\"\n    fi\nelse\n    print_warning \"staticcheck not available, skipping\"\nfi\n\necho \"\"\n\n# 8. Summary\nprint_status \"Test Summary\"\nprint_status \"============\"\necho \"✅ Unit tests\"\necho \"⚠️  Integration tests (may require GCP credentials)\"\necho \"✅ Race detection\"\necho \"📊 Coverage report: $COVERAGE\"\necho \"🏃 Benchmarks\"\necho \"🧪 Comprehensive scenarios\"\necho \"🔍 Static analysis\"\n\nprint_success \"Gemini package test suite completed!\"\n\n# Cleanup\nrm -f $COVERAGE_FILE\n\necho \"\"\nprint_status \"To view the HTML coverage report, open: $COVERAGE_HTML\"\nprint_status \"To view benchmark results, check: benchmark_results.txt\"","numLines":175,"startLine":1,"totalLines":175}}}
{"parentUuid":"08f4ec0b-173f-4795-90a2-e71e353629b3","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01S7FQVngSBjQM3BfKqZMERA","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now I'll update the references to gemini in the run_tests.sh file:"},{"type":"tool_use","id":"toolu_bdrk_01WKmisuqFmc84ZFbtUxhS1S","name":"MultiEdit","input":{"file_path":"/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh","edits":[{"old_string":"PACKAGE_PATH=\"./gemini\"","new_string":"PACKAGE_PATH=\"./gcp\""},{"old_string":"if [[ ! -d \"gemini\" ]]; then","new_string":"if [[ ! -d \"gcp\" ]]; then"},{"old_string":"print_status \"Starting test suite for gemini package...\"","new_string":"print_status \"Starting test suite for gcp package...\""},{"old_string":"print_success \"Gemini package test suite completed!\"","new_string":"print_success \"GCP package test suite completed!\""}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2078,"cache_read_input_tokens":33388,"output_tokens":304}},"type":"assistant","uuid":"04c25294-f906-49eb-9ec8-feaf1937f95b","timestamp":"2025-08-18T03:19:34.215Z"}
{"parentUuid":"04c25294-f906-49eb-9ec8-feaf1937f95b","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01WKmisuqFmc84ZFbtUxhS1S","type":"tool_result","content":"Applied 4 edits to /Users/mtk19651/project/azure-gateway/gcp/run_tests.sh:\n1. Replaced \"PACKAGE_PATH=\"./gemini\"\" with \"PACKAGE_PATH=\"./gcp\"\"\n2. Replaced \"if [[ ! -d \"gemini\" ]]; then\" with \"if [[ ! -d \"gcp\" ]]; then\"\n3. Replaced \"print_status \"Starting test suite for gemini packa...\" with \"print_status \"Starting test suite for gcp package....\"\n4. Replaced \"print_success \"Gemini package test suite completed...\" with \"print_success \"GCP package test suite completed!\"\""}]},"uuid":"d9ca393f-9cc2-4c14-9af8-349629fb00d9","timestamp":"2025-08-18T03:19:34.253Z","toolUseResult":{"filePath":"/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh","edits":[{"old_string":"PACKAGE_PATH=\"./gemini\"","new_string":"PACKAGE_PATH=\"./gcp\"","replace_all":false},{"old_string":"if [[ ! -d \"gemini\" ]]; then","new_string":"if [[ ! -d \"gcp\" ]]; then","replace_all":false},{"old_string":"print_status \"Starting test suite for gemini package...\"","new_string":"print_status \"Starting test suite for gcp package...\"","replace_all":false},{"old_string":"print_success \"Gemini package test suite completed!\"","new_string":"print_success \"GCP package test suite completed!\"","replace_all":false}],"originalFileContents":"#!/bin/bash\n\n# Gemini Package Test Runner\n# This script runs all tests for the gemini package with various configurations\n\nset -e\n\necho \"🧪 Running Gemini Package Tests\"\necho \"================================\"\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m' \nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\n# Test configuration\nPACKAGE_PATH=\"./gemini\"\nCOVERAGE_FILE=\"coverage.out\"\nCOVERAGE_HTML=\"coverage.html\"\n\n# Function to print colored output  \nprint_status() {\n    echo -e \"${BLUE}[INFO]${NC} $1\"\n}\n\nprint_success() {\n    echo -e \"${GREEN}[SUCCESS]${NC} $1\"\n}\n\nprint_warning() {\n    echo -e \"${YELLOW}[WARNING]${NC} $1\"\n}\n\nprint_error() {\n    echo -e \"${RED}[ERROR]${NC} $1\"\n}\n\n# Check if we're in the right directory\nif [[ ! -d \"gemini\" ]]; then\n    print_error \"Please run this script from the azure-gateway root directory\"\n    exit 1\nfi\n\nprint_status \"Starting test suite for gemini package...\"\n\n# 1. Run unit tests\nprint_status \"Running unit tests...\"\nif go test -v $PACKAGE_PATH -run \"Test.*\" -short; then\n    print_success \"Unit tests passed\"\nelse\n    print_error \"Unit tests failed\"\n    exit 1\nfi\n\necho \"\"\n\n# 2. Run integration tests  \nprint_status \"Running integration tests...\"\nif go test -v $PACKAGE_PATH -run \"TestIntegration.*|TestConcurrent.*|TestPerformance.*\" -timeout 30s; then\n    print_success \"Integration tests passed\"\nelse\n    print_warning \"Integration tests had issues (this may be expected without GCP credentials)\"\nfi\n\necho \"\"\n\n# 3. Run tests with race detection\nprint_status \"Running tests with race detection...\"\nif go test -race $PACKAGE_PATH -short; then\n    print_success \"Race detection tests passed\"\nelse\n    print_error \"Race detection found issues\"\n    exit 1\nfi\n\necho \"\"\n\n# 4. Generate coverage report\nprint_status \"Generating coverage report...\"\nif go test -coverprofile=$COVERAGE_FILE $PACKAGE_PATH; then\n    COVERAGE=$(go tool cover -func=$COVERAGE_FILE | grep total | awk '{print $3}')\n    print_success \"Coverage report generated: $COVERAGE\"\n    \n    # Generate HTML coverage report\n    go tool cover -html=$COVERAGE_FILE -o $COVERAGE_HTML\n    print_status \"HTML coverage report saved to $COVERAGE_HTML\"\n    \n    # Check coverage threshold\n    COVERAGE_NUM=$(echo $COVERAGE | sed 's/%//')\n    if (( $(echo \"$COVERAGE_NUM >= 80\" | bc -l) )); then\n        print_success \"Coverage meets threshold (≥80%): $COVERAGE\"\n    else\n        print_warning \"Coverage below threshold (<80%): $COVERAGE\"\n    fi\nelse\n    print_error \"Failed to generate coverage report\"\nfi\n\necho \"\"\n\n# 5. Run benchmarks\nprint_status \"Running benchmarks...\"\nif go test -bench=. -benchmem $PACKAGE_PATH -run=^# > benchmark_results.txt; then\n    print_success \"Benchmarks completed (results saved to benchmark_results.txt)\"\n    echo \"Top benchmark results:\"\n    head -20 benchmark_results.txt\nelse\n    print_warning \"Benchmarks had issues\"\nfi\n\necho \"\"\n\n# 6. Run specific test scenarios\nprint_status \"Running comprehensive test scenarios...\"\nif go test -v $PACKAGE_PATH -run \"TestComprehensiveTestSuite\"; then\n    print_success \"Comprehensive test scenarios passed\"\nelse\n    print_warning \"Some comprehensive test scenarios failed\"\nfi\n\necho \"\"\n\n# 7. Lint and static analysis (if tools are available)\nprint_status \"Running static analysis...\"\n\nif command -v golint &> /dev/null; then\n    print_status \"Running golint...\"\n    golint $PACKAGE_PATH\nelse\n    print_warning \"golint not available, skipping\"\nfi\n\nif command -v go &> /dev/null; then\n    print_status \"Running go vet...\"\n    if go vet $PACKAGE_PATH; then\n        print_success \"go vet passed\"\n    else\n        print_warning \"go vet found issues\"\n    fi\nfi\n\nif command -v staticcheck &> /dev/null; then\n    print_status \"Running staticcheck...\"\n    if staticcheck $PACKAGE_PATH; then\n        print_success \"staticcheck passed\"\n    else\n        print_warning \"staticcheck found issues\"\n    fi\nelse\n    print_warning \"staticcheck not available, skipping\"\nfi\n\necho \"\"\n\n# 8. Summary\nprint_status \"Test Summary\"\nprint_status \"============\"\necho \"✅ Unit tests\"\necho \"⚠️  Integration tests (may require GCP credentials)\"\necho \"✅ Race detection\"\necho \"📊 Coverage report: $COVERAGE\"\necho \"🏃 Benchmarks\"\necho \"🧪 Comprehensive scenarios\"\necho \"🔍 Static analysis\"\n\nprint_success \"Gemini package test suite completed!\"\n\n# Cleanup\nrm -f $COVERAGE_FILE\n\necho \"\"\nprint_status \"To view the HTML coverage report, open: $COVERAGE_HTML\"\nprint_status \"To view benchmark results, check: benchmark_results.txt\"","structuredPatch":[{"oldStart":16,"oldLines":7,"newStart":16,"newLines":7,"lines":[" NC='\\033[0m' # No Color"," "," # Test configuration","-PACKAGE_PATH=\"./gemini\"","+PACKAGE_PATH=\"./gcp\""," COVERAGE_FILE=\"coverage.out\""," COVERAGE_HTML=\"coverage.html\""," "]},{"oldStart":38,"oldLines":12,"newStart":38,"newLines":12,"lines":[" }"," "," # Check if we're in the right directory","-if [[ ! -d \"gemini\" ]]; then","+if [[ ! -d \"gcp\" ]]; then","     print_error \"Please run this script from the azure-gateway root directory\"","     exit 1"," fi"," ","-print_status \"Starting test suite for gemini package...\"","+print_status \"Starting test suite for gcp package...\""," "," # 1. Run unit tests"," print_status \"Running unit tests...\""]},{"oldStart":165,"oldLines":7,"newStart":165,"newLines":7,"lines":[" echo \"🧪 Comprehensive scenarios\""," echo \"🔍 Static analysis\""," ","-print_success \"Gemini package test suite completed!\"","+print_success \"GCP package test suite completed!\""," "," # Cleanup"," rm -f $COVERAGE_FILE"]}],"userModified":false}}
{"parentUuid":"d9ca393f-9cc2-4c14-9af8-349629fb00d9","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01JB7C58LU4UupyMHfZf6L6x","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Let me also update the header comments:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":438,"cache_read_input_tokens":35466,"output_tokens":1}},"type":"assistant","uuid":"47d17d0c-9754-4ad4-ab6c-90c92ee4fd48","timestamp":"2025-08-18T03:19:39.515Z"}
{"parentUuid":"47d17d0c-9754-4ad4-ab6c-90c92ee4fd48","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01JB7C58LU4UupyMHfZf6L6x","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01VGm9hSwFGzX1HBn4kFU3kC","name":"Edit","input":{"file_path":"/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh","old_string":"# Gemini Package Test Runner\n# This script runs all tests for the gemini package with various configurations","new_string":"# GCP Package Test Runner\n# This script runs all tests for the gcp package with various configurations"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":438,"cache_read_input_tokens":35466,"output_tokens":162}},"type":"assistant","uuid":"dee96387-9767-4d79-bb2f-258f9af87680","timestamp":"2025-08-18T03:19:40.592Z"}
{"parentUuid":"dee96387-9767-4d79-bb2f-258f9af87680","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01VGm9hSwFGzX1HBn4kFU3kC","type":"tool_result","content":"The file /Users/mtk19651/project/azure-gateway/gcp/run_tests.sh has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→#!/bin/bash\n     2→\n     3→# GCP Package Test Runner\n     4→# This script runs all tests for the gcp package with various configurations\n     5→\n     6→set -e\n     7→\n     8→echo \"🧪 Running Gemini Package Tests\""}]},"uuid":"5385c994-9476-4a1b-9281-041695dcd4b8","timestamp":"2025-08-18T03:19:40.613Z","toolUseResult":{"filePath":"/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh","oldString":"# Gemini Package Test Runner\n# This script runs all tests for the gemini package with various configurations","newString":"# GCP Package Test Runner\n# This script runs all tests for the gcp package with various configurations","originalFile":"#!/bin/bash\n\n# Gemini Package Test Runner\n# This script runs all tests for the gemini package with various configurations\n\nset -e\n\necho \"🧪 Running Gemini Package Tests\"\necho \"================================\"\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m' \nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\n# Test configuration\nPACKAGE_PATH=\"./gcp\"\nCOVERAGE_FILE=\"coverage.out\"\nCOVERAGE_HTML=\"coverage.html\"\n\n# Function to print colored output  \nprint_status() {\n    echo -e \"${BLUE}[INFO]${NC} $1\"\n}\n\nprint_success() {\n    echo -e \"${GREEN}[SUCCESS]${NC} $1\"\n}\n\nprint_warning() {\n    echo -e \"${YELLOW}[WARNING]${NC} $1\"\n}\n\nprint_error() {\n    echo -e \"${RED}[ERROR]${NC} $1\"\n}\n\n# Check if we're in the right directory\nif [[ ! -d \"gcp\" ]]; then\n    print_error \"Please run this script from the azure-gateway root directory\"\n    exit 1\nfi\n\nprint_status \"Starting test suite for gcp package...\"\n\n# 1. Run unit tests\nprint_status \"Running unit tests...\"\nif go test -v $PACKAGE_PATH -run \"Test.*\" -short; then\n    print_success \"Unit tests passed\"\nelse\n    print_error \"Unit tests failed\"\n    exit 1\nfi\n\necho \"\"\n\n# 2. Run integration tests  \nprint_status \"Running integration tests...\"\nif go test -v $PACKAGE_PATH -run \"TestIntegration.*|TestConcurrent.*|TestPerformance.*\" -timeout 30s; then\n    print_success \"Integration tests passed\"\nelse\n    print_warning \"Integration tests had issues (this may be expected without GCP credentials)\"\nfi\n\necho \"\"\n\n# 3. Run tests with race detection\nprint_status \"Running tests with race detection...\"\nif go test -race $PACKAGE_PATH -short; then\n    print_success \"Race detection tests passed\"\nelse\n    print_error \"Race detection found issues\"\n    exit 1\nfi\n\necho \"\"\n\n# 4. Generate coverage report\nprint_status \"Generating coverage report...\"\nif go test -coverprofile=$COVERAGE_FILE $PACKAGE_PATH; then\n    COVERAGE=$(go tool cover -func=$COVERAGE_FILE | grep total | awk '{print $3}')\n    print_success \"Coverage report generated: $COVERAGE\"\n    \n    # Generate HTML coverage report\n    go tool cover -html=$COVERAGE_FILE -o $COVERAGE_HTML\n    print_status \"HTML coverage report saved to $COVERAGE_HTML\"\n    \n    # Check coverage threshold\n    COVERAGE_NUM=$(echo $COVERAGE | sed 's/%//')\n    if (( $(echo \"$COVERAGE_NUM >= 80\" | bc -l) )); then\n        print_success \"Coverage meets threshold (≥80%): $COVERAGE\"\n    else\n        print_warning \"Coverage below threshold (<80%): $COVERAGE\"\n    fi\nelse\n    print_error \"Failed to generate coverage report\"\nfi\n\necho \"\"\n\n# 5. Run benchmarks\nprint_status \"Running benchmarks...\"\nif go test -bench=. -benchmem $PACKAGE_PATH -run=^# > benchmark_results.txt; then\n    print_success \"Benchmarks completed (results saved to benchmark_results.txt)\"\n    echo \"Top benchmark results:\"\n    head -20 benchmark_results.txt\nelse\n    print_warning \"Benchmarks had issues\"\nfi\n\necho \"\"\n\n# 6. Run specific test scenarios\nprint_status \"Running comprehensive test scenarios...\"\nif go test -v $PACKAGE_PATH -run \"TestComprehensiveTestSuite\"; then\n    print_success \"Comprehensive test scenarios passed\"\nelse\n    print_warning \"Some comprehensive test scenarios failed\"\nfi\n\necho \"\"\n\n# 7. Lint and static analysis (if tools are available)\nprint_status \"Running static analysis...\"\n\nif command -v golint &> /dev/null; then\n    print_status \"Running golint...\"\n    golint $PACKAGE_PATH\nelse\n    print_warning \"golint not available, skipping\"\nfi\n\nif command -v go &> /dev/null; then\n    print_status \"Running go vet...\"\n    if go vet $PACKAGE_PATH; then\n        print_success \"go vet passed\"\n    else\n        print_warning \"go vet found issues\"\n    fi\nfi\n\nif command -v staticcheck &> /dev/null; then\n    print_status \"Running staticcheck...\"\n    if staticcheck $PACKAGE_PATH; then\n        print_success \"staticcheck passed\"\n    else\n        print_warning \"staticcheck found issues\"\n    fi\nelse\n    print_warning \"staticcheck not available, skipping\"\nfi\n\necho \"\"\n\n# 8. Summary\nprint_status \"Test Summary\"\nprint_status \"============\"\necho \"✅ Unit tests\"\necho \"⚠️  Integration tests (may require GCP credentials)\"\necho \"✅ Race detection\"\necho \"📊 Coverage report: $COVERAGE\"\necho \"🏃 Benchmarks\"\necho \"🧪 Comprehensive scenarios\"\necho \"🔍 Static analysis\"\n\nprint_success \"GCP package test suite completed!\"\n\n# Cleanup\nrm -f $COVERAGE_FILE\n\necho \"\"\nprint_status \"To view the HTML coverage report, open: $COVERAGE_HTML\"\nprint_status \"To view benchmark results, check: benchmark_results.txt\"","structuredPatch":[{"oldStart":1,"oldLines":7,"newStart":1,"newLines":7,"lines":[" #!/bin/bash"," ","-# Gemini Package Test Runner","-# This script runs all tests for the gemini package with various configurations","+# GCP Package Test Runner","+# This script runs all tests for the gcp package with various configurations"," "," set -e"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5385c994-9476-4a1b-9281-041695dcd4b8","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_019v4Uch5SzkiG4btirU1pDy","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_019CYoMp8kBfaeUqK6Dg4UXZ","name":"Edit","input":{"file_path":"/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh","old_string":"echo \"🧪 Running Gemini Package Tests\"","new_string":"echo \"🧪 Running GCP Package Tests\""}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":293,"cache_read_input_tokens":35904,"output_tokens":135}},"type":"assistant","uuid":"5d978fa3-3b21-4de7-abc1-9eb9f5384507","timestamp":"2025-08-18T03:19:43.903Z"}
{"parentUuid":"5d978fa3-3b21-4de7-abc1-9eb9f5384507","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_019CYoMp8kBfaeUqK6Dg4UXZ","type":"tool_result","content":"The file /Users/mtk19651/project/azure-gateway/gcp/run_tests.sh has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     4→# This script runs all tests for the gcp package with various configurations\n     5→\n     6→set -e\n     7→\n     8→echo \"🧪 Running GCP Package Tests\"\n     9→echo \"================================\"\n    10→\n    11→# Colors for output\n    12→RED='\\033[0;31m'"}]},"uuid":"f13930ea-62e3-4cc9-8e17-426df07abec6","timestamp":"2025-08-18T03:19:43.929Z","toolUseResult":{"filePath":"/Users/mtk19651/project/azure-gateway/gcp/run_tests.sh","oldString":"echo \"🧪 Running Gemini Package Tests\"","newString":"echo \"🧪 Running GCP Package Tests\"","originalFile":"#!/bin/bash\n\n# GCP Package Test Runner\n# This script runs all tests for the gcp package with various configurations\n\nset -e\n\necho \"🧪 Running Gemini Package Tests\"\necho \"================================\"\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m' \nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\n# Test configuration\nPACKAGE_PATH=\"./gcp\"\nCOVERAGE_FILE=\"coverage.out\"\nCOVERAGE_HTML=\"coverage.html\"\n\n# Function to print colored output  \nprint_status() {\n    echo -e \"${BLUE}[INFO]${NC} $1\"\n}\n\nprint_success() {\n    echo -e \"${GREEN}[SUCCESS]${NC} $1\"\n}\n\nprint_warning() {\n    echo -e \"${YELLOW}[WARNING]${NC} $1\"\n}\n\nprint_error() {\n    echo -e \"${RED}[ERROR]${NC} $1\"\n}\n\n# Check if we're in the right directory\nif [[ ! -d \"gcp\" ]]; then\n    print_error \"Please run this script from the azure-gateway root directory\"\n    exit 1\nfi\n\nprint_status \"Starting test suite for gcp package...\"\n\n# 1. Run unit tests\nprint_status \"Running unit tests...\"\nif go test -v $PACKAGE_PATH -run \"Test.*\" -short; then\n    print_success \"Unit tests passed\"\nelse\n    print_error \"Unit tests failed\"\n    exit 1\nfi\n\necho \"\"\n\n# 2. Run integration tests  \nprint_status \"Running integration tests...\"\nif go test -v $PACKAGE_PATH -run \"TestIntegration.*|TestConcurrent.*|TestPerformance.*\" -timeout 30s; then\n    print_success \"Integration tests passed\"\nelse\n    print_warning \"Integration tests had issues (this may be expected without GCP credentials)\"\nfi\n\necho \"\"\n\n# 3. Run tests with race detection\nprint_status \"Running tests with race detection...\"\nif go test -race $PACKAGE_PATH -short; then\n    print_success \"Race detection tests passed\"\nelse\n    print_error \"Race detection found issues\"\n    exit 1\nfi\n\necho \"\"\n\n# 4. Generate coverage report\nprint_status \"Generating coverage report...\"\nif go test -coverprofile=$COVERAGE_FILE $PACKAGE_PATH; then\n    COVERAGE=$(go tool cover -func=$COVERAGE_FILE | grep total | awk '{print $3}')\n    print_success \"Coverage report generated: $COVERAGE\"\n    \n    # Generate HTML coverage report\n    go tool cover -html=$COVERAGE_FILE -o $COVERAGE_HTML\n    print_status \"HTML coverage report saved to $COVERAGE_HTML\"\n    \n    # Check coverage threshold\n    COVERAGE_NUM=$(echo $COVERAGE | sed 's/%//')\n    if (( $(echo \"$COVERAGE_NUM >= 80\" | bc -l) )); then\n        print_success \"Coverage meets threshold (≥80%): $COVERAGE\"\n    else\n        print_warning \"Coverage below threshold (<80%): $COVERAGE\"\n    fi\nelse\n    print_error \"Failed to generate coverage report\"\nfi\n\necho \"\"\n\n# 5. Run benchmarks\nprint_status \"Running benchmarks...\"\nif go test -bench=. -benchmem $PACKAGE_PATH -run=^# > benchmark_results.txt; then\n    print_success \"Benchmarks completed (results saved to benchmark_results.txt)\"\n    echo \"Top benchmark results:\"\n    head -20 benchmark_results.txt\nelse\n    print_warning \"Benchmarks had issues\"\nfi\n\necho \"\"\n\n# 6. Run specific test scenarios\nprint_status \"Running comprehensive test scenarios...\"\nif go test -v $PACKAGE_PATH -run \"TestComprehensiveTestSuite\"; then\n    print_success \"Comprehensive test scenarios passed\"\nelse\n    print_warning \"Some comprehensive test scenarios failed\"\nfi\n\necho \"\"\n\n# 7. Lint and static analysis (if tools are available)\nprint_status \"Running static analysis...\"\n\nif command -v golint &> /dev/null; then\n    print_status \"Running golint...\"\n    golint $PACKAGE_PATH\nelse\n    print_warning \"golint not available, skipping\"\nfi\n\nif command -v go &> /dev/null; then\n    print_status \"Running go vet...\"\n    if go vet $PACKAGE_PATH; then\n        print_success \"go vet passed\"\n    else\n        print_warning \"go vet found issues\"\n    fi\nfi\n\nif command -v staticcheck &> /dev/null; then\n    print_status \"Running staticcheck...\"\n    if staticcheck $PACKAGE_PATH; then\n        print_success \"staticcheck passed\"\n    else\n        print_warning \"staticcheck found issues\"\n    fi\nelse\n    print_warning \"staticcheck not available, skipping\"\nfi\n\necho \"\"\n\n# 8. Summary\nprint_status \"Test Summary\"\nprint_status \"============\"\necho \"✅ Unit tests\"\necho \"⚠️  Integration tests (may require GCP credentials)\"\necho \"✅ Race detection\"\necho \"📊 Coverage report: $COVERAGE\"\necho \"🏃 Benchmarks\"\necho \"🧪 Comprehensive scenarios\"\necho \"🔍 Static analysis\"\n\nprint_success \"GCP package test suite completed!\"\n\n# Cleanup\nrm -f $COVERAGE_FILE\n\necho \"\"\nprint_status \"To view the HTML coverage report, open: $COVERAGE_HTML\"\nprint_status \"To view benchmark results, check: benchmark_results.txt\"","structuredPatch":[{"oldStart":5,"oldLines":7,"newStart":5,"newLines":7,"lines":[" "," set -e"," ","-echo \"🧪 Running Gemini Package Tests\"","+echo \"🧪 Running GCP Package Tests\""," echo \"================================\""," "," # Colors for output"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"f13930ea-62e3-4cc9-8e17-426df07abec6","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_014z4BaPQtAuL9JexrBJvURY","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_bdrk_01GWUU3bRBy22yrZzX9Un1Ci","name":"TodoWrite","input":{"todos":[{"id":"1","content":"Rename gemini folder to gcp","status":"completed"},{"id":"2","content":"Update any import paths that reference the gemini folder","status":"completed"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":4040,"cache_read_input_tokens":32546,"output_tokens":106}},"type":"assistant","uuid":"b417c824-c904-49d0-9dd3-4254f65231d6","timestamp":"2025-08-18T03:19:48.280Z"}
{"parentUuid":"b417c824-c904-49d0-9dd3-4254f65231d6","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01GWUU3bRBy22yrZzX9Un1Ci","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"0fed4ccd-db01-4b51-a948-03395e655c47","timestamp":"2025-08-18T03:19:48.296Z","toolUseResult":{"oldTodos":[{"content":"Rename gemini folder to gcp","status":"completed","id":"1"},{"content":"Update any import paths that reference the gemini folder","status":"in_progress","id":"2"}],"newTodos":[{"content":"Rename gemini folder to gcp","status":"completed","id":"1"},{"content":"Update any import paths that reference the gemini folder","status":"completed","id":"2"}]}}
{"parentUuid":"0fed4ccd-db01-4b51-a948-03395e655c47","isSidechain":false,"userType":"external","cwd":"/Users/mtk19651/project/azure-gateway","sessionId":"f26d0c06-d890-4323-b56c-7baa4e02b014","version":"1.0.83","gitBranch":"main","message":{"id":"msg_bdrk_01J9Anesh1m6iXGhxr7H9pA5","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Done! I've successfully:\n\n1. ✅ Renamed the `gemini` folder to `gcp`\n2. ✅ Updated the import path in `cmd/mlop-azure-gateway/main.go` from `gitea.mediatek.inc/davinci/azure-gateway/gemini` to `gitea.mediatek.inc/davinci/azure-gateway/gcp`\n3. ✅ Updated the package function calls from `gemini.` to `gcp.` in the main.go file\n4. ✅ Updated the test script `gcp/run_tests.sh` to reference the correct folder path and package name\n\nThe folder has been successfully renamed to `gcp` while keeping all the code references to \"gemini\" intact as requested."}],"stop_reason":"end_turn","stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":22476,"cache_read_input_tokens":14349,"output_tokens":182}},"type":"assistant","uuid":"13f1336f-c3e2-430f-a1f1-ffe0efb79df2","timestamp":"2025-08-18T03:19:54.450Z"}
